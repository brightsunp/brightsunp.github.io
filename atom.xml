<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>捡贝壳的男孩</title>
  <icon>https://www.gravatar.com/avatar/fedf67ea89f192d1943d4401215cc53e</icon>
  <subtitle>功不唐捐。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://brightsunp.github.io/"/>
  <updated>2020-08-03T07:13:45.668Z</updated>
  <id>https://brightsunp.github.io/</id>
  
  <author>
    <name>sun品品</name>
    <email>sunp@whu.edu.cn</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Demo总结</title>
    <link href="https://brightsunp.github.io/2020/08/03/demo%E6%80%BB%E7%BB%93/"/>
    <id>https://brightsunp.github.io/2020/08/03/demo总结/</id>
    <published>2020-08-03T05:16:23.000Z</published>
    <updated>2020-08-03T07:13:45.668Z</updated>
    
    <content type="html"><![CDATA[<p>我们开发新产品的节奏很快，每2周1个sprint，在结束的那个周五需要做demo。从5月份开始到现在，不知不觉过了7个sprint，我已经进行了4次demo。这个过程对表达能力是很大的考验，不光是口语方面，还有逻辑上的清晰度。</p><h4 id="demo-1"><a href="#demo-1" class="headerlink" title="demo 1"></a>demo 1</h4><p>第一次demo体现了小组的开发进度，在repo框架搭好的基础上，我们很快实现了CRUD的功能，所以demo目的就是展示这些api，以及团队协作的过程。</p><ul><li><strong>闪光点</strong>：预先dry run，加了context和小组分工的介绍；提前准备和练习，表达很流畅。</li><li><strong>不足点</strong>：可以用swagger更清晰地展示api文档。</li></ul><h4 id="demo-2"><a href="#demo-2" class="headerlink" title="demo 2"></a>demo 2</h4><p>第二次demo是作为svt framework的首个用户，我们以甲方的角色帮infra team定位和解决bug，充分体现了跨组的团队合作。</p><ul><li><strong>闪光点</strong>：分工明确，没有占用其他人的功劳；运行测试用例，实时展示svt工具的强大功能。</li><li><strong>不足点</strong>：可以更好地体现出test cases的设计逻辑和实现细节。</li></ul><h4 id="demo-3"><a href="#demo-3" class="headerlink" title="demo 3"></a>demo 3</h4><p>第三次联合demo，我们原先对另一个产品的认识不足，导致开发方向有变。幸运的是，我们很快实现了备用方案，然后和其他team联调，走通了一整个流程。</p><ul><li><strong>闪光点</strong>：结合流程图，描述了完整的数据流，我们主要做了哪些工作，以及后续的工作重点。</li><li><strong>不足点</strong>：可以讲的更从容、有条理。</li></ul><h4 id="demo-4"><a href="#demo-4" class="headerlink" title="demo 4"></a>demo 4</h4><p>第四次demo是压力、性能测试，我们组率先做了这件事，原因是service逻辑相对简单，但对性能的要求特别高。</p><ul><li><strong>闪光点</strong>：展示了新工具的使用，日志的查询，以及分析问题的思路。</li><li><strong>不足点</strong>：可以讲的更从容、有条理；在总结的时候，应该向大家传达这项工作的意义所在。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>纵观这几次demo的完成度，无不体现了“凡事预则立，不预则废”的道理，多花时间准备是肯定没错的。另外还有几点，如果再有demo的机会，我一定会照着执行：</p><ul><li>写一个简单的ppt。一页封面，写demo的主题；一页内容，将demo想要表达的几个点提炼出来。这样逻辑会清晰很多，讲解者和听众都能从中获益。</li><li>找听众提前练习。有这个条件最好，因为听众的第一反馈会给到很多有帮助的建议。</li><li>避免浪费时间。复制和备份并不占用资源，提前准备好demo用到的材料，不至于浪费听众的时间，而且那样也会让自己尴尬。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们开发新产品的节奏很快，每2周1个sprint，在结束的那个周五需要做demo。从5月份开始到现在，不知不觉过了7个sprint，我已经进行了4次demo。这个过程对表达能力是很大的考验，不光是口语方面，还有逻辑上的清晰度。&lt;/p&gt;
&lt;h4 id=&quot;demo-1&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="随笔" scheme="https://brightsunp.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>C#学习笔记</title>
    <link href="https://brightsunp.github.io/2019/03/19/C-sharp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://brightsunp.github.io/2019/03/19/C-sharp学习笔记/</id>
    <published>2019-03-19T09:04:14.000Z</published>
    <updated>2020-08-03T07:14:22.365Z</updated>
    
    <content type="html"><![CDATA[<p>既然加入了微软，我自然要熟悉C#编程；幸运的是，我以前在实验室就做过WPF项目，而且作为Python重度用户，同样是面向对象的语言，学起来一点都不难。<br>本文主要对C#的独特之处进行了总结。</p><h2 id="1-C-数据类型"><a href="#1-C-数据类型" class="headerlink" title="1 C#数据类型"></a>1 C#数据类型</h2><h3 id="1-1-值类型"><a href="#1-1-值类型" class="headerlink" title="1.1 值类型"></a>1.1 值类型</h3><p><code>Value types</code> 直接分配一个值，派生自 <code>System.ValueType</code> 类。</p><ul><li><code>byte/short/int/long</code> 分别表示8位无符号整数、16/32/64位有符号整数。根据有无符号，对应的还有 <code>sbyte/ushort/uint/ulong</code>。</li><li><code>char</code> 表示16位Unicode字符，默认值为’\0’；<code>bool</code> 默认值为False。</li><li><code>float/double/decimal</code> 分别表示32位单精度浮点型、64位双精度浮点型、128位精确的十进制值。</li></ul><h3 id="1-2-引用类型"><a href="#1-2-引用类型" class="headerlink" title="1.2 引用类型"></a>1.2 引用类型</h3><p><code>Reference types</code> 不包含存储在变量中的实际数据，但包含对变量的引用。</p><ul><li><code>Object(System.Object)</code> 可以被分配任何其他类型的值。将值类型转换为对象类型，称为<strong>装箱</strong>；反过来，将对象类型转换为值类型，称为<strong>拆箱</strong>。</li><li><code>Dynamic</code> 动态数据类型可以存储任何类型的值，该变量的类型检查发生在<strong>运行</strong>时，而对象类型变量的类型检查发生在<strong>编译</strong>时。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dynamic &lt;variable&gt; = value;</span><br></pre></td></tr></table></figure><ul><li><code>String(System.String)</code> 分配任何字符串值，派生自Object类。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// contains &apos;\\&apos;</span><br><span class="line">string s = @&quot;C:\Windows&quot;;</span><br><span class="line"></span><br><span class="line">// contains &apos;\n&apos;</span><br><span class="line">string s = @&quot;&lt;script type=&quot;&quot;text/javascript&quot;&quot;&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">    --&gt;</span><br><span class="line">&lt;/script&gt;&quot;;</span><br></pre></td></tr></table></figure><ul><li><code>class/interface/delegate</code> 用户自定义引用类型。</li></ul><h3 id="1-3-指针类型"><a href="#1-3-指针类型" class="headerlink" title="1.3 指针类型"></a>1.3 指针类型</h3><p><code>Pointer types</code> 存储另一种类型的内存地址，与C或C++中的指针有相同的功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type* identifier;</span><br></pre></td></tr></table></figure><h3 id="1-4-可空类型"><a href="#1-4-可空类型" class="headerlink" title="1.4 可空类型"></a>1.4 可空类型</h3><ul><li><code>Nullable</code> 特殊的数据类型，表示其基础值类型正常范围内的值，再加上一个null值。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;datatype&gt;? &lt;variable&gt; = null;</span><br></pre></td></tr></table></figure><ul><li><code>??</code> 合并运算符，把操作数类型隐式转换为另一个可空（或不可空）类型的操作数类型。如果第一个操作数为null，则返回第二个操作数的值，否则返回第一个操作数的值。</li></ul><h2 id="2-C-封装"><a href="#2-C-封装" class="headerlink" title="2 C#封装"></a>2 C#封装</h2><p>抽象和封装是面向对象程序设计的相关特性。抽象允许相关信息的可视化，封装则使开发者实现<strong>所需级别的抽象</strong>。</p><h3 id="2-1-访问修饰符"><a href="#2-1-访问修饰符" class="headerlink" title="2.1 访问修饰符"></a>2.1 访问修饰符</h3><ul><li><code>Public</code> 类的公有成员（变量/函数）可以被外部类访问。</li><li><code>Private</code> 只有同一个类中的函数可以访问它的私有成员，即使类的实例也不能访问它的私有成员。如果不指定访问修饰符，默认为private。</li><li><code>Internal</code> 允许<strong>当前程序</strong>中的其他函数和对象访问。</li><li><code>Protected</code> 允许子类访问它的<strong>基类</strong>的成员变量和成员函数，这有利于实现继承。</li><li><code>Protected Internal</code> 允许在本类、派生类或当前程序中访问。</li></ul><h3 id="2-2-参数传递"><a href="#2-2-参数传递" class="headerlink" title="2.2 参数传递"></a>2.2 参数传递</h3><ul><li>值参数。这是默认的传参方式，在调用方法时，会为每个值参数创建一个新的存储位置；实参的值复制给形参，但它们是两个不同内存中的值。</li><li>引用参数。对变量的内存位置的引用，即不会为参数创建新的存储位置；使用 <code>ref</code> 关键字来声明。</li><li>输出参数。该参数可以接收一个返回值，从而实现方法的多返回值；使用 <code>out</code> 关键字来声明。</li></ul><h2 id="3-C-高级"><a href="#3-C-高级" class="headerlink" title="3 C#高级"></a>3 C#高级</h2><h3 id="3-1-特性"><a href="#3-1-特性" class="headerlink" title="3.1 特性"></a>3.1 特性</h3><p><code>Attribute(System.Attribute)</code> 是用于在运行时传递程序中各种元素的行为信息的声明性标签，主要功能是自描述。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[attribute(positional_paras, named_para=value, ...)]</span><br><span class="line">element</span><br></pre></td></tr></table></figure><h4 id="3-1-1-预定义特性"><a href="#3-1-1-预定义特性" class="headerlink" title="3.1.1 预定义特性"></a>3.1.1 预定义特性</h4><ul><li><code>AttributeUsage</code> 描述了如何使用一个自定义特性类，规定了特性可应用到的项目的类型。</li><li><code>Conditional</code> 标记了一个条件方法，其执行依赖于指定的预处理标识符，比如 <code>Debug/Trace</code>。</li><li><code>Obsolete</code> 标记了不应被使用的程序实体，给出特定的目标元素“已过时”的提示信息。</li></ul><h4 id="3-1-2-自定义特性"><a href="#3-1-2-自定义特性" class="headerlink" title="3.1.2 自定义特性"></a>3.1.2 自定义特性</h4><ul><li>声明：<code>public class DebugInfo: System.Attribute</code>，并且在前面加上AttributeUsage标记。</li><li>构建：在类中定义positional参数、named参数，并且每个参数至少有一个构造函数。</li><li>应用：在目标前面加上DebugInfo特性。</li></ul><h3 id="3-2-反射"><a href="#3-2-反射" class="headerlink" title="3.2 反射"></a>3.2 反射</h3><p><code>Reflection(System.Reflection)</code> 提供了封装程序集、模块和类型的对象。</p><ul><li>允许在运行时查看attribute信息；</li><li>允许延迟绑定的方法和属性；</li><li>允许审查集合中的各种类型，以及实例化这些类型；</li><li>允许在运行时创建新类型，然后用这些类型执行任务。</li></ul><h3 id="3-3-属性"><a href="#3-3-属性" class="headerlink" title="3.3 属性"></a>3.3 属性</h3><p><code>Property</code> 使用访问器 <code>accessors</code> 让私有域的值可以被读写或操作（公有构造函数），类似于Python的 <code>@property</code> 装饰器。</p><ul><li>访问器：包含get/set访问器。</li><li>抽象属性：抽象类可拥有抽象属性，这些属性在派生类中被 <code>override</code> 实现。</li></ul><h3 id="3-4-索引器"><a href="#3-4-索引器" class="headerlink" title="3.4 索引器"></a>3.4 索引器</h3><p><code>Indexer</code> 允许一个对象可以像数组一样被索引，索引器除了整型也可以是字符串类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">element-type this[int index]</span><br><span class="line">&#123;</span><br><span class="line">    get</span><br><span class="line">    &#123;</span><br><span class="line">        // 返回index指定的值</span><br><span class="line">    &#125;</span><br><span class="line">    set</span><br><span class="line">    &#123;</span><br><span class="line">        // 设置index指定的值</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-委托"><a href="#3-5-委托" class="headerlink" title="3.5 委托"></a>3.5 委托</h3><ul><li><code>Delegate(System.Delegate)</code> 函数的指针，是存有对某个方法的引用的一种引用类型变量，可在运行时被改变。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public delegate int MyDelegate(string s);</span><br><span class="line">public static int Write2Screen(string s);</span><br><span class="line">public static int Write2File(string s);</span><br><span class="line"></span><br><span class="line">MyDelegate md1 = new MyDelegate(Write2Screen);</span><br><span class="line">MyDelegate md2;</span><br><span class="line">md2 = Write2File;</span><br></pre></td></tr></table></figure><ul><li><code>Anonymous methods</code> 匿名方法，不需要指定返回类型，它从方法主体内的return语句推断出来。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">delegate void NumberChanger(int n);</span><br><span class="line"></span><br><span class="line">NumberChanger nc = delegate(int x)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(&quot;Anonymous Method: &#123;0&#125;&quot;, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-集合"><a href="#3-6-集合" class="headerlink" title="3.6 集合"></a>3.6 集合</h3><p><code>Collection(System.Collection)</code> 实现了常用的数据结构：</p><ul><li><code>ArrayList</code> 与数组不同的是，它可以在索引的位置添加、移除项目，自动重新调整它的大小。</li><li><code>Hashtable</code> 使用键来访问集合中的元素。</li><li><code>SortedList</code> 是数组和哈希表的结合，它使用键和索引来访问列表中的项；集合中的各项总是按键值排序。</li><li><code>Queue/Stack</code> 先进先出/后进先出。</li><li><code>BitArray</code> 使用0和1来表示的二进制数组，它可以由整型索引来访问元素。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;既然加入了微软，我自然要熟悉C#编程；幸运的是，我以前在实验室就做过WPF项目，而且作为Python重度用户，同样是面向对象的语言，学起来一点都不难。&lt;br&gt;本文主要对C#的独特之处进行了总结。&lt;/p&gt;
&lt;h2 id=&quot;1-C-数据类型&quot;&gt;&lt;a href=&quot;#1-C-数据类
      
    
    </summary>
    
    
      <category term="C#" scheme="https://brightsunp.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Face_recognition在win10上的安装和程序打包</title>
    <link href="https://brightsunp.github.io/2019/03/06/face-recognition%E5%9C%A8win10%E4%B8%8A%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85/"/>
    <id>https://brightsunp.github.io/2019/03/06/face-recognition在win10上的安装和程序打包/</id>
    <published>2019-03-06T00:42:11.000Z</published>
    <updated>2020-08-03T03:47:49.981Z</updated>
    
    <content type="html"><![CDATA[<p>最近开发了一个人脸识别的离线应用，除了业务逻辑的实现，时间主要耗费在 <code>face_recognition</code> 在win10上的安装和打包中。<br>本文属于典型的“github搬运工”。</p><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1 安装"></a>1 安装</h2><p>搬运自 <a href="https://github.com/ageitgey/face_recognition/issues/175" target="_blank" rel="noopener">这里</a>，当然也记录下自己遇到的一些坑，我用的是 <code>Python 3.7.2</code>。</p><h3 id="1-1-环境准备"><a href="#1-1-环境准备" class="headerlink" title="1.1 环境准备"></a>1.1 环境准备</h3><ul><li><code>CMake</code>。从 <a href="https://cmake.org/download/" target="_blank" rel="noopener">这里</a> 下载.msi文件，安装时勾选“Add CMake to system path”，安装完成用 <code>cmake --version</code> 进行验证。</li><li><code>Boost</code>。从 <a href="https://sourceforge.net/projects/boost/files/" target="_blank" rel="noopener">这里</a> 下载源码或二进制版本，如果是源码就需要自己编译。解压到本地路径，我的是“E:\local\boost_1_66_0”，然后添加环境变量：<code>BOOST_ROOT=E:\local\boost_1_66_0; BOOST_LIBRARYDIR=E:\local\boost_1_66_0\libs</code>。</li><li><code>Visual Studio 2015(fully updated)</code>。它和Cmake都是为了后面编译 <code>dlib</code> 做准备，安装过程见 <a href="https://blog.csdn.net/guxiaonuan/article/details/73775519" target="_blank" rel="noopener">这里</a>，安装组件勾选“Visual Studio 2015 更新 3”和“Visual C++”即可。</li></ul><h3 id="1-2-pip安装"><a href="#1-2-pip安装" class="headerlink" title="1.2 pip安装"></a>1.2 pip安装</h3><ul><li><code>virtualenv --no-site-packages venv</code>。创建虚拟环境，毕竟是一个独立的项目。</li><li><code>call venv\Scripts\activate.bat</code>。进入虚拟环境。</li><li><code>pip install scipy face_recognition</code>。这一步会自动安装 <code>dlib/numpy/Pillow</code> 等模块。</li></ul><h2 id="2-程序打包"><a href="#2-程序打包" class="headerlink" title="2 程序打包"></a>2 程序打包</h2><p>搬运自 <a href="https://github.com/ageitgey/face_recognition/issues/357" target="_blank" rel="noopener">这里</a>。</p><p>开发完成后，我希望得到一个.exe文件，不依赖环境就能运行。而face_recognition会用到自己的模型数据，所以需要一同打包进去。注意，打包需要切换到工程目录，并且在虚拟环境中进行。</p><ul><li>拷贝模型数据到工程目录。将 <code>venv\Lib\site-packages\face_recognition_models</code> 拷贝为 <code>face_recognition_models</code>，将 <code>venv\Lib\site-packages\scipy\extra-dll</code> 拷贝为 <code>scipy-extra-dll</code>。</li><li><code>pip install pyinstaller</code>。</li><li>新建 <code>setup.spec</code>。这是pyinstaller的配置文件，需要将 <code>&lt;&gt;</code> 包裹的参数替换为自己的。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"># -*- mode: python -*-</span><br><span class="line"></span><br><span class="line">block_cipher = None</span><br><span class="line"></span><br><span class="line">face_models = [</span><br><span class="line">(&apos;.\\face_recognition_models\\models\\dlib_face_recognition_resnet_model_v1.dat&apos;, &apos;./face_recognition_models/models&apos;),</span><br><span class="line">(&apos;.\\face_recognition_models\\models\\mmod_human_face_detector.dat&apos;, &apos;./face_recognition_models/models&apos;),</span><br><span class="line">(&apos;.\\face_recognition_models\\models\\shape_predictor_5_face_landmarks.dat&apos;, &apos;./face_recognition_models/models&apos;),</span><br><span class="line">(&apos;.\\face_recognition_models\\models\\shape_predictor_68_face_landmarks.dat&apos;, &apos;./face_recognition_models/models&apos;),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">a = Analysis([&apos;&lt;your python script name.py&gt;&apos;],</span><br><span class="line">             pathex=[&apos;&lt;path to working directory&gt;&apos;],</span><br><span class="line">             binaries=face_models,</span><br><span class="line">             datas=[],</span><br><span class="line">             hiddenimports=[&apos;scipy._lib.messagestream&apos;, &apos;scipy&apos;, &apos;scipy.signal&apos;, &apos;scipy.signal.bsplines&apos;, &apos;scipy.special&apos;, &apos;scipy.special._ufuncs_cxx&apos;,</span><br><span class="line">                            &apos;scipy.linalg.cython_blas&apos;,</span><br><span class="line">                            &apos;scipy.linalg.cython_lapack&apos;,</span><br><span class="line">                            &apos;scipy.integrate&apos;,</span><br><span class="line">                            &apos;scipy.integrate.quadrature&apos;,</span><br><span class="line">                            &apos;scipy.integrate.odepack&apos;,</span><br><span class="line">                            &apos;scipy.integrate._odepack&apos;,</span><br><span class="line">                            &apos;scipy.integrate.quadpack&apos;,</span><br><span class="line">                            &apos;scipy.integrate._quadpack&apos;,</span><br><span class="line">                            &apos;scipy.integrate._ode&apos;,</span><br><span class="line">                            &apos;scipy.integrate.vode&apos;,</span><br><span class="line">                            &apos;scipy.integrate._dop&apos;, &apos;scipy._lib&apos;, &apos;scipy._build_utils&apos;,&apos;scipy.__config__&apos;,</span><br><span class="line">                            &apos;scipy.integrate.lsoda&apos;, &apos;scipy.cluster&apos;, &apos;scipy.constants&apos;,&apos;scipy.fftpack&apos;,&apos;scipy.interpolate&apos;,&apos;scipy.io&apos;,&apos;scipy.linalg&apos;,&apos;scipy.misc&apos;,&apos;scipy.ndimage&apos;,&apos;scipy.odr&apos;,&apos;scipy.optimize&apos;,&apos;scipy.setup&apos;,&apos;scipy.sparse&apos;,&apos;scipy.spatial&apos;,&apos;scipy.special&apos;,&apos;scipy.stats&apos;,&apos;scipy.version&apos;],</span><br><span class="line"></span><br><span class="line">             hookspath=[],</span><br><span class="line">             runtime_hooks=[],</span><br><span class="line">             excludes=[],</span><br><span class="line">             win_no_prefer_redirects=False,</span><br><span class="line">             win_private_assemblies=False,</span><br><span class="line">             cipher=block_cipher)</span><br><span class="line"></span><br><span class="line">a.datas += Tree(&apos;./scipy-extra-dll&apos;, prefix=None)</span><br><span class="line"></span><br><span class="line">pyz = PYZ(a.pure, a.zipped_data,</span><br><span class="line">             cipher=block_cipher)</span><br><span class="line">exe = EXE(pyz,</span><br><span class="line">          a.scripts,</span><br><span class="line">          a.binaries,</span><br><span class="line">          a.zipfiles,</span><br><span class="line">          a.datas,</span><br><span class="line">          name=&apos;&lt;your python script name&gt;&apos;,</span><br><span class="line">          debug=False,</span><br><span class="line">          strip=False,</span><br><span class="line">          upx=True,</span><br><span class="line">          runtime_tmpdir=None,</span><br><span class="line">          console=True )</span><br></pre></td></tr></table></figure><ul><li><code>pyinstaller setup.spec</code>。打包成功后，就能在 <code>dist</code> 目录找到.exe文件了。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近开发了一个人脸识别的离线应用，除了业务逻辑的实现，时间主要耗费在 &lt;code&gt;face_recognition&lt;/code&gt; 在win10上的安装和打包中。&lt;br&gt;本文属于典型的“github搬运工”。&lt;/p&gt;
&lt;h2 id=&quot;1-安装&quot;&gt;&lt;a href=&quot;#1-安装&quot;
      
    
    </summary>
    
    
      <category term="CV" scheme="https://brightsunp.github.io/tags/CV/"/>
    
  </entry>
  
  <entry>
    <title>Daily-Coding-Problem-81-90</title>
    <link href="https://brightsunp.github.io/2019/02/22/Daily-Coding-Problem-81-90/"/>
    <id>https://brightsunp.github.io/2019/02/22/Daily-Coding-Problem-81-90/</id>
    <published>2019-02-22T02:18:52.000Z</published>
    <updated>2020-08-03T03:47:49.974Z</updated>
    
    <content type="html"><![CDATA[<p>本文的完整代码见 <a href="https://github.com/brightsunp/learn/blob/master/leetcode/DCP_81-90.py" target="_blank" rel="noopener">这里</a>。</p><h2 id="1-Microsoft-分块读取数据流"><a href="#1-Microsoft-分块读取数据流" class="headerlink" title="1 Microsoft-分块读取数据流"></a>1 Microsoft-分块读取数据流</h2><blockquote><p>Using a read7() method that returns 7 characters from a file, implement readN(n) which reads n characters.<br>For example, given a file with the content “Hello world”, three read7() returns “Hello w”, “orld” and then “”.</p></blockquote><ul><li>首先，这里的 <code>readN(n)</code> 不仅仅是读取前n个字符，还需要保存当前的<strong>文件指针</strong>，指向下一次读取的开始位置。</li><li>其次，借助 <code>read7()</code> 来实现，读取的累计长度可能大于n，需要将多余的部分缓存下来。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, content)</span>:</span></span><br><span class="line">        self.content = content</span><br><span class="line">        <span class="comment"># save file pointer</span></span><br><span class="line">        self.offset = <span class="number">0</span></span><br><span class="line">        <span class="comment"># cache remaining</span></span><br><span class="line">        self.buffer = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">readN</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> len(self.buffer) &lt; n:</span><br><span class="line">            piece = self._read7()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> piece:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            self.buffer += piece</span><br><span class="line">        n_chars = self.buffer[:n]</span><br><span class="line">        self.buffer = self.buffer[n:]</span><br><span class="line">        <span class="keyword">return</span> n_chars</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_read7</span><span class="params">(self)</span>:</span></span><br><span class="line">        start = self.offset</span><br><span class="line">        end = min(self.offset+<span class="number">7</span>, len(self.content))</span><br><span class="line">        self.offset = end</span><br><span class="line">        <span class="keyword">return</span> self.content[start:end]</span><br><span class="line"></span><br><span class="line">sol1 = Solution(<span class="string">'Hello world'</span>)</span><br><span class="line"><span class="keyword">assert</span> sol1.readN(<span class="number">8</span>) == <span class="string">'Hello wo'</span></span><br><span class="line"><span class="keyword">assert</span> sol1.readN(<span class="number">8</span>) == <span class="string">'rld'</span></span><br><span class="line"><span class="keyword">assert</span> sol1.readN(<span class="number">8</span>) == <span class="string">''</span></span><br><span class="line"></span><br><span class="line">sol2 = Solution(<span class="string">'Hello world'</span>)</span><br><span class="line"><span class="keyword">assert</span> sol2.readN(<span class="number">4</span>) == <span class="string">'Hell'</span></span><br><span class="line"><span class="keyword">assert</span> sol2.readN(<span class="number">4</span>) == <span class="string">'l wo'</span></span><br><span class="line"><span class="keyword">assert</span> sol2.readN(<span class="number">4</span>) == <span class="string">'rld'</span></span><br></pre></td></tr></table></figure><h2 id="2-Uber-验证地理位置"><a href="#2-Uber-验证地理位置" class="headerlink" title="2 Uber-验证地理位置"></a>2 Uber-验证地理位置</h2><blockquote><p>A rule looks like this:<br>A NE B<br>This means this means point A is located northeast of point B.<br>A SW C<br>means that point A is southwest of C.<br>Given a list of rules, check if the sum of the rules validate. For example:<br>A N B<br>B NE C<br>C N A<br>does not validate, since A cannot be both north and south of C.<br>A NW B<br>A N B<br>is considered valid.</p></blockquote><p>解题的过程中，我遇到了几个坑：</p><ul><li>使用更加Pythonic的 <code>dict.fromkeys([&#39;N&#39;, &#39;S&#39;, &#39;W&#39;, &#39;E&#39;], set())</code>，但这种初始化结果不符合预期。<br>因为 <code>set()</code> 是可变对象，而所有键的值指向了同一个 <code>set()</code>，所以修改一个键的值，其他键的值也会同步修改。</li><li>每添加一条边，需要对前节点、后节点在相反方向上的 <code>set()</code> 同步更新。</li><li>每添加一条边，需要判断前节点的所有<strong>传递依赖</strong>，同时每个子节点与后节点形成一条新边，需要递归地添加边。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NeighbourNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        <span class="comment"># dict.fromkeys(): pointer to SAME object</span></span><br><span class="line">        self.neighbours = &#123;<span class="string">'N'</span>: set(), <span class="string">'S'</span>: set(), <span class="string">'W'</span>: set(), <span class="string">'E'</span>: set()&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__hash__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> hash(self.val)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.opposites = &#123;<span class="string">'N'</span>: <span class="string">'S'</span>, <span class="string">'S'</span>: <span class="string">'N'</span>, <span class="string">'W'</span>: <span class="string">'E'</span>, <span class="string">'E'</span>: <span class="string">'W'</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_valid</span><span class="params">(self, rules)</span>:</span></span><br><span class="line">        nodes = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> rule <span class="keyword">in</span> rules:</span><br><span class="line">            val1, directions, val2 = tuple(rule.split())</span><br><span class="line">            node1 = nodes.setdefault(val1, NeighbourNode(val1))</span><br><span class="line">            node2 = nodes.setdefault(val2, NeighbourNode(val2))</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self._add_rule(node1, directions, node2):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_add_rule</span><span class="params">(self, node1, directions, node2)</span>:</span></span><br><span class="line">        <span class="comment"># recursive</span></span><br><span class="line">        <span class="keyword">for</span> direction <span class="keyword">in</span> directions:</span><br><span class="line">            <span class="keyword">if</span> node1 <span class="keyword">in</span> node2.neighbours[self.opposites[direction]] <span class="keyword">or</span> node2 <span class="keyword">in</span> node1.neighbours[direction]:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="comment"># check node1's transfer dependency</span></span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> node1.neighbours[direction]:</span><br><span class="line">                self._add_rule(node, direction, node2)</span><br><span class="line">        <span class="keyword">for</span> direction <span class="keyword">in</span> directions:</span><br><span class="line">            node2.neighbours[direction].add(node1)</span><br><span class="line">            node1.neighbours[self.opposites[direction]].add(node2)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">sol = Solution()</span><br><span class="line"><span class="keyword">assert</span> sol.is_valid([<span class="string">'A NW B'</span>, <span class="string">'A N B'</span>])</span><br><span class="line"><span class="keyword">assert</span> <span class="keyword">not</span> sol.is_valid([<span class="string">'A N B'</span>, <span class="string">'B NE C'</span>, <span class="string">'C N A'</span>])</span><br></pre></td></tr></table></figure><h2 id="3-ContextLogic-位运算实现除法"><a href="#3-ContextLogic-位运算实现除法" class="headerlink" title="3 ContextLogic-位运算实现除法"></a>3 ContextLogic-位运算实现除法</h2><blockquote><p>Implement division of two positive integers without using the division, multiplication, or modulus operators. Return the quotient as an integer, ignoring the remainder.</p></blockquote><p>正整数相除的原始思路，就是用除数不断地减去被除数，直到除数比被除数小。两个数相差很大时，相减的次数就会很多，这本身就需要优化。</p><p>为了降低除数“相减”的次数，自然是希望每次“相减”的幅度更大。以数字15和3为例，我们考虑 <code>3*2=6, 6*2=12</code>，记录下12和3的倍数，用15一次性减去12，再进行迭代的操作即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(self, dividend, divisor)</span>:</span></span><br><span class="line">        <span class="comment"># bit manipulation</span></span><br><span class="line">        <span class="keyword">if</span> divisor == <span class="number">0</span> <span class="keyword">or</span> (dividend == <span class="number">-2</span> ** <span class="number">31</span> <span class="keyword">and</span> divisor == <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        dvd, dvs = abs(dividend), abs(divisor)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> dvd &gt;= dvs:</span><br><span class="line">            tmp, mul = dvs, <span class="number">1</span></span><br><span class="line">            <span class="comment"># divisor doubled to get close to dividend</span></span><br><span class="line">            <span class="keyword">while</span> dvd &gt;= (tmp &lt;&lt; <span class="number">1</span>):</span><br><span class="line">                tmp &lt;&lt;= <span class="number">1</span></span><br><span class="line">                mul &lt;&lt;= <span class="number">1</span></span><br><span class="line">            dvd -= tmp</span><br><span class="line">            res += mul</span><br><span class="line"></span><br><span class="line">        sign = (dividend &lt; <span class="number">0</span>) ^ (divisor &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -res <span class="keyword">if</span> sign <span class="keyword">else</span> res</span><br><span class="line"></span><br><span class="line">sol = Solution()</span><br><span class="line"><span class="keyword">assert</span> sol.divide(<span class="number">10</span>, <span class="number">0</span>) == <span class="number">2</span>**<span class="number">31</span> - <span class="number">1</span></span><br><span class="line"><span class="keyword">assert</span> sol.divide(<span class="number">-2</span>**<span class="number">31</span>, <span class="number">-1</span>) == <span class="number">2</span>**<span class="number">31</span> - <span class="number">1</span></span><br><span class="line"><span class="keyword">assert</span> sol.divide(<span class="number">15</span>, <span class="number">3</span>) == <span class="number">5</span></span><br><span class="line"><span class="keyword">assert</span> sol.divide(<span class="number">16</span>, <span class="number">3</span>) == <span class="number">5</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文的完整代码见 &lt;a href=&quot;https://github.com/brightsunp/learn/blob/master/leetcode/DCP_81-90.py&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;h2 i
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://brightsunp.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Web学习笔记——协议</title>
    <link href="https://brightsunp.github.io/2019/02/14/web%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%8D%8F%E8%AE%AE/"/>
    <id>https://brightsunp.github.io/2019/02/14/web学习笔记——协议/</id>
    <published>2019-02-14T01:44:24.000Z</published>
    <updated>2020-08-03T03:47:49.968Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>《UNIX网络编程卷1：套接字联网API》学习笔记。</p></blockquote><p>网络通信由客户端发起，由服务器响应。web服务器是长时间运行的程序，即守护程序 <code>daemon</code>，它只在响应来自网络的请求时发送消息；web客户程序，如某种浏览器，总是网络请求的发起方。不过在更复杂的网络应用中，如果用到了异步回调 <code>asynchronous callback</code> 通信，则是由服务器向客户端发起请求。<br>web客户与服务器之间使用TCP <code>Transmission Control Protocol</code> 通信，TCP转而使用IP <code>Internet Protocol</code> 通信，IP再通过某种形式的数据链路层通信。有些客户和服务器则改用UDP <code>User Datagram Protocol</code> 通信。</p><h2 id="1-OSI模型"><a href="#1-OSI模型" class="headerlink" title="1 OSI模型"></a>1 OSI模型</h2><p>开放系统互联 <code>open system interconnection</code> 模型，从上往下依次为：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。</p><ul><li>应用层 <code>Application</code>：与应用程序界面沟通，达到展示给用户的目的，如HTTP/FTP/TELNET/SSH/SMTP等。</li><li>表示层 <code>Presentation</code>：对网络传输的数据进行转换，使多个主机之间传送的信息能相互理解，包括数据压缩、加密、格式转换等。</li><li>会话层 <code>Session</code>：管理主机之间的会话过程，包括会话建立、终止和会话过程中的管理。</li><li>传输层 <code>Transport</code>：提供可靠的数据传输服务，检测路由器丢弃的包，然后重新传输，能够将乱序收到的数据包重新排序。数据的传输单位是段 <code>segment</code>。</li><li>网络层 <code>Network</code>：将各个子网之间的数据进行路由选择、分组和重组，如IP/IPX/RIP/ICMP等。路由器属于该层，数据的传输单位是数据包 <code>packet</code>。</li><li>数据链路层 <code>Data Link</code>：对物理层收到的比特流进行数据成帧，提供可靠的数据传输服务，实现无差错数据传输。交换机属于该层，数据的传输单位是帧 <code>frame</code>。</li><li>物理层 <code>Physical</code>：定义了所有电子及物理设备的规范，为上层的传输提供物理介质。网卡属于该层，数据的传输单位是比特 <code>bit</code>。</li></ul><h3 id="1-1-网络拓扑"><a href="#1-1-网络拓扑" class="headerlink" title="1.1 网络拓扑"></a>1.1 网络拓扑</h3><ul><li><code>netstat -i</code> 提供网络接口的信息。还可以指定 <code>-n</code> 以输出数值地址。</li><li><code>netstat -r</code> 展示路由表，还给出默认路由器的IP地址。</li><li><code>ifconfig [ni]</code> 查看指定接口的IP地址、子网掩码、广播地址。</li><li><code>ping -b [bcast]</code> 通过本地接口的广播地址，找出本地网络中众多主机的IP地址。</li><li><code>arp -a</code> 查看主机所维护的ARP缓存表。</li></ul><h3 id="1-2-ping的过程"><a href="#1-2-ping的过程" class="headerlink" title="1.2 ping的过程"></a>1.2 ping的过程</h3><ol><li>ping判断参数是主机名还是IP地址。如果是主机名，则调用 <code>gethostbyname()</code>，解析主机B的32位IP地址，该过程即DNS域名解析。</li><li>ping发送ICMP ECHO包到目标IP地址。</li><li>ping在局域网内发送ARP请求广播，查找主机B的48位硬件地址。</li><li>主机B的ARP协议层接收到主机A的ARP请求，发送本机硬件地址的应答包到主机A。</li><li>主机A发送ICMP数据包到主机B。</li><li>主机B接收到主机A的ICMP包，发送响应包。</li><li>主机A接收到主机B的ICMP包响应包。</li></ol><h2 id="2-TCP-IP协议族"><a href="#2-TCP-IP协议族" class="headerlink" title="2 TCP/IP协议族"></a>2 TCP/IP协议族</h2><h3 id="2-1-总图"><a href="#2-1-总图" class="headerlink" title="2.1 总图"></a>2.1 总图</h3><p><img src="/img/TCP-IP.png" alt=""></p><p>图中的每个协议框都做个笔记：</p><ul><li>IPv4 <code>Internet Protocol version 4</code>：1980s作为网际协议族的主力，使用32位地址，给TCP/UDP/SCTP/ICMP/IGMP提供分组递送服务。</li><li>IPv6 <code>Internet Protocol version 6</code>：1990s作为IPv4的替代品设计，使用128位地址以应对因特网的爆发性增长，给TCP/UDP/SCTP/ICMPv6提供分组递送服务。无需区分时直接用IP一词。</li><li>TCP：面向连接的协议，为用户进程提供可靠的全双工字节流，关心确认、超时、重传等细节。</li><li>UDP：无连接的协议，UDP数据包不能保证最终到达目的地。</li><li>SCTP <code>Stream Control Transmission Protocol</code>：提供可靠全双工关联的面向连接的协议，每个“关联”的两端均涉及一组IP地址和一个端口号；提供消息服务，即维护来自应用层的记录边界。</li><li>ICMP <code>Internet Control Message Protocol</code>：处理在路由器和主机之间流通的错误和控制消息，<code>ping</code> 和 <code>traceroute</code> 程序使用了ICMP。</li><li>IGMP <code>Internet Group Management Protocol</code>：用于多播，在IPv4中是可选的。</li><li>ARP <code>Address Resolution Protocol</code>：“地址解析协议”，把IPv4地址映射成硬件地址，如以太网地址，ARP在点到点网络上并不需要。</li><li>RARP <code>Reverse ARP</code>：把硬件地址映射成IPv4地址，可用于无盘节点的引导。</li><li>ICMPv6：综合了ICMP、IGMP、ARP的功能。</li><li>BPF <code>BSD packet filter</code>：提供对数据链路层的访问能力，通常可以在Berkeley内核中找到。</li><li>DLPI <code>Data Link Provider Interface</code>：提供对数据链路层的访问能力，通常随SVR4内核提供。</li></ul><p>所有的网际协议由一个或多个<strong>请求评注</strong> <code>Request for Comments, RFC</code> 文档来定义，这些RFC就是它们的正式规范。</p><h3 id="2-2-UDP"><a href="#2-2-UDP" class="headerlink" title="2.2 UDP"></a>2.2 UDP</h3><p>简单的传输层协议。应用进程往一个UDP套接字写入一个消息，该消息被封装 <code>encapsulating</code> 到一个UDP数据报，该数据报又被封装到一个IP数据报，然后发送到目的地。<br>如果想确认数据报到达了目的地，可以往应用程序中添置特性：来自对端的确认、本端的超时与重传等。<br>每个UDP数据报都有一个长度，一旦正确到达目的地，该长度也随数据一道传递给接收端应用进程。这点与TCP数据报没有任何记录边界，有所不同。</p><h3 id="2-3-TCP"><a href="#2-3-TCP" class="headerlink" title="2.3 TCP"></a>2.3 TCP</h3><ul><li>提供客户与服务器之间的<strong>连接</strong> <code>connection</code>。跨该连接传输数据，再终止连接。</li><li>提供<strong>可靠性</strong> <code>reliability</code>。TCP发送数据给对端，要求对端返回一个确认，如果超时还没收到确认，会自动重传数据并等待更长的时间；数次重传失败后，TCP才放弃，如此尝试在发送数据上的总时间一般为 <code>4~10 min</code>。另外，TCP含有动态估算客户与服务器之间的往返时间 <code>round-trip time, RTT</code> 的算法，它会持续估算一个给定连接的RTT。</li><li>提供<strong>排序</strong> <code>sequencing</code>。TCP给每个字节关联一个序列号，如果数据分节非顺序到达，或接收到重复的数据，那么接收端TCP丢弃重复数据、根据序列号重新排序，再把结果提供给接收应用。</li><li>提供<strong>流量控制</strong> <code>flow control</code>。TCP总是告知对端在任何时刻它一次能够从对端接收多少字节的数据，即通告窗口 <code>advertised window</code>，也叫滑动窗口 <code>sliding window</code>。当接收到数据时，窗口减小；当接收端应用从缓冲区读取数据时，窗口增大；当TCP对应某个套接字的接收缓冲区已满，导致它必须等待应用从该缓冲区读取数据时，窗口减小到0。</li><li>TCP连接是<strong>全双工</strong>的 <code>full-duplex</code>。在一个给定的连接上，应用可以在任何时刻在进出两个方向上既发送数据又接收数据。</li></ul><h3 id="2-4-SCTP"><a href="#2-4-SCTP" class="headerlink" title="2.4 SCTP"></a>2.4 SCTP</h3><p>与TCP的区别有两点：</p><ul><li>提供客户与服务器之间的<strong>关联</strong> <code>association</code>。一个连接只涉及两个IP地址之间的通信，而一个关联指代两个系统之间的通信。</li><li>SCTP在所连接的端点之间提供多个流，每个流各自可靠地按序递送消息，并且一个流上某个消息的丢失不阻塞同一关联其他流上消息的投递；反观TCP，在单一字节流中任何位置的字节丢失都将阻塞该连接上其后所有数据的递送，直到该丢失被修复为止。</li></ul><h3 id="2-5-建立和终止TCP连接"><a href="#2-5-建立和终止TCP连接" class="headerlink" title="2.5 建立和终止TCP连接"></a>2.5 建立和终止TCP连接</h3><p><strong>三路握手</strong> <code>three-way handshake</code></p><ul><li>服务器准备好接收外来的连接。被动打开 <code>passive open</code>，调用 <code>socket/bind/listen</code> 这3个函数来完成。</li><li>客户发起连接。主动打开 <code>active open</code>，调用 <code>connect</code>，客户TCP发送一个同步位 <code>synchronize, SYN</code>，它是将要发送数据的初始序列号，但通常不携带数据。不妨设 <code>SYN=J</code>。</li><li>服务器确认 <code>acknowledge, ACK</code> 客户的SYN。调用 <code>accept</code>，同时自己也发送一个SYN，它是服务器将要发送数据的初始序列号。此时 <code>ACK=J+1, SYN=K</code>。</li><li>客户确认服务器的SYN。此时 <code>ACK=K+1</code>。（服务器接收后，开始调用 <code>read</code>）</li></ul><p><strong>四次挥手</strong></p><ul><li>某个应用进程发起关闭 <code>finish, FIN</code>。主动关闭 <code>active close</code>，调用 <code>close</code>。不妨设 <code>FIN=M</code>。</li><li>接收端确认FIN。被动关闭 <code>passive close</code>，FIN作为一个文件结束符 <code>end-of-file</code> 传递给接收端应用进程，这意味着接收端应用进程在相应连接上再无额外数据可接收。此时 <code>ACK=M+1</code>。</li><li>一段时间后，接收端调用 <code>close</code> 关闭它的套接字，也发送一个FIN。此时 <code>FIN=N</code>。</li><li>执行主动关闭的原发送端确认这个FIN。此时 <code>ACK=N+1</code>。</li></ul><h3 id="2-6-建立和终止SCTP关联"><a href="#2-6-建立和终止SCTP关联" class="headerlink" title="2.6 建立和终止SCTP关联"></a>2.6 建立和终止SCTP关联</h3><p><strong>四路握手</strong><br>与TCP很类似，主要区别在于作为SCTP整体一部分的cookie的生成。</p><ul><li>服务器准备好接收外来的关联。</li><li>客户发送一个INIT消息，告诉服务器：客户的IP地址清单、初始序列号、标识本关联所有分组的起始标记、客户请求的外出流数目和能够支持的外来流数目。</li><li>服务器以一个INIT ACK消息来确认，告诉客户：服务器对应的上述信息，以及一个状态cookie（数字化签名，包含了服务器用于确信本关联有效的所有状态）。</li><li>客户以一个COOKIE ECHO消息来回复，该消息可能在同一个分组中还捆绑了用户数据。</li><li>服务器以一个COOKIE ACK消息来确认客户的cookie是正确的，该消息也可能在同一个分组中还捆绑了用户数据。</li></ul><p><strong>终止关联</strong><br>只需要三次，不像TCP那样允许“半关闭”的关联。当一端关闭时，另一端必须停止发送新的数据；接收端发送完已经排队的数据（如果有）后，即终止关联。<br>SCTP没有类似于TCP的 <code>TIME_WAIT</code> 状态，原因是SCTP使用了验证标记。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;《UNIX网络编程卷1：套接字联网API》学习笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;网络通信由客户端发起，由服务器响应。web服务器是长时间运行的程序，即守护程序 &lt;code&gt;daemon&lt;/code&gt;，它只在响应来自网络的请求时发送消
      
    
    </summary>
    
    
      <category term="Web" scheme="https://brightsunp.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>MySQL学习笔记——逻辑架构</title>
    <link href="https://brightsunp.github.io/2019/02/12/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/"/>
    <id>https://brightsunp.github.io/2019/02/12/MySQL学习笔记——逻辑架构/</id>
    <published>2019-02-12T13:32:10.000Z</published>
    <updated>2020-08-03T03:47:49.963Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>《高性能MySQL》学习笔记。</p></blockquote><p>MySQL最重要的特性是它的存储引擎架构，这种架构的设计将Query Processing、Server Task和数据的存储/提取相分离，因此可以在使用时根据性能、特性，以及其他需求来选择数据存储的方式。Oracle一开始收购了InnoDB，后来收购了MySQL，两者得以更快地协同发展，MySQL始终基于GPL协议开放全部源代码。</p><h2 id="1-分层架构"><a href="#1-分层架构" class="headerlink" title="1 分层架构"></a>1 分层架构</h2><ul><li>第一层是大多数基于网络的客户端/服务器的工具或服务都有的架构，比如连接处理、授权认证、安全等。</li><li>第二层是服务器层和查询执行引擎，包括查询解析、分析、优化、缓存、内置函数，以及跨存储引擎的功能：存储过程、触发器、视图等。</li><li>第三层是存储引擎，负责数据的存储/提取，类似于GNU/Linux下的各种文件系统。<br>服务器和存储引擎在处理查询时通过API来回交互，这个过程屏蔽了<strong>不同存储引擎之间的差异</strong>。存储引擎既不会解析SQL，也不会与其他存储引擎通信，只是简单地响应服务器的请求。</li></ul><h3 id="1-1-连接管理"><a href="#1-1-连接管理" class="headerlink" title="1.1 连接管理"></a>1.1 连接管理</h3><p>每个客户端连接都会在服务器进程中拥有一个线程，服务器会负责缓存线程，所以不需要为每个新连接都创建或销毁线程。<br>MySQL 5.5以上的版本提供了一个API，支持Thread Pooling插件，可以用线程池中的少量线程来服务大量的连接。</p><h3 id="1-2-优化与执行"><a href="#1-2-优化与执行" class="headerlink" title="1.2 优化与执行"></a>1.2 优化与执行</h3><ul><li><strong>优化器</strong>：重写查询、决定表的读取顺序、选择合适的索引等。</li><li><strong>索引与schema</strong>：存储引擎的某种索引，可能对一些特定的查询有优化。</li><li><strong>缓存</strong>：<code>Query Cache</code>，如果能从中找到SELECT对应的查询，就不必再执行查询解析、优化的整个过程，而是直接返回缓存中的结果集。</li></ul><h2 id="2-并发控制"><a href="#2-并发控制" class="headerlink" title="2 并发控制"></a>2 并发控制</h2><h3 id="2-1-读写锁"><a href="#2-1-读写锁" class="headerlink" title="2.1 读写锁"></a>2.1 读写锁</h3><ul><li>读锁 <code>read lock</code> /共享锁 <code>shared lock</code>：相互不阻塞。</li><li>写锁 <code>write lock</code> /排他锁 <code>exclusive lock</code>：出于安全策略，写锁会阻塞其他的写锁和读锁。</li></ul><h3 id="2-2-锁粒度"><a href="#2-2-锁粒度" class="headerlink" title="2.2 锁粒度"></a>2.2 锁粒度</h3><p>为了提高系统的并发性，只锁定需要修改的部分数据，而不是所有的资源。即锁定的数据量越少，系统的并发程度越高。<br>而锁的各种操作，比如获得锁、检查锁是否解除、释放锁等，都会增加系统的开销。<br>锁策略就是在<strong>锁的开销</strong>和<strong>数据的安全性</strong>之间寻求平衡。每种MySQL存储引擎都可以实现自己的锁策略和锁粒度，并且MySQL支持多个存储引擎的架构。</p><ul><li>表锁 <code>table lock</code>，服务器层，这是MySQL中最基本、开销最小的锁策略，它会锁定整张表。<br>比如，服务器为 <code>ALTER TABLE</code> 之类的语句使用表锁，而忽略存储引擎的锁机制。</li><li>行级锁 <code>row lock</code>，存储引擎层，可以最大程度地支持并发，同时也带来了最大的锁开销。</li></ul><h2 id="3-事务"><a href="#3-事务" class="headerlink" title="3 事务"></a>3 事务</h2><ul><li><code>Atomicity</code> 原子性：事务是一组原子性的SQL语句，一个最小工作单元，执行要么全部成功，要么全部失败。</li><li><code>Consistency</code> 一致性：执行事务的前后，数据库从一个一致性的状态转换到另一个一致性的状态。</li><li><code>Isolation</code> 隔离性：一个事务在最终提交之前，对其他事务是不可见的。</li><li><code>Durability</code> 持久性：一旦事务提交，其所做的修改就会永久保存到数据库。</li></ul><h3 id="3-1-隔离级别"><a href="#3-1-隔离级别" class="headerlink" title="3.1 隔离级别"></a>3.1 隔离级别</h3><p>较低级别的隔离通常可以执行更高的并发，系统开销也更低。</p><ul><li><code>READ UNCOMMITTED</code> 未提交读：其他事务可以读取未提交的数据，即脏读 <code>Dirty Read</code>。</li><li><code>READ COMMITTED</code> 提交读：满足“隔离性”；这是大多数据库的默认隔离级别，但MySQL不是。</li><li><code>REPEATABLE READ</code> 可重复度：解决了脏读的问题，保证在同一个事务中多次读取同样记录的结果是一致的；这是MySQL的默认隔离级别。</li><li><code>SERIALIZABLE</code> 可串行化：解决了幻读 <code>Phantom Read</code> 的问题，为读取的每一行数据都加锁，可能导致大量的超时和锁争用的问题。</li></ul><h3 id="3-2-死锁"><a href="#3-2-死锁" class="headerlink" title="3.2 死锁"></a>3.2 死锁</h3><p>指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而恶性循环的现象。<br><strong>死锁检测</strong>、<strong>死锁超时</strong>机制：InnoDB存储引擎检测到死锁的循环依赖，会立即返回一个错误；当查询时间达到锁等待超时的设定后就放弃锁请求，将持有最少行级排他锁的事务进行回滚。</p><h3 id="3-3-事务日志"><a href="#3-3-事务日志" class="headerlink" title="3.3 事务日志"></a>3.3 事务日志</h3><p>可以提高事务的效率：存储引擎在修改表数据时只需要修改其内存拷贝，再把该修改记录到磁盘上的事务日志中，而不是每次都将修改的数据本身持久化到磁盘。<br>预写式日志 <code>Write-Ahead Logging</code>，修改数据需要写两次磁盘。</p><h3 id="3-4-MySQL事务"><a href="#3-4-MySQL事务" class="headerlink" title="3.4 MySQL事务"></a>3.4 MySQL事务</h3><ul><li><strong>自动提交AUTOCOMMIT</strong>：每个查询都默认当作一个事务执行提交；在当前连接中，可以设置AUTOCOMMIT变量来启用或禁用自动提交模式。</li><li><strong>不应该混合使用存储引擎</strong>：事务不是由服务器层、而是由下层的存储引擎实现的；<br>如果在事务中混合使用事务型InnoDB和非事务型MyISAM表，一旦回滚，导致非事务型的表无法撤销变更，数据库将处于不一致的状态，这种情况很难修复。</li><li><strong>隐式和显式锁定</strong>。</li></ul><h2 id="4-多版本并发控制"><a href="#4-多版本并发控制" class="headerlink" title="4 多版本并发控制"></a>4 多版本并发控制</h2><p>MVCC，可看作行级锁的一个变种，通过保存数据在某个时间点的快照来实现。它在很多情况下避免了加锁操作，大都实现了非阻塞的读操作，写操作也只锁定必要的行。<br>InnoDB-MVCC，通过在每行记录后面保存两个隐藏的列来实现：一列是行的创建时间，一列是行的过期/删除时间。当然存储的两列并不是实际时间，而是系统版本号。</p><h3 id="4-1-悲观锁"><a href="#4-1-悲观锁" class="headerlink" title="4.1 悲观锁"></a>4.1 悲观锁</h3><p><code>pessimistic lock</code>，总是假设最坏情况，每次读数据都认为别人会修改。共享资源每次只给一个线程使用，其他线程阻塞，用完后再把资源转让给其他线程。比如行级锁、表锁、读锁、写锁等。</p><h3 id="4-2-乐观锁"><a href="#4-2-乐观锁" class="headerlink" title="4.2 乐观锁"></a>4.2 乐观锁</h3><p><code>optimistic lock</code>，总是假设最好情况，每次读数据都认为别人不会修改，但是写数据时会判断此期间别人有没有更新这个数据，可以使用版本号机制和CAS算法实现。适用于多读的应用类型，这样可以提高吞吐量，比如数据库的write_condition机制。</p><ul><li><strong>版本号机制</strong>：在数据表中加上version字段，表示数据被修改的次数，若事务开始时的version和提交修改时的version值相等才执行，否则重新提交，直到修改成功。</li><li><strong>CAS算法</strong>：<code>compare and swap</code>，在不使用锁的情况下实现多线程之间的变量同步，也叫非阻塞同步 <code>Non-blocking Synchronization</code>。<br>1）需要读写的内存值V，2）进行比较的值A，3）拟写入的新值B；当且仅当V的值等于A，采取原子的方式用B来更新V的值，否则进行自旋操作，即<strong>不断的重试</strong>。</li></ul><h2 id="5-存储引擎"><a href="#5-存储引擎" class="headerlink" title="5 存储引擎"></a>5 存储引擎</h2><p>可以使用 <code>SHOW TABLE STATUS</code> 查看表的Engine信息。</p><h3 id="5-1-InnoDB引擎"><a href="#5-1-InnoDB引擎" class="headerlink" title="5.1 InnoDB引擎"></a>5.1 InnoDB引擎</h3><p>MySQL的默认事务型引擎，处理大量的短期 <code>short-lived</code> 事务，短期事务大部分情况是正常提交的，很少被回滚。<br>拥有大量的贡献者：Oracle、Google、Yasufumi Kinoshita、Percona、Facebook等。<br>InnoDB是最值得深入学习的存储引擎，推荐阅读官方手册<a href="https://segmentfault.com/a/1190000014071758" target="_blank" rel="noopener">《InnoDB事务模型和锁》</a>。</p><h3 id="5-2-MyISAM引擎"><a href="#5-2-MyISAM引擎" class="headerlink" title="5.2 MyISAM引擎"></a>5.2 MyISAM引擎</h3><p>MySQL 5.1之前的默认引擎，提供了全文索引、压缩、空间函数等大量特性，但不支持事务和行级锁，而且最大的缺陷是崩溃后无法安全恢复。<br>MyISAM只将数据写到内存中，然后等待操作系统定期将数据刷出到磁盘上。</p><h3 id="5-3-MySQL内建的其他存储引擎"><a href="#5-3-MySQL内建的其他存储引擎" class="headerlink" title="5.3 MySQL内建的其他存储引擎"></a>5.3 MySQL内建的其他存储引擎</h3><ul><li>Archive：只支持INSERT和SELECT操作，缓存所有的写并利用zlib压缩插入的行，磁盘IO少，但需要执行全表扫描。适合于日志和数据采集类应用。它不是一个事务型引擎，而是一个针对高速插入和压缩做了优化的简单引擎。</li><li>Blackhole：没有任何存储机制，丢弃所有插入的数据，但服务器会记录Blackhole表的日志，可用于复制数据到备库，或者简单地记录到日志。</li><li>CSV：可以将普通的csv文件作为MySQL的表来处理，但不支持索引。可以作为一种数据交换的机制。</li><li>Federated：是访问其他数据库服务器（比如Microsoft SQL Server）的一个代理，创建远程连接后，将查询传输到远程服务器执行，然后提取或者发送需要的数据。</li><li>Memory：也叫作HEAP表，所有数据都存储在内存中，不需要磁盘IO，可用作快速访问，但重启后数据丢失，仅保留Memory表的结构。适合于查找或映射表，以及缓存数据分析的中间数据等。</li><li>NDB：将MySQL服务器、NDB集群存储引擎，以及分布式的、share-nothing的、容灾的、高可用的NDB数据库的组合，称为MySQL Cluster。</li></ul><h3 id="5-4-选择合适的引擎"><a href="#5-4-选择合适的引擎" class="headerlink" title="5.4 选择合适的引擎"></a>5.4 选择合适的引擎</h3><ul><li><strong>日志型应用</strong>：实时记录日志到MySQL中，这类应用的插入速度有很高要求，选择MyISAM或Archive。如果还需要分析记录的日志，一种方法是，利用MySQL内置的复制方案将数据复制到备库，在备库上执行SQL查询，这样主库只用于高效的插入，备库上的查询也不影响日志的插入性能；另一种方法是，在日志记录表的表名中包含年月的信息，这样可以在历史表上做频繁的SQL查询，不会干扰当前表的插入操作。</li><li><strong>只读或者大部分情况只读的表</strong>：选用MyISAM，但最好模拟崩溃恢复测试，不轻易相信“MyISAM比InnoDB快”的经验之谈。</li><li><strong>订单处理</strong>：必然要支持事务，选用InnoDB。</li><li><strong>CD-ROM应用</strong>：选用MyISAM，因为MyISAM压缩表比未压缩的表要节约很多空间，唯一缺点是只读特性。</li><li><strong>大数据量</strong>：3-5TB选用InnoDB，10TB以上需要建立数据仓库，比如Infobright、TokuDB。</li></ul><h3 id="5-5-转换表的引擎"><a href="#5-5-转换表的引擎" class="headerlink" title="5.5 转换表的引擎"></a>5.5 转换表的引擎</h3><ul><li><strong>修改表属性</strong>：<code>ALTER TABLE mytable ENGINE=InnoDB;</code> 需要执行很长时间，因为MySQL按行将原表的数据复制到新表，在复制期间消耗系统的IO能力，同时给原表加上读锁。</li><li><strong>导出与导入</strong>：使用mysqldump工具将数据导出到文件，再修改文件中 <code>CREATE TABLE</code> 语句的存储引擎选项，同时修改表名。还要注意mysqldump默认会在 <code>CREATE TABLE</code> 前加上 <code>DROP TABLE</code> 语句，可能会导致数据丢失。</li><li><strong>创建与查询</strong>：综合了上述方法1的高效和方法2的安全，不需要导出整个表的数据。依次执行 <code>CREATE TABLE innodb_table;</code>、<code>ALTER TABLE innodb_table ENGINE=InnoDB;</code>、<code>INSERT INTO innodb_table SELECT * FROM myisam_table;</code>。如果数据量很大，考虑做分批处理，针对每一段数据执行事务提交操作，以避免大事务产生过多的undo。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;《高性能MySQL》学习笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;MySQL最重要的特性是它的存储引擎架构，这种架构的设计将Query Processing、Server Task和数据的存储/提取相分离，因此可以在使用时根据性能、特性，以
      
    
    </summary>
    
    
      <category term="MySQL" scheme="https://brightsunp.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Daily-Coding-Problem-71-80</title>
    <link href="https://brightsunp.github.io/2019/02/12/Daily-Coding-Problem-71-80/"/>
    <id>https://brightsunp.github.io/2019/02/12/Daily-Coding-Problem-71-80/</id>
    <published>2019-02-12T00:58:52.000Z</published>
    <updated>2020-08-03T03:47:49.956Z</updated>
    
    <content type="html"><![CDATA[<p>本文的完整代码见 <a href="https://github.com/brightsunp/learn/blob/master/leetcode/DCP_71-80.py" target="_blank" rel="noopener">这里</a>。</p><h2 id="1-Google-单链表逆序"><a href="#1-Google-单链表逆序" class="headerlink" title="1 Google-单链表逆序"></a>1 Google-单链表逆序</h2><blockquote><p>Given the head of a singly linked list, reverse it in-place.</p></blockquote><p>Leetcode原题：<a href="https://leetcode.com/problems/reverse-linked-list/" target="_blank" rel="noopener">Reverse Linked List</a>。<br>我的第一思路是利用<strong>辅助栈</strong>，但这会用到额外的空间，所以这道题真正考察的是<strong>递归</strong>和<strong>迭代</strong>。其中，迭代的写法反倒最容易理解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val, next=None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.next = next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse1</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="comment"># auxiliary stack</span></span><br><span class="line">        stack = []</span><br><span class="line">        cur, head = root, root</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            stack.append(cur.val)</span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            root.val = stack.pop()</span><br><span class="line">            root = root.next</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse2</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="comment"># recursive</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> <span class="keyword">not</span> root.next:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        new_head = self.reverse2(root.next)</span><br><span class="line">        <span class="comment"># root.next just reversed, so it refers to last of new_head</span></span><br><span class="line">        root.next.next = root</span><br><span class="line">        root.next = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">return</span> new_head</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse3</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="comment"># iterative</span></span><br><span class="line">        new_head = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            tmp = root.next</span><br><span class="line">            <span class="comment"># point to new_head</span></span><br><span class="line">            root.next = new_head</span><br><span class="line">            <span class="comment"># update new_head</span></span><br><span class="line">            new_head = root</span><br><span class="line">            root = tmp</span><br><span class="line">        <span class="keyword">return</span> new_head</span><br></pre></td></tr></table></figure><h2 id="2-Microsoft-数组的最长递增子序列"><a href="#2-Microsoft-数组的最长递增子序列" class="headerlink" title="2 Microsoft-数组的最长递增子序列"></a>2 Microsoft-数组的最长递增子序列</h2><blockquote><p>Given an array of numbers, find the length of the longest increasing subsequence in the array. The subsequence does not necessarily have to be contiguous.<br>For example, given the array [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15], the longest increasing subsequence has length 6: it is 0, 2, 6, 9, 11, 15.</p></blockquote><p>这道题暴力求解的复杂度很高，采用<strong>动态规划</strong>的解法更好理解：<code>f(i)</code> 表示以当前元素结尾的递增子序列，则需要判断前面所有比它小的元素，递推式为 <code>f(i) = max(f(i), f(j)+1)</code>。这样做的时间复杂度为<strong>O(n^2)</strong>。</p><p>再观察求解的过程，我们每走一步，只需要更新每个长度递增子序列的最后一个元素，直到最后返回最大长度即可。详细思路见 <a href="https://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/" target="_blank" rel="noopener">这里</a>，GeeksforGeeks 上面的讲解非常精彩。更新过程采用<strong>二分法</strong>，整体时间复杂度为<strong>O(nlogk)</strong>，其中k是所求得的LIS最大长度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lis1</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">        <span class="comment"># dp: LIS ending with arr[i]</span></span><br><span class="line">        n = len(arr)</span><br><span class="line">        dp = [<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="keyword">if</span> arr[i] &gt; arr[j]:</span><br><span class="line">                    dp[i] = max(dp[i], dp[j]+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> max(dp) <span class="keyword">if</span> dp <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lis2</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">        <span class="comment"># O(nlogk)</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> arr:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n, res = len(arr), <span class="number">1</span></span><br><span class="line">        tails = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        tails[<span class="number">0</span>] = arr[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> arr[i] &lt; tails[<span class="number">0</span>]:</span><br><span class="line">                tails[<span class="number">0</span>] = arr[i]</span><br><span class="line">            <span class="keyword">elif</span> arr[i] &gt; tails[res<span class="number">-1</span>]:</span><br><span class="line">                tails[res] = arr[i]</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tails[self._find(tails, <span class="number">0</span>, res<span class="number">-1</span>, arr[i])] = arr[i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_find</span><span class="params">(self, A, lo, hi, num)</span>:</span></span><br><span class="line">        <span class="comment"># first target &gt;= num</span></span><br><span class="line">        <span class="keyword">while</span> lo &lt;= hi:</span><br><span class="line">            mid = (lo+hi) &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> A[mid] &gt;= num:</span><br><span class="line">                hi = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                lo = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> lo</span><br><span class="line"></span><br><span class="line">sol = Solution()</span><br><span class="line"><span class="keyword">assert</span> sol.lis1([<span class="number">0</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">14</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">13</span>, <span class="number">3</span>, <span class="number">11</span>, <span class="number">7</span>, <span class="number">15</span>]) == <span class="number">6</span></span><br><span class="line"><span class="keyword">assert</span> sol.lis2([<span class="number">0</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">14</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">13</span>, <span class="number">3</span>, <span class="number">11</span>, <span class="number">7</span>, <span class="number">15</span>]) == <span class="number">6</span></span><br></pre></td></tr></table></figure><h2 id="3-Facebook-单调不减的数组"><a href="#3-Facebook-单调不减的数组" class="headerlink" title="3 Facebook-单调不减的数组"></a>3 Facebook-单调不减的数组</h2><blockquote><p>Given an array of integers, write a function to determine whether the array could become non-decreasing by modifying at most 1 element.<br>For example, given the array [10, 5, 7], you should return true, since we can modify the 10 into a 1 to make the array non-decreasing.<br>Given the array [10, 5, 1], you should return false, since we can’t modify any one element to get a non-decreasing array.</p></blockquote><p>Leetcode原题：<a href="https://leetcode.com/problems/non-decreasing-array/" target="_blank" rel="noopener">Non Decreasing Array</a>。<br>题目标注的难度为Easy，但AC率低的可怜，不到20%，很容易忽略某个场景。我也提交了好几次，才通过全部测试用例。<br>为了用一次修改恢复数组的单调性，我们采取<strong>贪心策略</strong>：一旦发现 <code>inversion pair</code>，优先将大数改小，其次才考虑将小数改大。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">        <span class="comment"># greedy: fix monotonic</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(arr)):</span><br><span class="line">            <span class="keyword">if</span> arr[i<span class="number">-1</span>] &gt; arr[i]:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> i &lt; <span class="number">2</span> <span class="keyword">or</span> arr[i<span class="number">-2</span>] &lt;= arr[i]:</span><br><span class="line">                    <span class="comment"># now arr[i-1] is remain_min</span></span><br><span class="line">                    arr[i<span class="number">-1</span>] = arr[i]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># now arr[i] is front_max</span></span><br><span class="line">                    arr[i] = arr[i<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> count &lt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">sol = Solution()</span><br><span class="line"><span class="keyword">assert</span> sol.check([<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="keyword">assert</span> <span class="keyword">not</span> sol.check([<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br><span class="line"><span class="keyword">assert</span> <span class="keyword">not</span> sol.check([<span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文的完整代码见 &lt;a href=&quot;https://github.com/brightsunp/learn/blob/master/leetcode/DCP_71-80.py&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;h2 i
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://brightsunp.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Daily-Coding-Problem-61-70</title>
    <link href="https://brightsunp.github.io/2019/02/02/Daily-Coding-Problem-61-70/"/>
    <id>https://brightsunp.github.io/2019/02/02/Daily-Coding-Problem-61-70/</id>
    <published>2019-02-02T04:41:52.000Z</published>
    <updated>2020-08-03T03:47:49.950Z</updated>
    
    <content type="html"><![CDATA[<p>本文的完整代码见 <a href="https://github.com/brightsunp/learn/blob/master/leetcode/DCP_61-70.py" target="_blank" rel="noopener">这里</a>。</p><h2 id="1-Amazon-矩阵顺时针打印"><a href="#1-Amazon-矩阵顺时针打印" class="headerlink" title="1 Amazon-矩阵顺时针打印"></a>1 Amazon-矩阵顺时针打印</h2><blockquote><p>Given a N by M matrix of numbers, print out the matrix in a clockwise spiral.<br>For example, given the following matrix:<br>[[1,  2,  3,  4,  5],<br> [6,  7,  8,  9,  10],<br> [11, 12, 13, 14, 15],<br> [16, 17, 18, 19, 20]]<br>You should print out the following:<br>[1, 2, 3, 4, 5, 10, 15, 20, 19, 18, 17, 16, 11, 6, 7, 8, 9, 14, 13, 12]</p></blockquote><p>这是我在面试时遇过的原题，一点都不难，但很能考验代码的整洁性。</p><ul><li>第一种解法是直观打印，注意边界条件即可。</li><li>第二种解法利用了<strong>矩阵转置</strong>，递归的写法非常简洁，注意这样会修改原矩阵。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spiral1</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="comment"># brute</span></span><br><span class="line">        res = []</span><br><span class="line">        row_beg, col_beg, row_end, col_end = <span class="number">0</span>, <span class="number">0</span>, len(matrix)<span class="number">-1</span>, len(matrix[<span class="number">0</span>])<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> row_beg &lt; row_end <span class="keyword">and</span> col_beg &lt; col_end:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(col_beg, col_end+<span class="number">1</span>):</span><br><span class="line">                res.append(matrix[row_beg][j])</span><br><span class="line">            row_beg += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(row_beg, row_end+<span class="number">1</span>):</span><br><span class="line">                res.append(matrix[i][col_end])</span><br><span class="line">            col_end -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(col_end, col_beg<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                res.append(matrix[row_end][j])</span><br><span class="line">            row_end -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(row_end, row_beg<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                res.append(matrix[i][col_beg])</span><br><span class="line">            col_beg += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spiral2</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="comment"># transpose</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        row = list(matrix.pop(<span class="number">0</span>))</span><br><span class="line">        t = list(zip(*matrix))[::<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> row + self.spiral2(t)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sol = Solution()</span><br><span class="line">arg = [[<span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">       [<span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>,  <span class="number">10</span>],</span><br><span class="line">       [<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>],</span><br><span class="line">       [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>]]</span><br><span class="line">res = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">19</span>, <span class="number">18</span>, <span class="number">17</span>, <span class="number">16</span>, <span class="number">11</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">14</span>, <span class="number">13</span>, <span class="number">12</span>]</span><br><span class="line"><span class="keyword">assert</span> sol.spiral1(arg) == res</span><br><span class="line"><span class="keyword">assert</span> arg == [[<span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>], [<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>], [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>]]</span><br><span class="line"><span class="keyword">assert</span> sol.spiral2(arg) == res</span><br><span class="line"><span class="keyword">assert</span> arg == [[<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>], [<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>], [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>]]</span><br></pre></td></tr></table></figure><h2 id="2-Square-巧掷硬币"><a href="#2-Square-巧掷硬币" class="headerlink" title="2 Square-巧掷硬币"></a>2 Square-巧掷硬币</h2><blockquote><p>Assume you have access to a function <code>toss_biased()</code> which returns 0 or 1 with a probability that’s not 50-50 (but also not 0-100 or 100-0). You do not know the bias of the coin.<br>Write a function to simulate an unbiased coin toss.</p></blockquote><p>遇到概率的问题，一定要<strong>先思考、再实现</strong>。</p><ul><li>第一种解法是考虑 <code>P(0)=p, P(1)=1-p</code>，若掷硬币两次，则 <code>P(00)=p*p, P(11)=(1-p)*(1-p), P(01)=P(10)=p*(1-p)</code>，把00和11的情况丢弃即可。</li><li>第二种解法是用频率来模拟概率，采取大量的试验，一半取正一半取反，同样能实现用不均匀的硬币掷出 <code>50-50</code> 的概率。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">toss_unbiased1</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># P(01) = P(10) = p*(1-p)</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            x = self._toss_biased()</span><br><span class="line">            y = self._toss_biased()</span><br><span class="line">            <span class="keyword">if</span> x == <span class="number">0</span> <span class="keyword">and</span> y == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> x == <span class="number">1</span> <span class="keyword">and</span> y == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">toss_unbiased2</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># frequency =&gt; probability</span></span><br><span class="line">        n_experiments = <span class="number">100000</span></span><br><span class="line">        res_biased = &#123;<span class="number">1</span>: <span class="number">0</span>, <span class="number">0</span>: <span class="number">0</span>&#125;</span><br><span class="line">        res_unbiased = &#123;<span class="number">1</span>: <span class="number">0</span>, <span class="number">0</span>: <span class="number">0</span>&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n_experiments):</span><br><span class="line">            coin = self._toss_biased()</span><br><span class="line">            res_biased[coin] += <span class="number">1</span></span><br><span class="line">            coin = <span class="keyword">not</span> coin <span class="keyword">if</span> i &amp; <span class="number">1</span> <span class="keyword">else</span> coin</span><br><span class="line">            res_unbiased[coin] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">assert</span> round(res_biased[<span class="number">0</span>] / n_experiments, <span class="number">2</span>) == <span class="number">0.7</span></span><br><span class="line">        <span class="keyword">assert</span> round(res_biased[<span class="number">1</span>] / n_experiments, <span class="number">2</span>) == <span class="number">0.3</span></span><br><span class="line">        <span class="keyword">assert</span> round(res_unbiased[<span class="number">0</span>] / n_experiments, <span class="number">2</span>) == <span class="number">0.5</span></span><br><span class="line">        <span class="keyword">assert</span> round(res_unbiased[<span class="number">1</span>] / n_experiments, <span class="number">2</span>) == <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_toss_biased</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> random.random() &lt; <span class="number">0.7</span> <span class="keyword">else</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="3-Google-LFU缓存"><a href="#3-Google-LFU缓存" class="headerlink" title="3 Google-LFU缓存"></a>3 Google-LFU缓存</h2><blockquote><p>Implement an LFU (Least Frequently Used) cache. It should be able to be initialized with a cache size n, and contain the following methods:<br><code>set(key, value)</code>: sets key to value. If there are already n items in the cache and we are adding a new item, then it should also remove the least frequently used item. If there is a tie, then the least recently used key should be removed.<br><code>get(key)</code>: gets the value at key. If no such key exists, return null.<br>Each operation should run in O(1) time.</p></blockquote><p>这道题比之前的 <code>LRU缓存</code> 更复杂，需要优先找<strong>使用最少的</strong>，如果存在多个，再从中寻找<strong>使用时间最远的</strong>。<br>如果采取类似的 <code>DoubleLinkedList</code> 思路，可以设计两层链表，外层链表的尾端是使用最少的节点，内层链表的尾端是使用时间最远的节点，则外层链表尾端节点的尾端节点，即为容量超出时删除的节点。<br>从上述思路出发，借助 <code>OrderedDict</code> 来实现，极大地提高了代码的可读性。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict, OrderedDict</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFU</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity)</span>:</span></span><br><span class="line">        self.remain = capacity</span><br><span class="line">        self.min_freq = <span class="number">1</span></span><br><span class="line">        self.d_key = &#123;&#125;</span><br><span class="line">        self.d_freq = defaultdict(OrderedDict)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.d_key:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        self._update(key)</span><br><span class="line">        <span class="keyword">return</span> self.d_key[key][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.d_key:</span><br><span class="line">            self._update(key, value)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.d_key[key] = (value, <span class="number">1</span>)</span><br><span class="line">            self.d_freq[<span class="number">1</span>][key] = (value, <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> self.remain == <span class="number">0</span>:</span><br><span class="line">                removed = self.d_freq[self.min_freq].popitem(last=<span class="keyword">False</span>)</span><br><span class="line">                <span class="keyword">del</span> self.d_key[removed[<span class="number">0</span>]]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.remain -= <span class="number">1</span></span><br><span class="line">            self.min_freq = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_update</span><span class="params">(self, key, new_val=None)</span>:</span></span><br><span class="line">        value, freq = self.d_key[key]</span><br><span class="line">        <span class="keyword">if</span> new_val:</span><br><span class="line">            value = new_val</span><br><span class="line">        <span class="keyword">del</span> self.d_freq[freq][key]</span><br><span class="line">        <span class="keyword">if</span> len(self.d_freq[self.min_freq]) == <span class="number">0</span>:</span><br><span class="line">            self.min_freq += <span class="number">1</span></span><br><span class="line">        self.d_key[key] = (value, freq+<span class="number">1</span>)</span><br><span class="line">        self.d_freq[freq+<span class="number">1</span>][key] = (value, freq+<span class="number">1</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文的完整代码见 &lt;a href=&quot;https://github.com/brightsunp/learn/blob/master/leetcode/DCP_61-70.py&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;h2 i
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://brightsunp.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Daily-Coding-Problem-51-60</title>
    <link href="https://brightsunp.github.io/2019/01/23/Daily-Coding-Problem-51-60/"/>
    <id>https://brightsunp.github.io/2019/01/23/Daily-Coding-Problem-51-60/</id>
    <published>2019-01-23T04:55:52.000Z</published>
    <updated>2020-08-03T03:47:49.942Z</updated>
    
    <content type="html"><![CDATA[<p>本文的完整代码见 <a href="https://github.com/brightsunp/learn/blob/master/leetcode/DCP_51-60.py" target="_blank" rel="noopener">这里</a>。</p><h2 id="1-Facebook-随机洗牌"><a href="#1-Facebook-随机洗牌" class="headerlink" title="1 Facebook-随机洗牌"></a>1 Facebook-随机洗牌</h2><blockquote><p>Given a function that generates perfectly random numbers between 1 and k (inclusive), where k is an input, write a function that shuffles a deck of cards represented as an array using only swaps.<br>It should run in O(N) time.<br>Hint: Make sure each one of the 52! permutations of the deck is equally likely.</p></blockquote><p>洗牌算法是我在面试时遇过的原题，<a href="https://gaohaoyang.github.io/2016/10/16/shuffle-algorithm/" target="_blank" rel="noopener">这里</a> 有篇很好的总结。<br>我在实现时做了小的改动，将每次取出的数字由“交换到列表最后”改为了“交换到列表最前”，时间复杂度<strong>O(n)</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shuffle</span><span class="params">(self)</span>:</span></span><br><span class="line">        cards = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">53</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">52</span>):</span><br><span class="line">            r = i - <span class="number">1</span> + self.randK(<span class="number">52</span> - i)</span><br><span class="line">            cards[i], cards[r] = cards[r], cards[i]</span><br><span class="line">        <span class="keyword">return</span> cards</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">randK</span><span class="params">(self, k)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> random.randint(<span class="number">1</span>, k)</span><br></pre></td></tr></table></figure><h2 id="2-Google-LRU缓存"><a href="#2-Google-LRU缓存" class="headerlink" title="2 Google-LRU缓存"></a>2 Google-LRU缓存</h2><blockquote><p>Implement an LRU (Least Recently Used) cache. It should be able to be initialized with a cache size n, and contain the following methods:<br><code>set(key, value)</code>: sets key to value. If there are already n items in the cache and we are adding a new item, then it should also remove the least recently used item.<br><code>get(key)</code>: gets the value at key. If no such key exists, return null.<br>Each operation should run in O(1) time.</p></blockquote><p>我的初始解法是给每个节点加一个 <code>prior</code> 属性，每次 <code>get/set</code> 都更新 <code>prior</code>；容量超出时，则删除 <code>prior</code> 最小的那个节点。这样做的话，<code>get</code> 时间复杂度<strong>O(1)</strong>，<code>set</code> 时间复杂度<strong>O(n)</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRU1</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity)</span>:</span></span><br><span class="line">        <span class="comment"># &#123;key: [value, prior]&#125;</span></span><br><span class="line">        self.cap = capacity</span><br><span class="line">        self.d = &#123;&#125;</span><br><span class="line">        self.prior = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.d:</span><br><span class="line">            self.prior += <span class="number">1</span></span><br><span class="line">            self.d[key][<span class="number">1</span>] = self.prior</span><br><span class="line">            <span class="keyword">return</span> self.d[key][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(self.d) == self.cap <span class="keyword">and</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.d:</span><br><span class="line">            least_used = min((v[<span class="number">1</span>], k) <span class="keyword">for</span> k, v <span class="keyword">in</span> self.d.items())</span><br><span class="line">            <span class="keyword">del</span> self.d[least_used[<span class="number">1</span>]]</span><br><span class="line">        self.prior += <span class="number">1</span></span><br><span class="line">        self.d[key] = [value, self.prior]</span><br></pre></td></tr></table></figure><p>既然采用了节点的模型，那干脆用的更彻底。<br>我们引入双向链表，每次 <code>get/set</code> 都把用到的节点移到链表尾部；容量超出时，则从链表头部删除节点。增、删链表节点的时间复杂度都为<strong>O(1)</strong>，这才是最优解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DllNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, k, v)</span>:</span></span><br><span class="line">        self.key = k</span><br><span class="line">        self.val = v</span><br><span class="line">        self.prev = <span class="keyword">None</span></span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRU2</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity)</span>:</span></span><br><span class="line">        self.cap = capacity</span><br><span class="line">        self.d = &#123;&#125;</span><br><span class="line">        self.head, self.tail = DllNode(<span class="number">0</span>, <span class="number">0</span>), DllNode(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        self.head.next, self.tail.prev = self.tail, self.head</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.d:</span><br><span class="line">            node = self.d[key]</span><br><span class="line">            self._remove(node)</span><br><span class="line">            self._add(node)</span><br><span class="line">            <span class="keyword">return</span> node.val</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.d:</span><br><span class="line">            self._remove(self.d[key])</span><br><span class="line">        node = DllNode(key, value)</span><br><span class="line">        self._add(node)</span><br><span class="line">        self.d[key] = node</span><br><span class="line">        <span class="keyword">if</span> len(self.d) &gt; self.cap:</span><br><span class="line">            h = self.head.next</span><br><span class="line">            self._remove(h)</span><br><span class="line">            <span class="keyword">del</span> self.d[h.key]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_remove</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        p = node.prev</span><br><span class="line">        n = node.next</span><br><span class="line">        p.next = n</span><br><span class="line">        n.prev = p</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_add</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        t = self.tail.prev</span><br><span class="line">        t.next = node</span><br><span class="line">        self.tail.prev = node</span><br><span class="line">        node.prev = t</span><br><span class="line">        node.next = self.tail</span><br></pre></td></tr></table></figure><h2 id="3-Apple-用栈实现队列"><a href="#3-Apple-用栈实现队列" class="headerlink" title="3 Apple-用栈实现队列"></a>3 Apple-用栈实现队列</h2><blockquote><p>Implement a queue using two stacks. Recall that a queue is a FIFO (first-in, first-out) data structure with the following methods:<br><code>enqueue</code>, which inserts an element into the queue.<br><code>dequeue</code>, which removes it.</p></blockquote><p>借助于两个栈，一个用来存储，一个用来缓冲。<br>入队时，进入存储栈；出队时，取缓冲栈的栈顶为出队元素，如果缓冲栈为空，则将存储栈的元素全部“倒入”缓冲栈中。示意图如下：</p><p><img src="/img/implement_queue_with_two_stacks.jpg" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.store = []</span><br><span class="line">        self.buffer = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.store.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.buffer:</span><br><span class="line">            <span class="keyword">return</span> self.buffer.pop()</span><br><span class="line">        <span class="keyword">while</span> self.store:</span><br><span class="line">            self.buffer.append(self.store.pop())</span><br><span class="line">        <span class="keyword">return</span> self.buffer.pop()</span><br></pre></td></tr></table></figure><p>类似的题是“<strong>用队列实现栈</strong>”，解法更巧妙：在入栈时，将队列转化为栈，队列的“出队”也就转化为“出栈”。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.queue = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="comment"># convert queue to stack</span></span><br><span class="line">        self.queue.append(x)</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1</span>, len(self.queue)):</span><br><span class="line">            self.queue.append(self.queue.pop(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.queue.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.queue[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.queue</span><br></pre></td></tr></table></figure><h2 id="4-Microsoft-url短编码"><a href="#4-Microsoft-url短编码" class="headerlink" title="4 Microsoft-url短编码"></a>4 Microsoft-url短编码</h2><blockquote><p>Implement a URL shortener with the following methods:<br><code>shorten(url)</code>, which shortens the url into a six-character alphanumeric string, such as zLg6wl.<br><code>restore(short)</code>, which expands the shortened string into the original url. If no such shortened string exists, return null.<br>Hint: What if we enter the same URL twice?</p></blockquote><p>借助于 <a href="https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8" target="_blank" rel="noopener">散列算法</a> 来实现，Python中 <code>hashlib</code> 的使用教程见 <a href="https://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/0013868328251266d86585fc9514536a638f06b41908d44000" target="_blank" rel="noopener">这里</a>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UrlShortener</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.d = &#123;&#125;</span><br><span class="line">        self.m = hashlib.sha256</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shorten</span><span class="params">(self, url)</span>:</span></span><br><span class="line">        sha_sign = self.m(url.encode()).hexdigest()</span><br><span class="line">        short_hash = sha_sign[:<span class="number">6</span>]</span><br><span class="line">        self.d[short_hash] = url</span><br><span class="line">        <span class="keyword">return</span> short_hash</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">restore</span><span class="params">(self, short)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.d.get(short, <span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><h2 id="5-Amazon-从旋转数组中查找元素"><a href="#5-Amazon-从旋转数组中查找元素" class="headerlink" title="5 Amazon-从旋转数组中查找元素"></a>5 Amazon-从旋转数组中查找元素</h2><blockquote><p>An sorted array of integers was rotated an unknown number of times. Given such an array, find the index of the element in the array in faster than linear time. If the element doesn’t exist in the array, return null.<br>Given the array [13, 18, 25, 2, 8, 10] and the element 8, return 4 (the index of 8 in the array). You can assume all the integers in the array are unique.</p></blockquote><p>对于查找的问题，自然会考虑二分法，但我们不知道原数组在哪旋转了。<br>对数组 <code>[0, 1, 2, 4, 5, 6, 7]</code> 进行分析，共有以下7种旋转的方式：<br>0　　1　　2　　<span style="color: #ff0000;"><strong>4　　5　　6　　7</strong></span><br>7　　0　　1　　<span style="color: #ff0000;"><strong>2　　4　　5　　6</strong></span><br>6　　7　　0　　<span style="color: #ff0000;"><strong>1　　2　　4　　5</strong></span><br>5　　6　　7　　<span style="color: #ff0000;"><strong>0　　1　　2　　4</strong></span><br><span style="color: #ff0000;"><strong>4　　5　　6　　7</strong></span>　　0　　1　　2<br><span style="color: #ff0000;"><strong>2　　4　　5　　6</strong></span>　　7　　0　　1<br><span style="color: #ff0000;"><strong>1　　2　　4　　5</strong></span>　　6　　7　　0</p><p>一目了然，总结规律如下：<strong>如果中间数小于最右边的数，则右半段是有序的</strong>，否则左半段是有序的。<br>我们通过有序的半段来判断目标值是否在此区域内，就可以决定要保留哪半边了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_num</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        left, right = <span class="number">0</span>, len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left + right) &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; nums[right]:</span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt; target &lt;= nums[right]:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[left] &lt;= target &lt; nums[mid]:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文的完整代码见 &lt;a href=&quot;https://github.com/brightsunp/learn/blob/master/leetcode/DCP_51-60.py&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;h2 i
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://brightsunp.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Daily-Coding-Problem-41-50</title>
    <link href="https://brightsunp.github.io/2019/01/14/Daily-Coding-Problem-41-50/"/>
    <id>https://brightsunp.github.io/2019/01/14/Daily-Coding-Problem-41-50/</id>
    <published>2019-01-14T02:56:22.000Z</published>
    <updated>2020-08-03T03:47:49.935Z</updated>
    
    <content type="html"><![CDATA[<p>随着做题的数量见长，我整理了不少专题，针对不同的tag有所总结。以后文章的Leetcode标签，并不局限于Leetcode，更多的来源于GeeksforGeeks、DCP、CtCI等。本文的完整代码见 <a href="https://github.com/brightsunp/learn/blob/master/leetcode/DCP_41-50.py" target="_blank" rel="noopener">这里</a>。</p><h2 id="1-Google-和为定值的子数组"><a href="#1-Google-和为定值的子数组" class="headerlink" title="1 Google-和为定值的子数组"></a>1 Google-和为定值的子数组</h2><blockquote><p>Given a list of integers S and a target number k, write a function that returns a subset of S that adds up to k. If such a subset cannot be made, then return null.<br>Integers can appear more than once in the list. You may assume all numbers in the list are positive.<br>[12, 1, 61, 5, 9, 2], 24 =&gt; [12, 9, 2, 1]</p></blockquote><p>经典的Backtracking问题，判断有没有解 / 寻找一个解，借用我这篇 <a href="https://brightsunp.github.io/2018/11/25/%E5%87%A0%E4%B8%AA%E5%85%B8%E5%9E%8B%E7%9A%84Backtracking%E9%97%AE%E9%A2%98/#0-%E5%9B%9E%E6%BA%AF%E6%A8%A1%E6%9D%BF">总结</a> 中的模板即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="comment"># find one solution</span></span><br><span class="line">        self.res = []</span><br><span class="line">        self.dfs(nums, k, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.res <span class="keyword">or</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, nums, k, pos)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> k &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(pos, len(nums)):</span><br><span class="line">            self.res.append(nums[i])</span><br><span class="line">            <span class="keyword">if</span> self.dfs(nums, k-nums[i], i+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.res.pop()</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h2 id="2-Google-数组中的逆序对"><a href="#2-Google-数组中的逆序对" class="headerlink" title="2 Google-数组中的逆序对"></a>2 Google-数组中的逆序对</h2><blockquote><p>We can determine how “out of order” an array A is by counting the number of inversions it has. Two elements A[i] and A[j] form an inversion if A[i] &gt; A[j] but i &lt; j. That is, a smaller element appears after a larger element.<br>Given an array, count the number of inversions it has. Do this faster than O(N^2) time. You may assume each element in the array is distinct.<br>A sorted list has zero inversions.<br>[2, 4, 1, 3, 5] =&gt; 3, since (2, 1), (4, 1), and (4, 3).<br>[5, 4, 3, 2, 1] =&gt; 10, since every distinct pair forms an inversion.</p></blockquote><p>暴力解法，遍历每个元素，判断其后面的元素是否与之“逆序”，时间复杂度<strong>O(n^2)</strong>；<br>从优化的角度，这道题和排序相关，时间复杂度应该不低于<strong>O(nlogn)</strong>，借用 <code>mergeSort</code> 的思路来实现。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countInversions1</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="comment"># O(n^2)</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, pre <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">for</span> cur <span class="keyword">in</span> nums[i+<span class="number">1</span>:]:</span><br><span class="line">                count += <span class="number">1</span> <span class="keyword">if</span> pre &gt; cur <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countInversions2</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="comment"># O(nlogn): mergeSort</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        copy = nums[:]</span><br><span class="line">        <span class="keyword">return</span> self.merge(nums, copy, <span class="number">0</span>, len(nums)<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums, copy, left, right)</span>:</span></span><br><span class="line">        <span class="comment"># merge sorted arrays and return inversion count</span></span><br><span class="line">        <span class="keyword">if</span> left == right:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        mid = (right+left) &gt;&gt; <span class="number">1</span></span><br><span class="line">        left_count = self.merge(nums, copy, left, mid)</span><br><span class="line">        right_count = self.merge(nums, copy, mid+<span class="number">1</span>, right)</span><br><span class="line">        count, i, j, idx = <span class="number">0</span>, mid, right, right</span><br><span class="line">        <span class="keyword">while</span> i &gt;= left <span class="keyword">and</span> j &gt;= mid+<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                count += j-mid</span><br><span class="line">                copy[idx] = nums[i]</span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                copy[idx] = nums[j]</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            idx -= <span class="number">1</span></span><br><span class="line">        copy[left:idx+<span class="number">1</span>] = nums[left:i+<span class="number">1</span>] + nums[mid+<span class="number">1</span>:j+<span class="number">1</span>]</span><br><span class="line">        nums[left:right+<span class="number">1</span>] = copy[left:right+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> count + left_count + right_count</span><br></pre></td></tr></table></figure><h2 id="3-Facebook-股票最大收益问题"><a href="#3-Facebook-股票最大收益问题" class="headerlink" title="3 Facebook-股票最大收益问题"></a>3 Facebook-股票最大收益问题</h2><blockquote><p>Given a array of numbers representing the stock prices of a company in chronological order, write a function that calculates the maximum profit you could have made from buying and selling that stock once. You must buy before you can sell it.<br>[9, 11, 8, 5, 7, 10] =&gt; 5, since you could buy the stock at 5 dollars and sell it at 10 dollars.</p></blockquote><p>这题原本是一个系列，难度依次提升：</p><ul><li>买卖一次</li><li>买卖任意多次</li><li>买卖最多k次</li></ul><p>每个场景都用到了DP的思想，特别是“买卖最多k次”，参考自 <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/discuss/54113/A-Concise-DP-Solution-in-Java/55579" target="_blank" rel="noopener">这里</a>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buyOnce</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(prices) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        max_profit = max_cur = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(prices)):</span><br><span class="line">            <span class="comment"># sell to get cur_profit</span></span><br><span class="line">            max_cur = max(<span class="number">0</span>, max_cur+prices[i]-prices[i<span class="number">-1</span>])</span><br><span class="line">            max_profit = max(max_profit, max_cur)</span><br><span class="line">        <span class="keyword">return</span> max_profit</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buyAsMany</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(prices) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        profit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(prices)):</span><br><span class="line">            <span class="comment"># sell only if price increased</span></span><br><span class="line">            profit += max(<span class="number">0</span>, prices[i]-prices[i<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> profit</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buyAtMostK</span><span class="params">(self, prices, k)</span>:</span></span><br><span class="line">        <span class="comment"># dp[i][j] = max(dp[i][j-1], max([dp[i-1][t-1]+prices[j]-prices[t] for t in range(j)]))</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        <span class="comment"># avoid MemoryError</span></span><br><span class="line">        <span class="keyword">if</span> k &gt;= (n&gt;&gt;<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> self.buyAsMany(prices)</span><br><span class="line">        dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(k+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, k+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># reduce O(knn) to O(kn)</span></span><br><span class="line">            tmp = -prices[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">                <span class="comment"># sell or not sell</span></span><br><span class="line">                dp[i][j] = max(dp[i][j<span class="number">-1</span>], prices[j]+tmp)</span><br><span class="line">                tmp = max(tmp, dp[i<span class="number">-1</span>][j<span class="number">-1</span>]-prices[j])</span><br><span class="line">        <span class="keyword">return</span> dp[k][n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h2 id="4-Google-由前-中序遍历结果还原二叉树"><a href="#4-Google-由前-中序遍历结果还原二叉树" class="headerlink" title="4 Google-由前/中序遍历结果还原二叉树"></a>4 Google-由前/中序遍历结果还原二叉树</h2><blockquote><p>Given pre-order and in-order traversals of a binary tree, write a function to reconstruct the tree. You may assume that duplicates do not exist in the tree.<br>For example, given the following preorder traversal: [a, b, d, e, c, f, g]<br>And the following inorder traversal: [d, b, e, a, f, c, g]<br>You should return the following tree:<br>    a<br>   / \<br>  b   c<br> / \ / \<br>d  e f  g</p></blockquote><p>这道题我用了三种解法：</p><ul><li><strong>递归</strong>，用Python的切片写法；</li><li><strong>改进后的递归</strong>，用数组索引，避免切片带来的空间开销；</li><li><strong>迭代</strong>，用栈来存储节点的顺序，相当于非递归遍历的逆过程。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree1</span><span class="params">(self, preorder, inorder)</span>:</span></span><br><span class="line">        <span class="comment"># recursive1 [284ms]</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        root = TreeNode(preorder[<span class="number">0</span>])</span><br><span class="line">        pos = inorder.index(preorder[<span class="number">0</span>])</span><br><span class="line">        root.left = self.buildTree1(preorder[<span class="number">1</span>:pos+<span class="number">1</span>], inorder[:pos])</span><br><span class="line">        root.right = self.buildTree1(preorder[pos+<span class="number">1</span>:], inorder[pos+<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree2</span><span class="params">(self, preorder, inorder)</span>:</span></span><br><span class="line">        <span class="comment"># recursive2 [48ms]</span></span><br><span class="line">        self.in_map = &#123;val: i <span class="keyword">for</span> i, val <span class="keyword">in</span> enumerate(inorder)&#125;</span><br><span class="line">        self.preorder = preorder</span><br><span class="line">        self.inorder = inorder</span><br><span class="line">        <span class="keyword">return</span> self.helper(<span class="number">0</span>, len(preorder), <span class="number">0</span>, len(inorder))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, pre_beg, pre_end, in_beg, in_end)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> pre_beg &gt;= pre_end:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        root = TreeNode(self.preorder[pre_beg])</span><br><span class="line">        in_root = self.in_map[root.val]</span><br><span class="line">        offset = in_root - in_beg</span><br><span class="line">        root.left = self.helper(pre_beg+<span class="number">1</span>, pre_beg+offset+<span class="number">1</span>, in_beg, in_root)</span><br><span class="line">        root.right = self.helper(pre_beg+offset+<span class="number">1</span>, pre_end, in_root+<span class="number">1</span>, in_end)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree3</span><span class="params">(self, preorder, inorder)</span>:</span></span><br><span class="line">        <span class="comment"># iterative [48ms]</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        root = TreeNode(preorder[<span class="number">0</span>])</span><br><span class="line">        stack = [root]</span><br><span class="line">        i, j = <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(preorder):</span><br><span class="line">            cur = TreeNode(preorder[i])</span><br><span class="line">            mark = <span class="keyword">None</span></span><br><span class="line">            <span class="comment"># comes to an end of the left node</span></span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>].val == inorder[j]:</span><br><span class="line">                mark = stack.pop()</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> mark:</span><br><span class="line">                mark.right = cur</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack[<span class="number">-1</span>].left = cur</span><br><span class="line">            stack.append(cur)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>与之类似的题：由前/后序遍历结果还原二叉树。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">constructFromPrePost</span><span class="params">(self, pre, post)</span>:</span></span><br><span class="line">        <span class="comment"># iterative</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pre:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        root = TreeNode(pre[<span class="number">0</span>])</span><br><span class="line">        stack = [root]</span><br><span class="line">        i, j = <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(pre):</span><br><span class="line">            cur = TreeNode(pre[i])</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>].val == post[j]:</span><br><span class="line">                stack.pop()</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> stack[<span class="number">-1</span>].left:</span><br><span class="line">                stack[<span class="number">-1</span>].right = cur</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack[<span class="number">-1</span>].left = cur</span><br><span class="line">            stack.append(cur)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h2 id="5-Microsoft-二叉树表示的算术计算式"><a href="#5-Microsoft-二叉树表示的算术计算式" class="headerlink" title="5 Microsoft-二叉树表示的算术计算式"></a>5 Microsoft-二叉树表示的算术计算式</h2><blockquote><p>Suppose an arithmetic expression is given as a binary tree. Each leaf is an integer and each internal node is one of ‘+’, ‘−’, ‘∗’, or ‘/‘.<br>Given the root to such a tree, write a function to evaluate it.<br>For example, given the following tree:<br>    *<br>   / \</p><ul><li>+<br>/ \  / \<br>3  2  4  5<br>You should return 45, as it is (3 + 2) * (4 + 5).</li></ul></blockquote><p>看到题目的第一反应是把二叉树还原为算术表达式，即中序遍历。但这个式子给人计算很容易，交给计算机操作，就不好处理运算符的优先级问题。所以转化为计算机容易理解的形式——<a href="https://zh.wikipedia.org/wiki/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95" target="_blank" rel="noopener">逆波兰式</a>，通过后序遍历来实现。</p><p>逆波兰式的计算过程如下：</p><ol><li>准备一个栈，开始从左到右遍历逆波兰式。</li><li>如果取到操作数，直接入栈；如果取到运算符，从栈中弹出2个数进行运算，然后把运算结果入栈。 </li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">evaluate</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="comment"># Reverse Polish: postorder traverse</span></span><br><span class="line">        self.vals = []</span><br><span class="line">        self.postorder(root)</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> val <span class="keyword">in</span> self.vals:</span><br><span class="line">            <span class="keyword">if</span> isinstance(val, int):</span><br><span class="line">                stack.append(val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                a = stack.pop()</span><br><span class="line">                b = stack.pop()</span><br><span class="line">                stack.append(self.operate(a, b, val))</span><br><span class="line">        <span class="comment"># one element remains in the stack</span></span><br><span class="line">        <span class="keyword">return</span> stack[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.postorder(root.left)</span><br><span class="line">        self.postorder(root.right)</span><br><span class="line">        self.vals.append(root.val)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">operate</span><span class="params">(self, a, b, operator)</span>:</span></span><br><span class="line">        d = &#123;<span class="string">'+'</span>: a+b, <span class="string">'-'</span>: a-b, <span class="string">'*'</span>: a*b, <span class="string">'/'</span>: a/b&#125;</span><br><span class="line">        <span class="keyword">return</span> d[operator]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;随着做题的数量见长，我整理了不少专题，针对不同的tag有所总结。以后文章的Leetcode标签，并不局限于Leetcode，更多的来源于GeeksforGeeks、DCP、CtCI等。本文的完整代码见 &lt;a href=&quot;https://github.com/brightsu
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://brightsunp.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>几个典型的位运算问题</title>
    <link href="https://brightsunp.github.io/2019/01/07/%E5%87%A0%E4%B8%AA%E5%85%B8%E5%9E%8B%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97%E9%97%AE%E9%A2%98/"/>
    <id>https://brightsunp.github.io/2019/01/07/几个典型的位运算问题/</id>
    <published>2019-01-07T06:58:19.000Z</published>
    <updated>2020-08-03T03:47:49.929Z</updated>
    
    <content type="html"><![CDATA[<p>非cs出身的我对二进制不够敏感，所以一直很头疼位运算的问题。上次看了M67的一篇 <a href="http://www.matrix67.com/blog/archives/263" target="_blank" rel="noopener">文章</a>，我把里面提到的公式都推导一遍，再按tag刷题进行巩固；其实理解以后并不可怕，反而拓宽了做其他题的思路。本文题目包括纯粹的位运算，以及位运算的典型应用，完整代码见 <a href="https://github.com/brightsunp/learn/blob/master/leetcode/learn_Bit_Manipulation.py" target="_blank" rel="noopener">这里</a>。</p><h2 id="0-六种位运算符的应用"><a href="#0-六种位运算符的应用" class="headerlink" title="0 六种位运算符的应用"></a>0 六种位运算符的应用</h2><ol><li><code>&amp;</code> 取某位的值，或改某位的值为0</li><li><code>|</code> 改某位的值为1</li><li><code>^</code> 某位取反，逆运算是它本身</li><li><code>~</code> 所有位取反：无符号数，得到与该类型上界的差；有符号数，用第一位 <code>0/1</code> 标识 <code>正/负</code>，导致负数比正数多一个；计算负数采用反码+补码，所以 <code>~x=-x-1</code>。</li><li><code>&lt;&lt;k</code> 乘以2的k次方</li><li><code>&gt;&gt;k</code> 除以2的k次方（整除）</li></ol><table><thead><tr><th>常规操作</th><th>表达式</th><th>高级操作</th><th>表达式</th></tr></thead><tbody><tr><td>取最末位</td><td>x &amp; 1</td><td>改最后一个1为0</td><td>x &amp; (x-1)</td></tr><tr><td>取右数第k位</td><td>(x &gt;&gt; (k-1)) &amp; 1</td><td>改最后一个0为1</td><td>x &#124; (x+1)</td></tr><tr><td>取末k位</td><td>x &amp; ((1 &lt;&lt; k) - 1)</td><td>取最后一个1出现的位到结尾</td><td>x &amp; (~x+1) 或 x &amp; -x</td></tr><tr><td>改最末位为1, 0</td><td>x &#124; 1, x &amp; ~1</td></tr><tr><td>改右数第k位为1</td><td>x &#124; (1 &lt;&lt; (k-1))</td></tr><tr><td>改右数第k位为0</td><td>x &amp; ~(1 &lt;&lt; (k-1))</td></tr><tr><td>最末位取反</td><td>x ^ 1</td></tr><tr><td>右数第k位取反</td><td>x ^ (1 &lt;&lt; (k-1))</td></tr><tr><td>末k位取反</td><td>x ^ ((1 &lt;&lt; k) - 1)</td></tr></tbody></table><h2 id="1-Repeated-DNA-Sequences"><a href="#1-Repeated-DNA-Sequences" class="headerlink" title="1 Repeated DNA Sequences"></a>1 Repeated DNA Sequences</h2><p><a href="https://leetcode.com/problems/repeated-dna-sequences" target="_blank" rel="noopener">187. Repeated DNA Sequences</a></p><blockquote><p>All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: “ACGAATTCCG”. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.<br>Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.<br>“AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT” =&gt; [“AAAAACCCCC”, “CCCCCAAAAA”]</p></blockquote><p>这道题的第一反应是<strong>哈希表+滑动窗口</strong>，实现起来也很简单，果然是熟能生巧。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRepeatedDnaSequences1</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># hashmap</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)<span class="number">-9</span>):</span><br><span class="line">            cur = s[i:i+<span class="number">10</span>]</span><br><span class="line">            d[cur] = d.get(cur, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> [k <span class="keyword">for</span> k, v <span class="keyword">in</span> d.items() <span class="keyword">if</span> v &gt; <span class="number">1</span>]</span><br></pre></td></tr></table></figure></p><p>但discuss区有人提到，哈希值不能代表唯一的字符串，并且长度为10的字符串哈希很浪费内存；<br>考虑到本题只出现了“A、C、G、T”四个字母，可以用两个bit进行<strong>字符串编码</strong>，这样就节省了大量的内存空间。参考自 <a href="https://leetcode.com/problems/repeated-dna-sequences/discuss/53867/Clean-Java-solution-(hashmap-%2B-bits-manipulation" target="_blank" rel="noopener">这里</a>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRepeatedDnaSequences2</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># 2-bits: encode string</span></span><br><span class="line">        m = &#123;<span class="string">'A'</span>: <span class="number">0</span>, <span class="string">'C'</span>: <span class="number">1</span>, <span class="string">'G'</span>: <span class="number">2</span>, <span class="string">'T'</span>: <span class="number">3</span>&#125;</span><br><span class="line">        seen, repeated = set(), set()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)<span class="number">-9</span>):</span><br><span class="line">            cur = s[i:i+<span class="number">10</span>]</span><br><span class="line">            v = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> letter <span class="keyword">in</span> cur:</span><br><span class="line">                v = v &lt;&lt; <span class="number">2</span> | m[letter]</span><br><span class="line">            <span class="keyword">if</span> v <span class="keyword">in</span> seen <span class="keyword">and</span> v <span class="keyword">not</span> <span class="keyword">in</span> repeated:</span><br><span class="line">                res.append(cur)</span><br><span class="line">                repeated.add(v)</span><br><span class="line">            seen.add(v)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="2-Bitwise-AND-of-Numbers-Range"><a href="#2-Bitwise-AND-of-Numbers-Range" class="headerlink" title="2 Bitwise AND of Numbers Range"></a>2 Bitwise AND of Numbers Range</h2><p><a href="https://leetcode.com/problems/bitwise-and-of-numbers-range/" target="_blank" rel="noopener">201. Bitwise AND of Numbers Range</a></p><blockquote><p>Given a range [m, n] where 0 &lt;= m &lt;= n &lt;= 2147483647, return the bitwise AND of all numbers in this range, inclusive.<br>[5,7] =&gt; 4, [0,1] =&gt; 0</p></blockquote><p>要对范围内的数进行<strong>全量与运算</strong>，我们知道 <code>m&amp;(m-1)</code> 的最后一位必为0，所以两个以上的连续数全量与运算的结果最后几位必为0；<br>而一个数连续地加1，先发生改变的是低位，那么找到尚未发生改变的位，将此位置后所有位的值改为0即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution2</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rangeBitwiseAnd1</span><span class="params">(self, m, n)</span>:</span></span><br><span class="line">        <span class="comment"># recursive</span></span><br><span class="line">        <span class="keyword">return</span> self.rangeBitwiseAnd1(m &gt;&gt; <span class="number">1</span>, n &gt;&gt; <span class="number">1</span>) &lt;&lt; <span class="number">1</span> <span class="keyword">if</span> m != n <span class="keyword">else</span> m</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rangeBitwiseAnd2</span><span class="params">(self, m, n)</span>:</span></span><br><span class="line">        <span class="comment"># count zeros</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> m != n:</span><br><span class="line">            m, n, count = m &gt;&gt; <span class="number">1</span>, n &gt;&gt; <span class="number">1</span>, count + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> m &lt;&lt; count</span><br></pre></td></tr></table></figure><h2 id="3-Maximum-Product-of-Word-Lengths"><a href="#3-Maximum-Product-of-Word-Lengths" class="headerlink" title="3 Maximum Product of Word Lengths"></a>3 Maximum Product of Word Lengths</h2><p><a href="https://leetcode.com/problems/maximum-product-of-word-lengths/" target="_blank" rel="noopener">318. Maximum Product of Word Lengths</a></p><blockquote><p>Given a string array words, find the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. You may assume that each word will contain only lower case letters. If no such two words exist, return 0.<br>[“abcw”,”baz”,”foo”,”bar”,”xtfn”,”abcdef”] =&gt; 16<br>Explanation: The two words can be “abcw”, “xtfn”.</p></blockquote><p>这道题的关键是判断两个word是否包含相同的字母，可以用<strong>集合的交</strong>求解，比较浪费内存；<br>如何利用位运算这个新武器呢？为了节省空间，我们用26个bit来记录是否包含每个字母，再使用<strong>与运算</strong>来实现“相交”的判断。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution3</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProduct1</span><span class="params">(self, words)</span>:</span></span><br><span class="line">        <span class="comment"># hashset</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(words)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(words)):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> (set(words[i]) &amp; set(words[j])):</span><br><span class="line">                    res = max(res, len(words[i]) * len(words[j]))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProduct2</span><span class="params">(self, words)</span>:</span></span><br><span class="line">        <span class="comment"># 26-bits: store distinct letters</span></span><br><span class="line">        values = [<span class="number">0</span>] * len(words)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(words)):</span><br><span class="line">            <span class="keyword">for</span> char <span class="keyword">in</span> words[i]:</span><br><span class="line">                values[i] |= <span class="number">1</span> &lt;&lt; (ord(char) - ord(<span class="string">'a'</span>))</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="keyword">if</span> values[i] &amp; values[j] == <span class="number">0</span>:</span><br><span class="line">                    res = max(res, len(words[i]) * len(words[j]))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="4-Sum-of-Two-Integers"><a href="#4-Sum-of-Two-Integers" class="headerlink" title="4 Sum of Two Integers"></a>4 Sum of Two Integers</h2><p><a href="https://leetcode.com/problems/sum-of-two-integers/" target="_blank" rel="noopener">371. Sum of Two Integers</a></p><blockquote><p>Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.<br>a = -2, b = 3 =&gt; 1</p></blockquote><p>用位运算实现四则运算，<a href="https://www.cnblogs.com/kiven-code/archive/2012/09/15/2686922.html" target="_blank" rel="noopener">这里</a> 有篇很好的总结。<br>具体到加法，原理想通了也不难：先不考虑进位，0+0、1+1得0，0+1、1+0得1，正好是异或运算的结果；再考虑进位，1+1得1，其他得0，正好是与运算的结果。也就是说 <code>add(a, b) == add(a^b, a&amp;b&lt;&lt;1)</code>，通过<strong>递归或迭代</strong>都可以解决。<br>值得注意的是，Python整数的位数不确定，所以需要通过 <code>&amp;mask</code> 取每个数的后32位，通过 <code>^mask</code> 对每个数的后32位取反。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution4</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">        <span class="comment"># 32-bits integer max (MIN = 0x80000000)</span></span><br><span class="line">        MAX = <span class="number">0x7FFFFFFF</span></span><br><span class="line">        <span class="comment"># mask to get last 32 bits</span></span><br><span class="line">        mask = <span class="number">0xFFFFFFFF</span></span><br><span class="line">        <span class="keyword">while</span> b != <span class="number">0</span>:</span><br><span class="line">            a, b = (a ^ b) &amp; mask, ((a &amp; b) &lt;&lt; <span class="number">1</span>) &amp; mask</span><br><span class="line">        <span class="comment"># if a is negative, get a's 32 bits complement positive first</span></span><br><span class="line">        <span class="comment"># then get 32-bit positive's Python complement negative</span></span><br><span class="line">        <span class="keyword">return</span> a <span class="keyword">if</span> a &lt;= MAX <span class="keyword">else</span> ~(a ^ mask)</span><br></pre></td></tr></table></figure><p>具体到乘法，直接对<strong>竖式乘法</strong>进行模拟：从乘数的末位起，遇0舍弃，遇1则累加左移后的被乘数，直到最高位。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution4</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">        a = a <span class="keyword">if</span> a &gt;= <span class="number">0</span> <span class="keyword">else</span> self.add(~a, <span class="number">1</span>)</span><br><span class="line">        b = b <span class="keyword">if</span> b &gt;= <span class="number">0</span> <span class="keyword">else</span> self.add(~b, <span class="number">1</span>)</span><br><span class="line">        product = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> b != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> b &amp; <span class="number">1</span>:</span><br><span class="line">                product = self.add(product, a)</span><br><span class="line">            a, b = a &lt;&lt; <span class="number">1</span>, b &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> product <span class="keyword">if</span> a^b &gt;= <span class="number">0</span> <span class="keyword">else</span> self.add(~product, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="5-Reverse-Bits"><a href="#5-Reverse-Bits" class="headerlink" title="5 Reverse Bits"></a>5 Reverse Bits</h2><p><a href="https://leetcode.com/problems/reverse-bits" target="_blank" rel="noopener">190. Reverse Bits</a></p><blockquote><p>Reverse bits of a given 32 bits unsigned integer.<br>00000010100101000001111010011100 =&gt; 00111001011110000010100101000000</p></blockquote><p>相比之下，这道题的思路最直观：取原数的最末位，用另一个数来存储取到的位；然后右移，重复以上步骤。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution5</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBits</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">            res = (res &lt;&lt; <span class="number">1</span>) | (n &amp; <span class="number">1</span>)</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;非cs出身的我对二进制不够敏感，所以一直很头疼位运算的问题。上次看了M67的一篇 &lt;a href=&quot;http://www.matrix67.com/blog/archives/263&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文章&lt;/a&gt;，我把里面提到
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://brightsunp.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>2018年度总结</title>
    <link href="https://brightsunp.github.io/2019/01/03/2018%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    <id>https://brightsunp.github.io/2019/01/03/2018年度总结/</id>
    <published>2019-01-03T07:04:51.000Z</published>
    <updated>2020-08-03T06:08:04.022Z</updated>
    
    <content type="html"><![CDATA[<p>2018-2019之交，我感慨于时光荏苒，过去的一年里，我从换工作的挫败、低谷到逐渐稳定，此刻的心境与去年相比有了本质的不同。尽管在技术上有了一定的进步，但我不得不面对一个可怕的事实：过去的自己实在不够努力，导致与同龄人的差距太大，即使奋起直追，仍须要长久的时日。</p><h4 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h4><p>2018上半年，我之所以停滞不前，是有理可循的，最致命的原因是<strong>坏习惯</strong>和<strong>缺乏思考</strong>。刚踏入社会的一年内，我保留着学生时代的坏习惯：一有空闲就逛知乎、虎扑、心声社区。坏习惯就像“慢性毒药”，纯属浪费时间，不思进取。玩就玩吧，凡事都缺乏思考，而每件事都有其可取之处：知乎上除了无聊的问题，还有相当多的学习建议，再不济也能学到如何表达自己的想法；心声上除了对薪水、制度的吐槽，还有工作总结、成长经历等；打游戏除了一味的沉迷，还可以思考游戏类型、用户体验、设计和开发难度等。上面这些习惯倘若能加以思考，我或多好少都能取其精华，形成积极的生活方式和职场思维；作为一个IT人，只有保持学习和不断上进，才不至于被行业的寒冬吞噬。</p><p>另一点原因，是对<strong>自身的定位不清晰</strong>。我的长处是擅于总结，从小成绩好，就是因为常常做笔记、写错题本，从考试的成败中吸取经验。短处就很多了，从最大的说起，一是不自律，大学GPA不高，沉迷于各种游戏，三国杀、FIFA、LOL等；二是不自知，有一颗中二的心，还自视甚高，以为稍作准备就能通过其他公司的面试，然而一个人的价值在于他的不可替代性；三是目标不明确，小地方出来的我目光短浅，主见性不强，对于网上的观点人云亦云，拎不清自己想要的是什么。直到如今终于弄清楚了，值得幸运的是我从未在关键的时间节点犯错：武大毕业，考研进了中科院，顺利拿到hw的实习offer；遗憾的是不经校招，导致对IT普遍看重的算法能力缺乏锻炼。我总算是将短处各个击破，而破解的关键在于勤思考、常练习、多总结。脑子不用就容易生锈、容易懒散，用多了又会疲惫不堪、消磨意志，科学运用、踏实积累才是长远之道。</p><h4 id="转变"><a href="#转变" class="headerlink" title="转变"></a>转变</h4><p>2018下半年起，我对<strong>职业选择</strong>有了更深的认识。从hw离职的时候，我把自身积累浅、进步慢的原因单方面归于公司，这是多么愚蠢的想法。真正优秀的人到哪里都不会差：tom把长期坚持健身的自律，发挥到日常工作中，呈现出高效的工作效率；永富哥凭借多年的经验，遇到问题总能找到合适的解决办法。人只要学习能力强，自然能胜任不同层次的工作。我以为到了小公司，项目压力会逼得我进步，各方面都能迅速成长。殊不知技术的提升全靠自觉，公司提供的只是平台和伙伴而已。大公司的业务平台大，对人才的吸引力强，分工明确，团队管理和流程则稍显冗杂；小公司的数据平台小，员工水平没那么高，更注重工程化和落地场景，管理扁平，单兵作战效率高。你要说哪个对自己的提升更大？答案见仁见智。我在做好本职工作的同时，多花心思在自身的迭代上，慢慢地实现自我提升。从我的个人经历来讲，知名大厂还是更值得去。但不管人在哪里，自己心目中对标的，都应该是同行业的“世界战场”，而不仅仅局限在公司层面。凡事做到了行业领先，也便成就了自身的核心竞争力。</p><p>在认清自己的基础上，我将<strong>算法工程师</strong>作为未来的职业方向。原因有哪些呢？一是发挥自己的长处，工具+基础+项目经历，我最擅长的语言Python，非常适合数据挖掘、科学计算、机器学习等；各种英文资料和博客，我以往再懒散，也始终保持着英语这项特长；目前的工作领域是NLP和CV，我积累了不少工程化的项目经验。二是自身的兴趣，解决算法题的过程给我带来巨大的愉悦；对海量数据进行处理、分析、可视化，特征工程、预测和回归，这本身就是一件看得到结果，即时回报的事；我的硕士课题是基于决策树的图像分类，在CV领域也有一定的专业背景。三是未来的主流趋势，近两年国内的很多高校开设了AI学院，各大公司对AI人才的需求热度，社会各界讨论的热点也是AI技术；互联网的前几十年都处于工程发展期，沉淀下来的海量数据蕴藏着金矿，而算法、深度学习正是挖掘这些金矿的利器。即使很难成为AI理论专家，我也要多锻炼这方面的思维，努力成长为机器学习实战高手。</p><h4 id="进步"><a href="#进步" class="headerlink" title="进步"></a>进步</h4><p>有了正确的目标就有了持久的动力，科学的学习计划不可或缺，这正是2018让我真正欣喜的点：<strong>好习惯的养成</strong>。这是对整个职业生涯最有帮助的事，没有什么比它更重要了。经历挫败后承受着巨大的压力，我终于变得自律，找准了自身的短板，践行正确的学习途径，也让简历有不少的加分。我每天都在编程训练、深度思考，刷题的过程痛并快乐着；看机器学习的书和博客，从零手写常用的模型，以加深对算法原理的理解；每周把阶段性的小结更新到博客，把调试好的代码提交到github；经常逛开源社区，查阅最新的学习资料。有所欠缺、美中不足的是表达能力，现在的工作渐渐少了谈吐，我只能把想法都寄托在博客文字和代码逻辑中，这个也不知是好是坏。</p><p>2018，我25岁，正值一个人脑力和体力的巅峰；年轻气盛，挫败催人成长，让我对自己有所担当。这一年，我有了很多积极转变：生活日志变少，技术博客变多；晚上充实做题，早晨自然睡醒；与朋友聚会叙旧，关心家人和长辈。我在做人做事上都变得成熟，进步巨大，很多东西从无到有，从少到多；但这不过是个开端，未来依旧道阻且长。</p><p>2019，我怀揣着满满的自信，朝着正确、明确的路标坚定前行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2018-2019之交，我感慨于时光荏苒，过去的一年里，我从换工作的挫败、低谷到逐渐稳定，此刻的心境与去年相比有了本质的不同。尽管在技术上有了一定的进步，但我不得不面对一个可怕的事实：过去的自己实在不够努力，导致与同龄人的差距太大，即使奋起直追，仍须要长久的时日。&lt;/p&gt;

      
    
    </summary>
    
      <category term="随笔" scheme="https://brightsunp.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>Daily-Coding-Problem-31-40</title>
    <link href="https://brightsunp.github.io/2019/01/03/Daily-Coding-Problem-31-40/"/>
    <id>https://brightsunp.github.io/2019/01/03/Daily-Coding-Problem-31-40/</id>
    <published>2019-01-03T02:46:47.000Z</published>
    <updated>2020-08-03T03:47:49.922Z</updated>
    
    <content type="html"><![CDATA[<p>本文的完整代码见 <a href="https://github.com/brightsunp/learn/blob/master/leetcode/DCP_31-40.py" target="_blank" rel="noopener">这里</a>。</p><h2 id="1-Microsoft-流式数组的中位数"><a href="#1-Microsoft-流式数组的中位数" class="headerlink" title="1 Microsoft-流式数组的中位数"></a>1 Microsoft-流式数组的中位数</h2><p><a href="https://leetcode.com/problems/find-median-from-data-stream/" target="_blank" rel="noopener">295. Find Median from Data Stream</a></p><blockquote><p>Compute the running median of a sequence of numbers. That is, given a stream of numbers, print out the median of the list so far on each new element.<br>Recall that the median of an even-numbered list is the average of the two middle numbers.<br>[2, 1, 5, 7, 2, 0, 5] =&gt; [2, 1.5, 2, 3.5, 2, 2, 2]</p></blockquote><p>题目要实现一种数据结构，包含 <code>addNum</code> 和 <code>findMedian</code> 两个方法，属于常见的“增、查”功能。<br>维护一个<strong>最大堆</strong>和一个<strong>最小堆</strong>，在增加元素的过程中，保持两个堆的长度相差1；每次往一个堆增加元素，首先要进、出另一个堆。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> heappush, heappushpop</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1_1</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># max_heap: reverse min_heap</span></span><br><span class="line">        self.small = []</span><br><span class="line">        <span class="comment"># min_heap</span></span><br><span class="line">        self.large = []</span><br><span class="line">        self.even = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addNum</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="comment"># keep len(self.small) &gt;= len(self.large)</span></span><br><span class="line">        <span class="keyword">if</span> len(self.small) == len(self.large):</span><br><span class="line">            heappush(self.small, -heappushpop(self.large, num))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            heappush(self.large, -heappushpop(self.small, -num))</span><br><span class="line">        self.even = <span class="keyword">not</span> self.even</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedian</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.even:</span><br><span class="line">            <span class="keyword">return</span> (self.large[<span class="number">0</span>] - self.small[<span class="number">0</span>]) / <span class="number">2.0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -self.small[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>求动态数组的中位数，类似题目有 <a href="https://leetcode.com/problems/sliding-window-median/" target="_blank" rel="noopener">480. Sliding Window Median</a>。<br>思路也很清晰：维护一个有序的数组，该过程包含了“增、查、删”功能，采用<strong>二分查找</strong>来优化时间复杂度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bisect <span class="keyword">import</span> bisect_left, insort</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1_2</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">medianSlidingWindow</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        win, res = nums[:k], []</span><br><span class="line">        win.sort()</span><br><span class="line">        odd = k % <span class="number">2</span></span><br><span class="line">        res.append(win[(k<span class="number">-1</span>)/<span class="number">2</span>]*<span class="number">1.0</span> <span class="keyword">if</span> odd <span class="keyword">else</span> (win[k/<span class="number">2</span><span class="number">-1</span>]+win[k/<span class="number">2</span>])/<span class="number">2.0</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k, len(nums)):</span><br><span class="line">            <span class="comment"># bisect_left returns exactly the index</span></span><br><span class="line">            <span class="keyword">del</span>(win[bisect_left(win, nums[i-k])])</span><br><span class="line">            insort(win, nums[i])</span><br><span class="line">            res.append(win[(k<span class="number">-1</span>)/<span class="number">2</span>]*<span class="number">1.0</span> <span class="keyword">if</span> odd <span class="keyword">else</span> (win[k/<span class="number">2</span><span class="number">-1</span>]+win[k/<span class="number">2</span>])/<span class="number">2.0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="2-Google-数组的颜色排序"><a href="#2-Google-数组的颜色排序" class="headerlink" title="2 Google-数组的颜色排序"></a>2 Google-数组的颜色排序</h2><p><a href="https://leetcode.com/problems/sort-colors/" target="_blank" rel="noopener">75. Sort Colors</a></p><blockquote><p>Given an array of strictly the characters ‘R’, ‘G’, and ‘B’, segregate the values of the array so that all the Rs come first, the Gs come second, and the Bs come last. You can only swap elements of the array.<br>Do this in linear time and in-place.<br>[‘G’, ‘B’, ‘R’, ‘R’, ‘B’, ‘R’, ‘G’] =&gt; [‘R’, ‘R’, ‘R’, ‘G’, ‘G’, ‘B’, ‘B’].</p></blockquote><p>题目给定了排序规则，直观思路是 <code>count and say</code>，借助 <code>OrderedDict</code> 实现，但是产生了额外的空间；<br>优化的逻辑很巧妙，多看discuss区，在有限的生命中实现尽可能多的愿望。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution2</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="comment"># mind blowing from counting-sort</span></span><br><span class="line">        n0 = n1 = n2 = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">                n2, n1, n0 = n2+<span class="number">1</span>, n1+<span class="number">1</span>, n0+<span class="number">1</span></span><br><span class="line">                nums[n2] = <span class="number">2</span></span><br><span class="line">                nums[n1] = <span class="number">1</span></span><br><span class="line">                nums[n0] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">elif</span> num == <span class="number">1</span>:</span><br><span class="line">                n2, n1 = n2+<span class="number">1</span>, n1+<span class="number">1</span></span><br><span class="line">                nums[n2] = <span class="number">2</span></span><br><span class="line">                nums[n1] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                n2 += <span class="number">1</span></span><br><span class="line">                nums[n2] = <span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="3-Dropbox-康威生命游戏"><a href="#3-Dropbox-康威生命游戏" class="headerlink" title="3 Dropbox-康威生命游戏"></a>3 Dropbox-康威生命游戏</h2><p><a href="https://leetcode.com/problems/game-of-life/" target="_blank" rel="noopener">289. Game of Life</a></p><p>具体的游戏规则见 <a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life" target="_blank" rel="noopener">这里</a>，元胞自动机（Cellular Automaton/Automata）用来模仿人类或细胞的生存环境：</p><ol><li>“人口过少”：任何活细胞如果活邻居少于2个，则“孤单”而死。</li><li>“正常”：任何活细胞如果活邻居为2个或3个，则继续活。</li><li>“人口过多”：任何活细胞如果活邻居大于3个，则“资源短缺”而死。</li><li>“繁殖”：任何死细胞如果活邻居正好是3个，则活过来。</li></ol><p>这道题要模拟“细胞棋盘”一次迭代后的变化，根据规则逐个判断即可，难点在于判断的过程中，每个点的“8-邻域”发生着动态变化。</p><ul><li>直观思路是用<strong>中间变量</strong>来记录变化后的状态，然后在判断时，将中间状态转化为 <code>live_neighbors</code> 的计数依据，最后再还原。</li><li>优化则基于上面的想法，采用<strong>位运算</strong>来说明，显得特别清晰；我越来越发现，位运算能广泛用于 <code>state</code> 相关的问题。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution3</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gameOfLife</span><span class="params">(self, board)</span>:</span></span><br><span class="line">        <span class="comment"># use 2-bits to store independent states: [cur, pre]</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> board <span class="keyword">or</span> len(board) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        m, n = len(board), len(board[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                lives = self.live_neighbors(board, i, j, m, n)</span><br><span class="line">                <span class="comment"># 01 -&gt; 11</span></span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="number">1</span> <span class="keyword">and</span> lives <span class="keyword">in</span> [<span class="number">2</span>, <span class="number">3</span>]:</span><br><span class="line">                    board[i][j] = <span class="number">3</span></span><br><span class="line">                <span class="comment"># 00 -&gt; 10</span></span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="number">0</span> <span class="keyword">and</span> lives == <span class="number">3</span>:</span><br><span class="line">                    board[i][j] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="comment"># update cur state</span></span><br><span class="line">                board[i][j] &gt;&gt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">live_neighbors</span><span class="params">(self, board, i, j, m, n)</span>:</span></span><br><span class="line">        lives = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(max(<span class="number">0</span>, i - <span class="number">1</span>), min(m, i + <span class="number">2</span>)):</span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> range(max(<span class="number">0</span>, j - <span class="number">1</span>), min(n, j + <span class="number">2</span>)):</span><br><span class="line">                lives += board[x][y] &amp; <span class="number">1</span></span><br><span class="line">        lives -= board[i][j] &amp; <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> lives</span><br></pre></td></tr></table></figure><h2 id="4-Google-数组中只出现一次的数"><a href="#4-Google-数组中只出现一次的数" class="headerlink" title="4 Google-数组中只出现一次的数"></a>4 Google-数组中只出现一次的数</h2><p><a href="https://leetcode.com/problems/single-number-ii/" target="_blank" rel="noopener">137. Single Number II</a></p><blockquote><p>Given an array of integers where every integer occurs three times except for one integer, which only occurs once, find and return the non-duplicated integer. Do this in O(N) time and O(1) space.<br>[6, 1, 3, 3, 3, 6, 6] =&gt; 1, [13, 19, 13, 13] =&gt; 19.</p></blockquote><p>这道题是 <a href="https://leetcode.com/problems/single-number/" target="_blank" rel="noopener">136. Single Number</a> 的延伸：</p><ul><li>通用的思路是采用<strong>哈希表</strong>，记录所有元素出现的次数，从而找到只出现一次的数，但是产生了额外的空间；</li><li>优化则采用<strong>位运算</strong>来实现，通过异或 <code>^</code> 来消除出现2次的数。 </li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution4_1</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber1</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            d[num] = d.get(num, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> d.items():</span><br><span class="line">            <span class="keyword">if</span> v == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> k</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber2</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="comment"># use 1-bit to store num</span></span><br><span class="line">        <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x, y: x ^ y, nums)</span><br></pre></td></tr></table></figure><p>再回到本题，通用的思路不再赘述，如何通过位运算来消除出现3次的数呢？这相当于设计一个运算符，来实现同样的功能，有一门课程 <em>digital logic</em> 专门讲到了这点。<br>借助一个中间变量，存储之前累积的计算结果，通过不断的交替来求解；代码注释中的 <code>True/False</code>，指的是连续进入相同元素的特殊情形。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution4_2</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="comment"># use 2-bits to store nums: [a, b]</span></span><br><span class="line">        a = b = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># a stores num, b stores True/False</span></span><br><span class="line">            a = a ^ num &amp; ~b</span><br><span class="line">            <span class="comment"># b stores num, a stores True/False</span></span><br><span class="line">            b = b ^ num &amp; ~a</span><br><span class="line">        <span class="comment"># b == 0 in this problem</span></span><br><span class="line">        <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure><p>另一道相关的题是 <a href="https://leetcode.com/problems/single-number-iii/" target="_blank" rel="noopener">260. Single Number III</a>，采用的位运算性质是 <code>ans &amp; -ans</code> 得到 <code>ans</code> 中最后一个 <code>1</code> 出现的位置，通过该位置即可把数组中“与众不同”的两个数分离出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution4_3</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="comment"># two-pass: a != b, so (a ^ b) has at least one '1'</span></span><br><span class="line">        ans = reduce(<span class="keyword">lambda</span> x, y: x ^ y, nums)</span><br><span class="line">        <span class="comment"># get last '1' set bit</span></span><br><span class="line">        ans &amp;= -ans</span><br><span class="line">        res = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num &amp; ans == <span class="number">0</span>:</span><br><span class="line">                res[<span class="number">0</span>] ^= num</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res[<span class="number">1</span>] ^= num</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文的完整代码见 &lt;a href=&quot;https://github.com/brightsunp/learn/blob/master/leetcode/DCP_31-40.py&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;h2 i
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://brightsunp.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>理解Manacher算法</title>
    <link href="https://brightsunp.github.io/2018/12/28/%E7%90%86%E8%A7%A3Manacher%E7%AE%97%E6%B3%95/"/>
    <id>https://brightsunp.github.io/2018/12/28/理解Manacher算法/</id>
    <published>2018-12-28T05:16:25.000Z</published>
    <updated>2020-08-03T03:47:49.910Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Manacher算法</strong>专门用来解决 <a href="https://leetcode.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">Longest Palindromic Substring</a> 问题，将时间复杂度从O(n^2)减小到O(n)，但表述和理解起来都比较麻烦。题目描述如下：</p><blockquote><p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.<br>“babad” =&gt; “bab”<br>Note: “aba” is also a valid answer.</p></blockquote><p>我看了不少资料，很多人都直接拿结论来推过程，不利于独立思维的锻炼；<a href="https://www.geeksforgeeks.org/manachers-algorithm-linear-time-longest-palindromic-substring-part-1/" target="_blank" rel="noopener">GeeksforGeeks</a> 分了4篇文章来讲解该算法的原理，很值得详细阅读。</p><h2 id="1-O-n-2-解法"><a href="#1-O-n-2-解法" class="headerlink" title="1 O(n^2)解法"></a>1 O(n^2)解法</h2><p>思路很清晰，将每个位置都作为回文串的中心向外延伸，分奇偶两种情形，遍历找到最长的回文子字符串。<br>这应该是O(n^2)解法里最简洁的版本了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># O(n^2) time and O(1) space</span></span><br><span class="line">        max_len = start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            cur_len = max(self.extend(s, i, i), self.extend(s, i - <span class="number">1</span>, i))</span><br><span class="line">            <span class="keyword">if</span> cur_len &gt; max_len:</span><br><span class="line">                max_len, start = cur_len, i - cur_len//<span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> s[start:start+max_len]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">extend</span><span class="params">(self, s, left, right)</span>:</span></span><br><span class="line">        <span class="comment"># calculate length of palindrome</span></span><br><span class="line">        <span class="keyword">while</span> left &gt;= <span class="number">0</span> <span class="keyword">and</span> right &lt; len(s) <span class="keyword">and</span> s[left] == s[right]:</span><br><span class="line">            left, right = left - <span class="number">1</span>, right + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> right - left - <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="2-O-n-解法"><a href="#2-O-n-解法" class="headerlink" title="2 O(n)解法"></a>2 O(n)解法</h2><p>Manacher算法的第一步是填充原字符串，将 <code>abba</code> 转化为 <code>#a#b#b#a#</code> 的形式，这就不用再考虑回文串的奇偶长度；正因为所有回文串的长度都变为了奇数，在第二步可以很方便地利用对称性，计算每个位置的<strong>回文串对折长度</strong>，从而减少冗余计算，这是保证线性时间复杂度的关键。</p><p><img src="/img/Manacher’s-Algorithm.jpg" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># O(n) time and O(n) space</span></span><br><span class="line">        t = <span class="string">'#'</span>.join(<span class="string">'^&#123;&#125;$'</span>.format(s))</span><br><span class="line">        res = [<span class="number">0</span>] * len(t)</span><br><span class="line">        center = right = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(t) - <span class="number">1</span>):</span><br><span class="line">            mirror = <span class="number">2</span> * center - i</span><br><span class="line">            <span class="comment"># using symmetry</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; right:</span><br><span class="line">                res[i] = min(right - i, res[mirror])</span><br><span class="line">            <span class="keyword">while</span> t[i + (<span class="number">1</span> + res[i])] == t[i - (<span class="number">1</span> + res[i])]:</span><br><span class="line">                res[i] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i + res[i] &gt; right:</span><br><span class="line">                center, right = i, i + res[i]</span><br><span class="line">        max_len, center = max((value, i) <span class="keyword">for</span> i, value <span class="keyword">in</span> enumerate(res))</span><br><span class="line">        <span class="keyword">return</span> s[(center - <span class="number">1</span> - max_len) / <span class="number">2</span>:(center - <span class="number">1</span> + max_len) / <span class="number">2</span>]</span><br></pre></td></tr></table></figure><h2 id="3-最短回文字符串"><a href="#3-最短回文字符串" class="headerlink" title="3 最短回文字符串"></a>3 最短回文字符串</h2><p><a href="https://leetcode.com/problems/shortest-palindrome/" target="_blank" rel="noopener">214. Shortest Palindrome</a></p><blockquote><p>Given a string s, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation.<br>“aacecaaa” =&gt; “aaacecaaa”</p></blockquote><p>同样是回文串问题，但Manacher算法在这里就用不上了，其不具备普适性。<br>第一种解法是找到<strong>最长的回文串前缀</strong>。正由于“前缀”这个限定条件，最右的索引可以从 <code>mid</code> 开始，如果能延伸到起点则返回问题的解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortestPalindrome1</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># O(n^2) time: TLE, 119 / 120 test cases passed.</span></span><br><span class="line">        <span class="comment"># find longest palindrome prefix (center &lt;= mid)</span></span><br><span class="line">        mid = len(s) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(mid, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            res = self.extend(s, i, i) <span class="keyword">or</span> self.extend(s, i - <span class="number">1</span>, i)</span><br><span class="line">            <span class="keyword">if</span> res:</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">extend</span><span class="params">(self, s, left, right)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> left &gt;= <span class="number">0</span> <span class="keyword">and</span> right &lt; len(s) <span class="keyword">and</span> s[left] == s[right]:</span><br><span class="line">            left, right = left - <span class="number">1</span>, right + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> left &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="comment"># left reaches front of s</span></span><br><span class="line">        <span class="keyword">return</span> s[right:][::<span class="number">-1</span>] + s</span><br></pre></td></tr></table></figure><p>第二种解法比较巧妙，将逆序的字符串 <code>t</code> 和原字符串 <code>s</code>拼接，自然就形成一个回文字符串；然后找到 <code>t</code> 的后缀和 <code>s</code> 的前缀公共的最大长度，将重叠部分消除即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortestPalindrome2</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># startswith implemented in C: avoid slow compare loop in Python</span></span><br><span class="line">        r = s[::<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s) + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> s.startswith(r[i:]):</span><br><span class="line">                <span class="keyword">return</span> r[:i] + s</span><br></pre></td></tr></table></figure><p>上面的代码没有考虑 <code>startswith</code> 的具体实现，这其实是字符串匹配的问题，与之相关的是 <a href="https://zh.wikipedia.org/wiki/%E5%85%8B%E5%8A%AA%E6%96%AF-%E8%8E%AB%E9%87%8C%E6%96%AF-%E6%99%AE%E6%8B%89%E7%89%B9%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">KMP算法</a>，特别是最大前缀后缀对应的next数组，这里就不具体展开了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Manacher算法&lt;/strong&gt;专门用来解决 &lt;a href=&quot;https://leetcode.com/problems/longest-palindromic-substring/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;L
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://brightsunp.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Daily-Coding-Problem-21-30</title>
    <link href="https://brightsunp.github.io/2018/12/24/Daily-Coding-Problem-21-30/"/>
    <id>https://brightsunp.github.io/2018/12/24/Daily-Coding-Problem-21-30/</id>
    <published>2018-12-24T02:13:18.000Z</published>
    <updated>2020-08-03T03:47:49.903Z</updated>
    
    <content type="html"><![CDATA[<p>这次收录了6个有启发的问题，其中有几道 <code>DP &amp; Backtracking</code>；算法之所以成为经典，在于它们的普适性，也在于细节实现上的多变性，实现过程中饶有趣味。本文的完整代码见 <a href="https://github.com/brightsunp/learn/blob/master/leetcode/DCP_21-30.py" target="_blank" rel="noopener">这里</a>。</p><h2 id="1-Snapchat-最少需要的房间数"><a href="#1-Snapchat-最少需要的房间数" class="headerlink" title="1 Snapchat-最少需要的房间数"></a>1 Snapchat-最少需要的房间数</h2><blockquote><p>Given an array of time intervals (start, end) for classroom lectures (possibly overlapping), find the minimum number of rooms required.<br>For example, given [(30, 75), (0, 50), (60, 150)], you should return 2.</p></blockquote><p>题目求的是最少需要的房间数，等价于求同一时段最多有几门课程，类似的有 <a href="https://www.geeksforgeeks.org/minimum-number-platforms-required-railwaybus-station/" target="_blank" rel="noopener">公交站台问题</a>。</p><ul><li>最暴力的解法是遍历数组，对每个interval，查找与之交叠的interval个数，取其最大值，时间复杂度<strong>O(n^2)</strong>；</li><li>优化的策略是考虑每个时刻的课程数，动态更新它们的最大值，那么需要对interval排序，外加一次merge遍历，时间复杂度<strong>O(nlogn)</strong>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRoom</span><span class="params">(self, intervals)</span>:</span></span><br><span class="line">        <span class="comment"># find maximum number of lectures at a time</span></span><br><span class="line">        arr, dep = tuple(zip(*intervals))</span><br><span class="line">        arr, dep = sorted(arr), sorted(dep)</span><br><span class="line">        res = cur = <span class="number">0</span></span><br><span class="line">        i = j = <span class="number">0</span></span><br><span class="line">        <span class="comment"># merge process of mergeSort</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(arr) <span class="keyword">and</span> j &lt; len(dep):</span><br><span class="line">            <span class="keyword">if</span> arr[i] &lt; dep[j]:</span><br><span class="line">                cur, i = cur+<span class="number">1</span>, i+<span class="number">1</span></span><br><span class="line">                res = max(res, cur)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur, j = cur<span class="number">-1</span>, j+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="2-Microsoft-字符串按给定的词典分词"><a href="#2-Microsoft-字符串按给定的词典分词" class="headerlink" title="2 Microsoft-字符串按给定的词典分词"></a>2 Microsoft-字符串按给定的词典分词</h2><p><a href="https://leetcode.com/problems/word-break-ii/" target="_blank" rel="noopener">140. Word Break II</a></p><blockquote><p>Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences.<br>Input:<br>s = “pineapplepenapple”, wordDict = [“apple”, “pen”, “applepen”, “pine”, “pineapple”]<br>Output:<br>[“pine apple pen apple”, “pineapple pen apple”, “pine applepen apple”]</p></blockquote><p>这道题求的是所有解，自然想到用Backtracking，但直截了当的写法会TLE，这就体现出难度了。<br>优化的策略是“<strong>记忆式回溯</strong>”，因为回溯的本质还是递归，有很多重复计算；“记忆”指的是记住子字符串s的所有分词可能，下次遇到该字符串直接查询，比如 <code>&#39;applepen&#39; =&gt; [&#39;apple pen&#39;, &#39;applepen&#39;]</code>，参考自 <a href="https://leetcode.com/problems/word-break-ii/discuss/44167/My-concise-JAVA-solution-based-on-memorized-DFS" target="_blank" rel="noopener">这里</a>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span><span class="params">(self, s, wordDict)</span>:</span></span><br><span class="line">        <span class="comment"># find all solutions</span></span><br><span class="line">        <span class="keyword">return</span> self.dfs(s, wordDict, &#123;&#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, s, wordDict, memory)</span>:</span></span><br><span class="line">        <span class="comment"># dfs returns all break results of s.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> [<span class="string">''</span>]</span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">in</span> memory:</span><br><span class="line">            <span class="keyword">return</span> memory[s]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> wordDict:</span><br><span class="line">            <span class="keyword">if</span> s.startswith(word):</span><br><span class="line">                results = self.dfs(s[len(word):], wordDict, memory)</span><br><span class="line">                <span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">                    res.append(word + (<span class="string">' '</span> + result <span class="keyword">if</span> result <span class="keyword">else</span> <span class="string">''</span>))</span><br><span class="line">        memory[s] = res</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="3-Google-二叉树的加锁-解锁"><a href="#3-Google-二叉树的加锁-解锁" class="headerlink" title="3 Google-二叉树的加锁/解锁"></a>3 Google-二叉树的加锁/解锁</h2><blockquote><p>Implement locking in a binary tree. A binary tree node can be locked or unlocked only if all of its descendants or ancestors are not locked.<br>Design a binary tree node class with the following methods:</p><ul><li><code>is_locked</code>, which returns whether the node is locked</li><li><code>lock</code>, which attempts to lock the node. If it cannot be locked, then it should return false. Otherwise, it should lock it and return true.</li><li><code>unlock</code>, which unlocks the node. If it cannot be unlocked, then it should return false. Otherwise, it should unlock it and return true.<br>Each method should run in O(h), where h is the height of the tree.</li></ul></blockquote><p>二叉树不愧为面试必考题，因为O(logn)的时间复杂度实在是美妙。</p><ul><li>本题中，给二叉树的每个节点增加 <code>is_locked</code> 属性，那么 <code>lock</code> 和 <code>unlock</code> 都要花费<strong>O(m+h)</strong>的时间，其中m为当前节点子树的节点总个数（对于后代节点的遍历花费m，对于祖先节点的遍历花费h）。</li><li>优化的策略是给每个节点再加一个属性，用来记录当前节点子树的 <code>locked</code> 节点总个数；每次调用 <code>lock/unlock</code> 时，需要更新当前节点所有祖先节点的该属性值，这个操作只花费O(h)，所以两个方法的时间复杂度都减小为<strong>O(h)</strong>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockingBinaryTreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val, left=None, right=None, parent=None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line">        self.parent = parent</span><br><span class="line">        </span><br><span class="line">        self._is_locked = <span class="keyword">False</span></span><br><span class="line">        self.locked_descendants_count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_can_lock_or_unlock</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.locked_descendants_count &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        cur = self.parent</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur._is_locked:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            cur = cur.parent</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_locked</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._is_locked</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lock</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self._can_lock_or_unlock():</span><br><span class="line">            <span class="comment"># increment count in all ancestors</span></span><br><span class="line">            self._is_locked = <span class="keyword">True</span></span><br><span class="line">            cur = self.parent</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                cur.locked_descendants_count += <span class="number">1</span></span><br><span class="line">                cur = cur.parent</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">unlock</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self._can_lock_or_unlock():</span><br><span class="line">            <span class="comment"># decrement count in all ancestors</span></span><br><span class="line">            self._is_locked = <span class="keyword">False</span></span><br><span class="line">            cur = self.parent</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                cur.locked_descendants_count -= <span class="number">1</span></span><br><span class="line">                cur = cur.parent</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h2 id="4-Facebook-字符串的正则匹配"><a href="#4-Facebook-字符串的正则匹配" class="headerlink" title="4 Facebook-字符串的正则匹配"></a>4 Facebook-字符串的正则匹配</h2><p><a href="https://leetcode.com/problems/regular-expression-matching/" target="_blank" rel="noopener">10. Regular Expression Matching</a></p><blockquote><p>Implement regular expression matching with the following special characters:</p><ul><li><code>.</code> (period) which matches any single character</li><li><code>*</code> (asterisk) which matches zero or more of the preceding element<br>That is, implement a function that takes in a string and a valid regular expression and returns whether or not the string matches the regular expression.</li></ul></blockquote><p>典型的DP问题，这道题的难点在于 <code>*</code> 匹配很灵活，细分的话分为以下两种情形：</p><ul><li>它前面的字符出现零次，则有 <code>dp[i][j] = dp[i][j-2]</code>；</li><li>它前面的字符出现多次，需要考虑 <code>.</code> 的匹配。</li></ul><p>然后，用 <code>or</code> 来合并两种情形的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s, p)</span>:</span></span><br><span class="line">        <span class="comment"># dp[i][j]: if s[:i] matches p[:j]</span></span><br><span class="line">        m, n = len(s), len(p)</span><br><span class="line">        dp = [[<span class="keyword">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(m+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j &gt; <span class="number">1</span> <span class="keyword">and</span> p[j<span class="number">-1</span>] == <span class="string">'*'</span>:</span><br><span class="line">                    <span class="comment"># preceding pattern repeats 0 or more times</span></span><br><span class="line">                    dp[i][j] = dp[i][j<span class="number">-2</span>]</span><br><span class="line">                    <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> (p[j<span class="number">-2</span>] == <span class="string">'.'</span> <span class="keyword">or</span> p[j<span class="number">-2</span>] == s[i<span class="number">-1</span>]):</span><br><span class="line">                        dp[i][j] = dp[i][j] <span class="keyword">or</span> dp[i<span class="number">-1</span>][j]</span><br><span class="line">                <span class="keyword">elif</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> (p[j<span class="number">-1</span>] == <span class="string">'.'</span> <span class="keyword">or</span> p[j<span class="number">-1</span>] == s[i<span class="number">-1</span>]):</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure><h2 id="5-Amazon-字符串的计数编码-解码"><a href="#5-Amazon-字符串的计数编码-解码" class="headerlink" title="5 Amazon-字符串的计数编码/解码"></a>5 Amazon-字符串的计数编码/解码</h2><blockquote><p>Run-length encoding is a fast and simple method of encoding strings. The basic idea is to represent repeated successive characters as a single count and character. For example, the string “AAAABBBCCDAA” would be encoded as “4A3B2C1D2A”.</p></blockquote><p>很简单的一道题，实现过程中用 <code>list</code> 来减小字符串拼接的开销。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">encode</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        res = []</span><br><span class="line">        count, pre = <span class="number">0</span>, <span class="string">'#'</span></span><br><span class="line">        <span class="keyword">for</span> i, char <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            <span class="keyword">if</span> char == pre:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># find switch pos</span></span><br><span class="line">                <span class="keyword">if</span> pre != <span class="string">'#'</span>:</span><br><span class="line">                    res.append(str(count)+pre)</span><br><span class="line">                count, pre = <span class="number">1</span>, char</span><br><span class="line">        res.append(str(count)+pre)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(res)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decode</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(s), <span class="number">2</span>):</span><br><span class="line">            cur = s[i:i+<span class="number">2</span>]</span><br><span class="line">            count, char = int(cur[<span class="number">0</span>]), cur[<span class="number">1</span>]</span><br><span class="line">            res.append(char * count)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(res)</span><br></pre></td></tr></table></figure><h2 id="6-Facebook-数组中的隔板收集雨水"><a href="#6-Facebook-数组中的隔板收集雨水" class="headerlink" title="6 Facebook-数组中的隔板收集雨水"></a>6 Facebook-数组中的隔板收集雨水</h2><p><a href="https://leetcode.com/problems/trapping-rain-water" target="_blank" rel="noopener">42. Trapping Rain Water</a></p><blockquote><p>You are given an array of non-negative integers that represents a two-dimensional elevation map where each element is unit-width wall and the integer is the height. Suppose it will rain and all spots between two walls get filled up.<br>Compute how many units of water remain trapped on the map in O(N) time and O(1) space.</p></blockquote><blockquote><p>Given the input [3, 0, 1, 3, 0, 5], we can hold 3 units in the first index, 2 in the second, and 3 in the fourth index (we cannot hold 5 since it would run off to the left), so we can trap 8 units of water.</p></blockquote><p>上面这段描述已经提示了解题思路：</p><blockquote><p>我们考虑每一块隔板上方的“储水量”，这是由它左边和右边最高的两块隔板决定的。</p></blockquote><p>理解这个逻辑是最关键的一步。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span><span class="params">(self, height)</span>:</span></span><br><span class="line">        <span class="comment"># cur_holder = max(min(left_max_height, right_max_height)-cur_height, 0)</span></span><br><span class="line">        <span class="comment"># two pointers: just avoid those two-step comparision</span></span><br><span class="line">        res, left_max, right_max, lo, hi = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, len(height) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> lo &lt;= hi:</span><br><span class="line">            <span class="keyword">if</span> height[lo] &lt; height[hi]:</span><br><span class="line">                <span class="keyword">if</span> height[lo] &gt; left_max:</span><br><span class="line">                    left_max = height[lo]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res += left_max - height[lo]</span><br><span class="line">                lo += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> height[hi] &gt; right_max:</span><br><span class="line">                    right_max = height[hi]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res += right_max - height[hi]</span><br><span class="line">                hi -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这次收录了6个有启发的问题，其中有几道 &lt;code&gt;DP &amp;amp; Backtracking&lt;/code&gt;；算法之所以成为经典，在于它们的普适性，也在于细节实现上的多变性，实现过程中饶有趣味。本文的完整代码见 &lt;a href=&quot;https://github.com/bri
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://brightsunp.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>N-Queens和Sudoku问题</title>
    <link href="https://brightsunp.github.io/2018/12/21/N-Queens%E5%92%8CSudoku%E9%97%AE%E9%A2%98/"/>
    <id>https://brightsunp.github.io/2018/12/21/N-Queens和Sudoku问题/</id>
    <published>2018-12-21T02:56:43.000Z</published>
    <updated>2020-08-03T03:47:49.896Z</updated>
    
    <content type="html"><![CDATA[<p>N皇后、数独是经典的数学问题，用编程的方式来解决，关键在于如何用数学语言来描述问题，从而选择对应的算法：<br>前者求的是所有符合规则的解；后者求的是唯一解，即判断有没有解。<br>这两类问题都是Backtracking的典型应用，我前面做过 <a href="https://brightsunp.github.io/2018/11/25/%E5%87%A0%E4%B8%AA%E5%85%B8%E5%9E%8B%E7%9A%84Backtracking%E9%97%AE%E9%A2%98/">总结</a>，本文的完整代码见 <a href="https://github.com/brightsunp/learn/blob/master/leetcode/solve_NQueens_Sudoku.py" target="_blank" rel="noopener">这里</a>。</p><h2 id="1-N-Queens问题"><a href="#1-N-Queens问题" class="headerlink" title="1 N-Queens问题"></a>1 N-Queens问题</h2><p><a href="https://leetcode.com/problems/n-queens/" target="_blank" rel="noopener">51. N-Queens</a></p><blockquote><p>Given an integer n, return all distinct solutions to the n-queens puzzle.<br>Each solution contains a distinct board configuration of the n-queens’ placement, where ‘Q’ and ‘.’ both indicate a queen and an empty space respectively.</p></blockquote><p><img src="/img/N-Queens.png" alt=""></p><p>解题步骤：</p><ul><li>首先，棋盘的初始化很容易，用 <code>.</code> 填充一个 <code>n*n</code> 矩阵；</li><li>然后，依次往每一行都只放一个皇后 <code>Q</code>（水平线规则），同时判断该位置是否符合其他规则：竖线、45°对角线、135°对角线，不符合则回溯；</li><li>最后，将找到的所有解都添加到全局变量 <code>res[]</code> 中。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveNQueens</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># find all solutions</span></span><br><span class="line">        self.res = []</span><br><span class="line">        self.board = [[<span class="string">'.'</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        self.dfs(<span class="number">0</span>, n)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, row, n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> row == n:</span><br><span class="line">            self.res.append([<span class="string">''</span>.join(line) <span class="keyword">for</span> line <span class="keyword">in</span> self.board])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> self.is_valid(row, col, n):</span><br><span class="line">                self.board[row][col] = <span class="string">'Q'</span></span><br><span class="line">                self.dfs(row + <span class="number">1</span>, n)</span><br><span class="line">                self.board[row][col] = <span class="string">'.'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_valid</span><span class="params">(self, row, col, n)</span>:</span></span><br><span class="line">        <span class="comment"># upper vertical</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(row):</span><br><span class="line">            <span class="keyword">if</span> self.board[i][col] == <span class="string">'Q'</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="comment"># left upper diagonal</span></span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> zip(range(row - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>), range(col - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>)):</span><br><span class="line">            <span class="keyword">if</span> self.board[i][j] == <span class="string">'Q'</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="comment"># right upper diagonal</span></span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> zip(range(row - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>), range(col + <span class="number">1</span>, n)):</span><br><span class="line">            <span class="keyword">if</span> self.board[i][j] == <span class="string">'Q'</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h2 id="2-Sudoku问题"><a href="#2-Sudoku问题" class="headerlink" title="2 Sudoku问题"></a>2 Sudoku问题</h2><p><a href="https://leetcode.com/problems/sudoku-solver/" target="_blank" rel="noopener">37. Sudoku Solver</a></p><blockquote><p>The given board contain only digits 1-9 and the character ‘.’. You may assume that the given Sudoku puzzle will have a single unique solution. Do not return anything, modify board in-place instead.</p></blockquote><p><img src="/img/Sudoku.png" alt=""></p><p>和N-Queens相比，这里有两点不同：</p><ul><li><strong>前进的方式</strong>，需要手动找下一个空白，没有空白则终止递归；</li><li><strong>回溯的条件</strong>，需要整条路都走不通才进行回溯。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveSudoku</span><span class="params">(self, board)</span>:</span></span><br><span class="line">        <span class="comment"># find one solution</span></span><br><span class="line">        self.board = board</span><br><span class="line">        self.dfs()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self)</span>:</span></span><br><span class="line">        loc = [<span class="number">-1</span>, <span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.find_empty_loc(loc):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        row, col = tuple(loc)</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">            <span class="keyword">if</span> self.is_valid(row, col, str(num)):</span><br><span class="line">                self.board[row][col] = str(num)</span><br><span class="line">                <span class="keyword">if</span> self.dfs():</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.board[row][col] = <span class="string">'.'</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_empty_loc</span><span class="params">(self, loc)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">                <span class="keyword">if</span> self.board[i][j] == <span class="string">'.'</span>:</span><br><span class="line">                    loc[<span class="number">0</span>] = i</span><br><span class="line">                    loc[<span class="number">1</span>] = j</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_valid</span><span class="params">(self, row, col, digit)</span>:</span></span><br><span class="line">        <span class="comment"># used in row</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">if</span> self.board[row][i] == digit:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="comment"># used in col</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">if</span> self.board[j][col] == digit:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="comment"># used in sub-box</span></span><br><span class="line">        row, col = row - row % <span class="number">3</span>, col - col % <span class="number">3</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">                <span class="keyword">if</span> self.board[row + i][col + j] == digit:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;N皇后、数独是经典的数学问题，用编程的方式来解决，关键在于如何用数学语言来描述问题，从而选择对应的算法：&lt;br&gt;前者求的是所有符合规则的解；后者求的是唯一解，即判断有没有解。&lt;br&gt;这两类问题都是Backtracking的典型应用，我前面做过 &lt;a href=&quot;https:
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://brightsunp.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Daily-Coding-Problem-11-20</title>
    <link href="https://brightsunp.github.io/2018/12/14/Daily-Coding-Problem-11-20/"/>
    <id>https://brightsunp.github.io/2018/12/14/Daily-Coding-Problem-11-20/</id>
    <published>2018-12-14T01:41:44.000Z</published>
    <updated>2020-08-03T03:47:49.888Z</updated>
    
    <content type="html"><![CDATA[<p>第二个10天，题目变得好难，特别是本文的第5题和第6题，搞懂了以后对解题思路的帮助很大。本文的完整代码见 <a href="https://github.com/brightsunp/learn/blob/master/leetcode/DCP_11-20.py" target="_blank" rel="noopener">这里</a>。</p><h2 id="1-Amazon-字符串中包含k个不同字符的最长子串"><a href="#1-Amazon-字符串中包含k个不同字符的最长子串" class="headerlink" title="1 Amazon-字符串中包含k个不同字符的最长子串"></a>1 Amazon-字符串中包含k个不同字符的最长子串</h2><p><a href="https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters" target="_blank" rel="noopener">340. Longest Substring with At Most K Distinct Characters</a></p><blockquote><p>Given a string, find the length of the longest substring T that contains at most k distinct characters.<br>For example, Given s = “eceba” and k = 2,<br>T is “ece” which its length is 3.</p></blockquote><p>这道题属于子字符串问题，一般化而言，就是寻找满足某条件的子字符串，用<strong>滑动窗口</strong>的思路能在线性时间内解决，具体的解题模板见 <a href="https://leetcode.com/problems/minimum-window-substring/discuss/26808/Here-is-a-10-line-template-that-can-solve-most-&#39;substring&#39;-problems" target="_blank" rel="noopener">这里</a>。这个思路也适用于寻找某些连续子数组的问题。</p><blockquote><p>A general way is to use a hashmap assisted with two pointers.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstringKDistinct</span><span class="params">(self, s, k)</span>:</span></span><br><span class="line">        <span class="comment"># maintain a valid window</span></span><br><span class="line">        left = max_len = <span class="number">0</span></span><br><span class="line">        counter = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            counter[s[right]] = counter.get(s[right], <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> len(counter) &gt; k:</span><br><span class="line">                counter[s[left]] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> counter[s[left]] == <span class="number">0</span>:</span><br><span class="line">                    counter.pop(s[left])</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            max_len = max(max_len, right-left+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure><h2 id="2-Google-蒙特卡洛法求π"><a href="#2-Google-蒙特卡洛法求π" class="headerlink" title="2 Google-蒙特卡洛法求π"></a>2 Google-蒙特卡洛法求π</h2><blockquote><p>The area of a circle is defined as π*r^2. Estimate π to 3 decimal places using a Monte Carlo method.<br>Hint: The basic equation of a circle is x^2 + y^2 = r^2.</p></blockquote><p><a href="https://zh.wikipedia.org/wiki/%E8%92%99%E5%9C%B0%E5%8D%A1%E7%BE%85%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">蒙特卡洛算法</a> 也称<strong>统计模拟方法</strong>，指的是使用随机数来解决很多计算问题的方法，与之对应的是 <a href="https://zh.wikipedia.org/wiki/%E7%A1%AE%E5%AE%9A%E6%80%A7%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">确定性算法</a>。对于有机器学习背景的人来讲，这道题很好理解：向一个由正方形和圆组成的图形里随机扔豆子，那么落入圆中的概率等于圆和正方形的面积之比，取 <code>r = 1</code>，则有 <code>π/4 ≈ n/N</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">estimatePi</span><span class="params">(self)</span>:</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">10</span>**<span class="number">9</span>):</span><br><span class="line">            <span class="comment"># random float between [0, 1)</span></span><br><span class="line">            x = random.random()</span><br><span class="line">            y = random.random()</span><br><span class="line">            <span class="keyword">if</span> x**<span class="number">2</span> + y**<span class="number">2</span> &lt; <span class="number">1</span>:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&#123;:.4f&#125;'</span>.format(count * <span class="number">4.0</span> / <span class="number">10</span>**<span class="number">9</span>)</span><br></pre></td></tr></table></figure><p>上述代码的实际计算速度很慢，而且计算机产生的<strong>伪随机数</strong>只能精确到某位数，不能产生无理数等，即使取10的9次方个随机点时，其结果也仅在前4位与圆周率吻合。参考见 <a href="http://www.ruanyifeng.com/blog/2015/07/monte-carlo-method.html" target="_blank" rel="noopener">这里</a>。</p><h2 id="3-Facebook-从数据流随机选取1个数据"><a href="#3-Facebook-从数据流随机选取1个数据" class="headerlink" title="3 Facebook-从数据流随机选取1个数据"></a>3 Facebook-从数据流随机选取1个数据</h2><p><a href="https://leetcode.com/problems/linked-list-random-node/" target="_blank" rel="noopener">382. Linked List Random Node</a></p><blockquote><p>Given a stream of elements too large to store in memory, pick a random element from the stream with uniform probability.</p></blockquote><p>又是随机数的问题，题意至少要遍历一次数据流，但不能一次性读入内存。这其实就是 <a href="https://en.wikipedia.org/wiki/Reservoir_sampling" target="_blank" rel="noopener">水塘抽样</a> 中k=1的情形，假设数据流包含n个数，我们要保证每个数被抽到的概率为 <code>1/n</code>。<br>这个情形按以下步骤来实现：</p><blockquote><p>1) 遇到第一个数时，n=1，将它以 <code>1/1</code> 的概率返回；<br>2) 遇到第k个数时，n=k，将它以 <code>1/k</code> 的概率返回，那么要保证前k-1个数被抽到的概率也为 <code>1/k</code>，用<strong>数学归纳法</strong>证明如下。<br>由于最后一个数n=k，其被抽到的概率为 <code>1/k</code> ；前k-1个数，被抽到的概率则为 <code>1/(k-1) * (1-1/(k)) = 1/k</code>，符合条件。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRandom</span><span class="params">(self, stream, n)</span>:</span></span><br><span class="line">        <span class="comment"># uniform probability: 1/(i+1), i=n-1 =&gt; 1/n</span></span><br><span class="line">        res = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> random.randrange(i+<span class="number">1</span>) == <span class="number">0</span>:</span><br><span class="line">                res = stream[i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>扩展到k&gt;1的情形，题目就变为“从数据流随机选取k个数据”，那么我们要保证每个数被抽到的概率为 <code>k/n</code>，证明过程见 <a href="https://leetcode.com/problems/linked-list-random-node/discuss/85659/Brief-explanation-for-Reservoir-Sampling" target="_blank" rel="noopener">这里</a>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRandomK</span><span class="params">(self, stream, n, k)</span>:</span></span><br><span class="line">        <span class="comment"># Reservoir sampling</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            res.append(stream[i])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k, n):</span><br><span class="line">            j = random.randrange(i+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> j &lt; k:</span><br><span class="line">                res[j] = stream[i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="4-Google-字符串中最长的绝对路径"><a href="#4-Google-字符串中最长的绝对路径" class="headerlink" title="4 Google-字符串中最长的绝对路径"></a>4 Google-字符串中最长的绝对路径</h2><p><a href="https://leetcode.com/problems/longest-absolute-file-path/" target="_blank" rel="noopener">388. Longest Absolute File Path</a></p><blockquote><p>Given a string representing the file system in the above format, return the length of the longest absolute path to a file in the abstracted file system. If there is no file in the system, return 0.<br>“dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext”<br>=&gt; “dir/subdir2/subsubdir2/file2.ext”, and its length is 32</p></blockquote><p>分析这道题，最长绝对路径不一定是最深的路径，我们需要遍历所有的文件路径长度。<br>有个很清晰的实现思路：以深度和当前深度的绝对路径长度来建立哈希表；这样找到一个文件后，深度就回到1，更新哈希表的值继续寻找下一个文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthLongestPath</span><span class="params">(self, input)</span>:</span></span><br><span class="line">        <span class="comment"># dict &#123;depth: cur_len&#125;</span></span><br><span class="line">        d = &#123;<span class="number">0</span>: <span class="number">0</span>&#125;</span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> input.split(<span class="string">'\n'</span>):</span><br><span class="line">            name = line.lstrip(<span class="string">'\t'</span>)</span><br><span class="line">            depth = len(line) - len(name)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">'.'</span> <span class="keyword">in</span> name:</span><br><span class="line">                max_len = max(max_len, d[depth] + len(name))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                d[depth+<span class="number">1</span>] = d[depth] + len(name) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure><h2 id="5-Google-数组中所有长度为k的连续子数组的最大值"><a href="#5-Google-数组中所有长度为k的连续子数组的最大值" class="headerlink" title="5 Google-数组中所有长度为k的连续子数组的最大值"></a>5 Google-数组中所有长度为k的连续子数组的最大值</h2><p><a href="https://leetcode.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">239. Sliding Window Maximum</a></p><blockquote><p>Given an array of integers and a number k, where 1 &lt;= k &lt;= length of the array, compute the maximum values of each subarray of length k.<br>For example, given array = [10, 5, 2, 7, 8, 7] and k = 3,<br>we should get: [10, 7, 8, 8], since:<br>    • 10 = max(10, 5, 2)<br>    • 7 = max(5, 2, 7)<br>    • 8 = max(2, 7, 8)<br>    • 8 = max(7, 8, 7)</p></blockquote><ul><li>解法一是 <code>Brutal Force</code>：求所有的 max(k-subarray)，时间复杂度<strong>O(nk)</strong>；</li><li>解法二是 <code>Heap</code>：优化计算最大值的过程，维护一个 k-heap，时间复杂度<strong>O(nlogk)</strong>；</li><li>解法三是 <code>Deque</code>：这个思路最 hack，用双向队列存储 useful index，并且以 nums[index] 降序排列，原因是<strong>比当前元素小的所有元素</strong>对后续的滑动窗口求最大值都没有帮助，时间复杂度<strong>O(n)</strong>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="comment"># deque: store useful indexes in num-decreasing order</span></span><br><span class="line">        res = []</span><br><span class="line">        deque = []</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">while</span> deque <span class="keyword">and</span> num &gt;= nums[deque[<span class="number">-1</span>]]:</span><br><span class="line">                deque.pop()</span><br><span class="line">            deque.append(i)</span><br><span class="line">            <span class="comment"># remove indexes out of window</span></span><br><span class="line">            <span class="keyword">if</span> deque[<span class="number">0</span>] == i-k:</span><br><span class="line">                deque.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> i &gt;= k<span class="number">-1</span>:</span><br><span class="line">                res.append(nums[deque[<span class="number">0</span>]])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="6-Facebook-用k种颜色粉刷房子的最小代价"><a href="#6-Facebook-用k种颜色粉刷房子的最小代价" class="headerlink" title="6 Facebook-用k种颜色粉刷房子的最小代价"></a>6 Facebook-用k种颜色粉刷房子的最小代价</h2><p><a href="https://leetcode.com/problems/paint-house-ii" target="_blank" rel="noopener">265. Paint House II</a></p><blockquote><p>A builder is looking to build a row of N houses that can be of K different colors. He has a goal of minimizing cost while ensuring that no two neighboring houses are of the same color.<br>Given an N by K matrix where the nth row and kth column represents the cost to build the nth house with kth color, return the minimum cost which achieves this goal.</p></blockquote><p>这道题是 <a href="https://leetcode.com/problems/paint-house" target="_blank" rel="noopener">256. Paint House</a> 的拓展，都属于动态规划问题。</p><p>第一题只考虑相邻不同色的限定，当前的房子可选3个颜色，每个颜色取前面2个颜色的最小值为最优解，有以下递推式：<br><code>dp[i][j] += min(dp[i - 1][(j + 1) % 3], dp[i - 1][(j + 2) % 3])</code><br>最后求 <code>min(dp[-1])</code> 即为问题的解，虽然每走一步都做了6次比较，最后的时间复杂度仍为<strong>O(n)</strong>。</p><p>第二题如果按上述思路，当前的房子可选k个颜色，每个颜色取前面k-1个颜色的最小值为最优解，时间复杂度<strong>O(nkk)</strong>，这个解法会TLE。<br>优化的思路如下：既然求的是 <code>min(dp[-1])</code>，那么对我们真正有用的是当前房子花费的 <code>smallest</code> （用来记录结果）和 <code>2nd_smallest</code> （用来计算下一个房子同色的情形），以及 <code>smallest</code> 对应的颜色 <code>pre</code>（用来判断同色），于是有以下递推式：<br><code>dp[i][j] += 2nd_smallest if j==pre else smallest</code><br>由于每个房子的k个颜色都参与了计算，最后的时间复杂度为<strong>O(nk)</strong>。</p><p>总结一下，这两道题是<strong>贪心</strong>和<strong>动态规划</strong>思想的综合运用；按照优化后的思路，甚至不需要建立二维的dp数组，进一步节省了空间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCost</span><span class="params">(self, costs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> len(costs) <span class="keyword">or</span> <span class="keyword">not</span> len(costs[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n, k = len(costs), len(costs[<span class="number">0</span>])</span><br><span class="line">        min1, min2, pre = <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="comment"># MAX_INT = sys.maxint if Python2 else sys.maxsize</span></span><br><span class="line">            m1, m2, cur = MAX_INT, MAX_INT, <span class="number">-1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(k):</span><br><span class="line">                cur_cost = costs[i][j] + (min2 <span class="keyword">if</span> j==pre <span class="keyword">else</span> min1)</span><br><span class="line">                <span class="keyword">if</span> cur_cost &lt; m1:</span><br><span class="line">                    m1, m2, cur = cur_cost, m1, j</span><br><span class="line">                <span class="keyword">elif</span> cur_cost &lt; m2:</span><br><span class="line">                    m2 = cur_cost</span><br><span class="line">            <span class="comment"># updated when i steps forward</span></span><br><span class="line">            min1, min2, pre = m1, m2, cur</span><br><span class="line">        <span class="keyword">return</span> min1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;第二个10天，题目变得好难，特别是本文的第5题和第6题，搞懂了以后对解题思路的帮助很大。本文的完整代码见 &lt;a href=&quot;https://github.com/brightsunp/learn/blob/master/leetcode/DCP_11-20.py&quot; targ
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://brightsunp.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Scrapy项目实战</title>
    <link href="https://brightsunp.github.io/2018/12/07/scrapy%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
    <id>https://brightsunp.github.io/2018/12/07/scrapy项目实战/</id>
    <published>2018-12-07T06:25:20.000Z</published>
    <updated>2020-08-03T03:47:49.880Z</updated>
    
    <content type="html"><![CDATA[<p>最近开发了一个数据挖掘项目，前期的数据来源是爬虫，中期的数据筛选是Random-Forest，后期的数据提取是NER（命名实体识别）。<br>我花了不少功夫在完整的爬虫上，今天以其中的一小步来总结scrapy项目的具体步骤，完整的代码见 <a href="https://github.com/brightsunp/dfld_crawler" target="_blank" rel="noopener">这里</a>。</p><h2 id="1-Scrapy-基本架构"><a href="#1-Scrapy-基本架构" class="headerlink" title="1 Scrapy 基本架构"></a>1 Scrapy 基本架构</h2><p><a href="https://github.com/scrapy/scrapy" target="_blank" rel="noopener">Scrapy</a> 是专门为了爬取网站，提取结构性数据而编写的应用框架。它使用 <a href="https://twistedmatrix.com/" target="_blank" rel="noopener">Twisted</a> 异步网络框架来处理网络通讯，架构清晰，而且包含了各种中间件接口。分为以下几个模块：</p><ul><li>引擎（Scrapy Engine）：处理整个系统的数据流，触发事务。</li><li>调度器（Scheduler）：接受引擎发过来的请求，压入调度队列，并在引擎再次请求的时候返回。</li><li>下载器（Downloader）：下载网页内容，并将网页内容返回给蜘蛛。</li><li>蜘蛛（Spider）：定制特定域名或网页的解析规则。</li><li>项目管道（ItemPipeline）：处理由蜘蛛从网页中提取的结构性数据，主要任务是清洗、验证和存储数据。</li><li>中间件（Middlewares）：包括下载器中间件（引擎与下载器之间）、蜘蛛中间件（引擎与蜘蛛之间）、调度中间件（引擎与调度器之间）等。</li></ul><h2 id="2-Scrapy-实战"><a href="#2-Scrapy-实战" class="headerlink" title="2 Scrapy 实战"></a>2 Scrapy 实战</h2><p>光说不练假把式，Scrapy 之所以流行，实战过几次就能感受到其精妙：不仅是简化、规范了爬虫的开发流程，而且自定义中间件能完成各种灵活的需求。<br>比如我需要从 <a href="http://ldzl.people.com.cn/dfzlk/front/firstPage.htm" target="_blank" rel="noopener">人民网-地方领导资料库</a> 抓取各省市的主要领导简历页面，作为验证Random-Forest模型全部判对的测试数据。<br>具体的开发流程如下：</p><h4 id="2-1-创建项目"><a href="#2-1-创建项目" class="headerlink" title="2.1 创建项目"></a>2.1 创建项目</h4><p>Scrapy 提供的命令行工具非常便捷，环境配置完成后，执行 <code>scrapy -h</code> 查看各命令的用途。<br>第一步，创建项目，然后创建第一个 <code>Spider</code>，其命名最好体现实际意义，因为它的启动命令是 <code>scrapy crawl</code>，这里就是个不好的示范（懒得改了）。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scrapy startproject dfld</span><br><span class="line"><span class="built_in">cd</span> dfld</span><br><span class="line">scrapy genspider crawler ldzl.people.com.cn/dfzlk/front/firstPage.htm</span><br></pre></td></tr></table></figure></p><h4 id="2-2-自定义结构性数据"><a href="#2-2-自定义结构性数据" class="headerlink" title="2.2 自定义结构性数据"></a>2.2 自定义结构性数据</h4><p><code>Item</code> 是我们保存想要抓取的数据的容器，使用方法和内置 <code>dict</code> 类似。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DfldItem</span><span class="params">(scrapy.Item)</span>:</span></span><br><span class="line">    url = scrapy.Field()</span><br><span class="line">    title = scrapy.Field()</span><br><span class="line">    content = scrapy.Field()</span><br></pre></td></tr></table></figure></p><h4 id="2-3-编写解析网页的Spider"><a href="#2-3-编写解析网页的Spider" class="headerlink" title="2.3 编写解析网页的Spider"></a>2.3 编写解析网页的Spider</h4><p><code>parse</code> 方法以url下载后的Response对象为唯一的参数，负责解析数据，至少要做一件事：提取数据 <code>yield item</code>，或者生成需要进一步抓取的Request对象 <code>yield scrapy.Request(...)</code>。<br>本项目中，我要抓取的领导简历页面都以相对路径的形式出现，并包含 <code>personPage</code>，进入其他省市则需要点击包含 <code>personProvince</code> 的链接，所以主体的解析代码非常简单。<br>另外，<code>extract</code> 系列方法返回的是 <code>str</code>，而 <code>response.body</code> 属性返回的是 <code>bytes</code>，其编码与网页的原始编码一致，所以使用该编码进行解码，即可转化为 <code>str</code>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> ..items <span class="keyword">import</span> DfldItem</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrawlerSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">'crawler'</span></span><br><span class="line">    allowed_domains = [<span class="string">'ldzl.people.com.cn'</span>]</span><br><span class="line">    start_urls = [<span class="string">'http://ldzl.people.com.cn/dfzlk/front/firstPage.htm'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> link <span class="keyword">in</span> response.css(<span class="string">'a::attr(href)'</span>).extract():</span><br><span class="line">            <span class="keyword">if</span> <span class="string">'personProvince'</span> <span class="keyword">in</span> link:</span><br><span class="line">                <span class="keyword">yield</span> scrapy.Request(response.urljoin(link), callback=self.parse)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">'personPage'</span> <span class="keyword">in</span> link:</span><br><span class="line">                <span class="keyword">yield</span> scrapy.Request(response.urljoin(link), callback=self.page_parse)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">page_parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        item = DfldItem()</span><br><span class="line">        item[<span class="string">'url'</span>] = response.url</span><br><span class="line">        item[<span class="string">'title'</span>] = response.css(<span class="string">'title::text'</span>).extract_first()</span><br><span class="line">        item[<span class="string">'content'</span>] = response.body.decode(response.encoding)</span><br><span class="line">        <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure></p><h4 id="2-4-自定义数据管道"><a href="#2-4-自定义数据管道" class="headerlink" title="2.4 自定义数据管道"></a>2.4 自定义数据管道</h4><p><code>Pipeline</code> 的作用有很多，详细教程见 <a href="https://doc.scrapy.org/en/latest/topics/item-pipeline.html" target="_blank" rel="noopener">这里</a>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os, re, csv</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HtmlCleanPipeline</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    数据清洗：title、content</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line">        item[<span class="string">'title'</span>] = self._process_title(item[<span class="string">'title'</span>])</span><br><span class="line">        item[<span class="string">'content'</span>] = self._process_content(item[<span class="string">'content'</span>])</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_process_title</span><span class="params">(self, title)</span>:</span></span><br><span class="line">        <span class="comment"># 去除标题中的空字符</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(title.split())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_process_content</span><span class="params">(self, content)</span>:</span></span><br><span class="line">        re_blank = re.compile(<span class="string">'[,\s]*'</span>)  <span class="comment"># 空白字符（空格、tab、换行）、英文逗号</span></span><br><span class="line">        re_script = re.compile(<span class="string">'&lt;script[^&gt;]*&gt;.*?&lt;/script&gt;'</span>, re.I)  <span class="comment"># script标签</span></span><br><span class="line">        re_style = re.compile(<span class="string">'&lt;style[^&gt;]*&gt;.*?&lt;/style&gt;'</span>, re.I)  <span class="comment"># style标签</span></span><br><span class="line">        re_comment = re.compile(<span class="string">'&lt;!--.*?--&gt;'</span>)  <span class="comment"># HTML注释</span></span><br><span class="line">        re_tag = re.compile(<span class="string">'&lt;[^&gt;]*&gt;'</span>)  <span class="comment"># HTML标签</span></span><br><span class="line">        re_entity = re.compile(<span class="string">'&amp;[#\w\d]*?;'</span>)  <span class="comment"># HTML实体</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ptn <span class="keyword">in</span> [re_blank, re_script, re_style, re_comment, re_tag, re_entity]:</span><br><span class="line">            content = ptn.sub(<span class="string">''</span>, content)</span><br><span class="line">        <span class="keyword">return</span> content</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CsvWritePipeline</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    结果存储：.csv文件，每一行的数据是[url, title, content]</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        cur_dir = os.path.dirname(os.path.abspath(__file__))</span><br><span class="line">        self.result_dir = os.path.join(cur_dir, <span class="string">'..'</span>, <span class="string">'result'</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(self.result_dir):</span><br><span class="line">            os.makedirs(self.result_dir)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line">        file_name = os.path.join(self.result_dir, <span class="string">'dfld.csv'</span>)</span><br><span class="line">        <span class="keyword">with</span> open(file_name, <span class="string">'a+'</span>, encoding=<span class="string">'utf-8'</span>, newline=<span class="string">''</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f_csv = csv.writer(f)</span><br><span class="line">            f_csv.writerow([item[<span class="string">'url'</span>], item[<span class="string">'title'</span>], item[<span class="string">'content'</span>]])</span><br><span class="line">        <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure></p><h4 id="2-5-自定义中间件"><a href="#2-5-自定义中间件" class="headerlink" title="2.5 自定义中间件"></a>2.5 自定义中间件</h4><p><code>Middleware</code> 有多种类型，具体的需求在哪个阶段，最好就使用对应的中间件，这样可以让整体的流程清晰。<br>这个设计思想在很多流行框架中都有体现，也是我最喜欢Scrapy的一个点。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DfldDownloaderMiddleware</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    使用随机的User-Agent进行爬虫</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># User-Agent 列表：https://github.com/fengzhizi715/user-agent-list/blob/master/Chrome.txt</span></span><br><span class="line">        self.user_agent_list = [</span><br><span class="line">            <span class="string">'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2228.0 Safari/537.36'</span>,</span><br><span class="line">            <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2227.1 Safari/537.36'</span>,</span><br><span class="line">            <span class="string">'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2227.0 Safari/537.36'</span>,</span><br><span class="line">            <span class="string">'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2227.0 Safari/537.36'</span>,</span><br><span class="line">            <span class="string">'Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2226.0 Safari/537.36'</span>,</span><br><span class="line">            <span class="string">'Mozilla/5.0 (Windows NT 6.4; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2225.0 Safari/537.36'</span>,</span><br><span class="line">            <span class="string">'Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2225.0 Safari/537.36'</span>,</span><br><span class="line">            <span class="string">'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2224.3 Safari/537.36'</span>,</span><br><span class="line">            <span class="string">'Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.93 Safari/537.36'</span>,</span><br><span class="line">            <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2062.124 Safari/537.36'</span>,</span><br><span class="line">            <span class="string">'Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2049.0 Safari/537.36'</span>,</span><br><span class="line">            <span class="string">'Mozilla/5.0 (Windows NT 4.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2049.0 Safari/537.36'</span>,</span><br><span class="line">            <span class="string">'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1985.67 Safari/537.36'</span>,</span><br><span class="line">            <span class="string">'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1985.67 Safari/537.36'</span>,</span><br><span class="line">            <span class="string">'Mozilla/5.0 (X11; OpenBSD i386) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1985.125 Safari/537.36'</span>,</span><br><span class="line">            <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1944.0 Safari/537.36'</span>,</span><br><span class="line">            <span class="string">'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.3319.102 Safari/537.36'</span>,</span><br><span class="line">            <span class="string">'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.2309.372 Safari/537.36'</span>,</span><br><span class="line">            <span class="string">'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.2117.157 Safari/537.36'</span>,</span><br><span class="line">            <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.47 Safari/537.36'</span></span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request, spider)</span>:</span></span><br><span class="line">        ua = random.choice(self.user_agent_list)</span><br><span class="line">        request.headers[<span class="string">'User-Agent'</span>] = ua</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure></p><h4 id="2-6-配置settings"><a href="#2-6-配置settings" class="headerlink" title="2.6 配置settings"></a>2.6 配置settings</h4><p>启用自定义的Pipelines、Middlewares（按数字的大小顺序执行），以及很多有用的配置字段，详细教程见 <a href="https://doc.scrapy.org/en/latest/topics/settings.html" target="_blank" rel="noopener">这里</a>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">    &apos;dfld.pipelines.HtmlCleanPipeline&apos;: 200,</span><br><span class="line">    &apos;dfld.pipelines.CsvWritePipeline&apos;: 300,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DOWNLOADER_MIDDLEWARES = &#123;</span><br><span class="line">    &apos;dfld.middlewares.DfldDownloaderMiddleware&apos;: 543,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-7-启动Spider"><a href="#2-7-启动Spider" class="headerlink" title="2.7 启动Spider"></a>2.7 启动Spider</h4><p>一步到位，我喜欢把日志保存到单独的文件，所以加上 <code>-s</code> 参数（或者设置settings的 <code>LOG_FILE</code> 字段）。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy crawl crawler -s LOG_FILE=dfld_crawler.log</span><br></pre></td></tr></table></figure></p><h4 id="2-8-检查爬虫结果"><a href="#2-8-检查爬虫结果" class="headerlink" title="2.8 检查爬虫结果"></a>2.8 检查爬虫结果</h4><p>当然是查看想要的数据爬到了没，如果出问题的话，就查看日志定位原因。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://ldzl.people.com.cn/dfzlk/front/personPage5462.htm,盛茂林简历-人民网地方领导资料库,盛茂林简历-人民网地方领导资料库人民网|地方领导频道北京天津河北山西内蒙古辽宁吉林黑龙江上海江苏浙江安徽福建江西山东河南湖北湖南广东广西海南重庆四川贵州云南西藏陕西甘肃青海宁夏新疆香港澳门台湾盛茂林简历天津市政协主席盛茂林盛茂林，男，汉族，1960年1月生，湖北黄石人，1981年12月加入中国共产党，1975年3月参加工作，中央党校大学学历。曾为湖南省郴县知青，后历任核工业部711矿钻探队工人、团总支书记，矿团委副书记、书记，矿党委委员、办公室主任、政工办主任，共青团湖南省郴州地委副书记、书记，共青团湖南省委事业发展部部长、青少年发展基金会秘书长，湖南省资兴市（县级）委副书记（挂职），资兴市（县级）委书记。1998.07先后任湖南省郴州市委常委、资兴市（县级）委书记，郴州市委副书记2003.02先后任湖南省计划生育委员会（省人口和计划生育委员会）主任、党组书记，邵阳市委书记，省委组织部常务副部长，省政府党组成员、秘书长，省政府办公厅主任、党组书记2012.01湖南省副省长2014.08先后任山西省委常委、组织部部长，省委党校校长2017.03天津市委常委、组织部部长2018.01天津市政协主席，市委常委、市委组织部部长2018.03天津市政协主席党的十九大代表。（人民网资料截至2018年3月）纠错、提醒管理员更新返回封面纠错提醒管理员更新领导信息纠错领导姓名天津市政协主席错误或需更新内容以上内容均为必填，请尽量详细描述需修订的内容及原因等信息您的姓名:联系方式:验证码:请先输入正确的验证码后方可点击提交按钮人民网版权所有，未经书面授权禁止使用Copyright1997-2017bywww.people.com.cn.allrightsreserved</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近开发了一个数据挖掘项目，前期的数据来源是爬虫，中期的数据筛选是Random-Forest，后期的数据提取是NER（命名实体识别）。&lt;br&gt;我花了不少功夫在完整的爬虫上，今天以其中的一小步来总结scrapy项目的具体步骤，完整的代码见 &lt;a href=&quot;https://g
      
    
    </summary>
    
    
      <category term="Web" scheme="https://brightsunp.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>一道题搞懂前缀树Trie的原理</title>
    <link href="https://brightsunp.github.io/2018/12/06/%E4%B8%80%E9%81%93%E9%A2%98%E6%90%9E%E6%87%82%E5%89%8D%E7%BC%80%E6%A0%91Trie%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>https://brightsunp.github.io/2018/12/06/一道题搞懂前缀树Trie的原理/</id>
    <published>2018-12-06T01:45:57.000Z</published>
    <updated>2020-08-03T03:47:49.869Z</updated>
    
    <content type="html"><![CDATA[<p>这是我非常喜欢的一道题，用到了 Backtracking 和 Trie，但不拘泥于表面；<br>初版的解法实质上是两道题的结合，摸清楚 Trie 的原理后，就能一步步进行优化。</p><h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1 题目描述"></a>1 题目描述</h2><p><a href="https://leetcode.com/problems/word-search-ii/" target="_blank" rel="noopener">212. Word Search II</a></p><blockquote><p>Given a 2D board and a list of words from the dictionary, find all words in the board.<br>The same letter cell may not be used more than once in a word. All inputs are consist of lowercase letters a-z.<br>words = [“oath”,”pea”,”eat”,”rain”] and board =<br>[<br>  [‘o’,’a’,’a’,’n’],<br>  [‘e’,’t’,’a’,’e’],<br>  [‘i’,’h’,’k’,’r’],<br>  [‘i’,’f’,’l’,’v’]<br>]<br>=&gt; [“eat”,”oath”]</p></blockquote><p>这道题是从字母组成的矩阵中，找到所有可能组成的单词，并且判断每个单词是否在给定的单词数组中。前半部分显然和 <a href="https://leetcode.com/problems/word-search/" target="_blank" rel="noopener">79. Word Search</a> 一致，后半部分是前缀树的典型应用：通过 <code>insert</code> 构造 Trie，通过 <code>startsWith</code> 提前结束回溯，通过 <code>search</code> 找到每个解，所以需要 <a href="https://leetcode.com/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener">208. Implement Trie (Prefix Tree)</a>。</p><h2 id="2-初版解法"><a href="#2-初版解法" class="headerlink" title="2 初版解法"></a>2 初版解法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># implement Trie</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.isLeaf = <span class="keyword">False</span></span><br><span class="line">        <span class="comment"># defaultdict: &#123;char: TrieNode&#125;</span></span><br><span class="line">        self.children = &#123;&#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.root = TrieNode()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, word)</span>:</span></span><br><span class="line">        cur = self.root</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> word:</span><br><span class="line">            cur = cur.children.setdefault(char, TrieNode())</span><br><span class="line">        cur.isLeaf = <span class="keyword">True</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, word)</span>:</span></span><br><span class="line">        cur = self.root</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> word:</span><br><span class="line">            cur = cur.children.get(char)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> cur.isLeaf</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">startsWith</span><span class="params">(self, prefix)</span>:</span></span><br><span class="line">        cur = self.root</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> prefix:</span><br><span class="line">            cur = cur.children.get(char)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># do word search</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findWords</span><span class="params">(self, board, words)</span>:</span></span><br><span class="line">        <span class="comment"># Backtracking + Trie</span></span><br><span class="line">        self.trie = Trie()</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            self.trie.insert(word)</span><br><span class="line">        self.res = set()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(board[<span class="number">0</span>])):</span><br><span class="line">                self.dfs(board, i, j, board[i][j])</span><br><span class="line">        <span class="keyword">return</span> list(self.res)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, board, i, j, tmp)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.trie.startsWith(tmp):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> self.trie.search(tmp):</span><br><span class="line">            self.res.add(tmp)</span><br><span class="line">        c, board[i][j] = board[i][j], <span class="string">'#'</span></span><br><span class="line">        <span class="keyword">if</span> i&gt;<span class="number">0</span>: self.dfs(board, i<span class="number">-1</span>, j, tmp+board[i<span class="number">-1</span>][j])</span><br><span class="line">        <span class="keyword">if</span> i&lt;len(board)<span class="number">-1</span>: self.dfs(board, i+<span class="number">1</span>, j, tmp+board[i+<span class="number">1</span>][j])</span><br><span class="line">        <span class="keyword">if</span> j&gt;<span class="number">0</span>: self.dfs(board, i, j<span class="number">-1</span>, tmp+board[i][j<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">if</span> j&lt;len(board[<span class="number">0</span>])<span class="number">-1</span>: self.dfs(board, i, j+<span class="number">1</span>, tmp+board[i][j+<span class="number">1</span>])</span><br><span class="line">        board[i][j] = c</span><br></pre></td></tr></table></figure><h2 id="3-如何优化"><a href="#3-如何优化" class="headerlink" title="3 如何优化"></a>3 如何优化</h2><p>优化过程的启发来自于 <a href="https://leetcode.com/problems/word-search-ii/discuss/59780/Java-15ms-Easiest-Solution-(100.00" target="_blank" rel="noopener">这里</a>，我这个初版解法值得优化的点在于：</p><ul><li>不必实现完整的 Trie 结构，仅需要它的思想和原理</li><li>不必用 str_concat，依次比较 char 即可</li><li>不必用 set，找到一个解就删除 word，即对初始的 Trie 进行动态修改</li></ul><p>上述每个优化点都非常 fancy，可见勤思考的重要性，闪耀着智慧的光辉；优化后的解法不仅更优雅、简洁，而且效率高得多。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findWords</span><span class="params">(self, board, words)</span>:</span></span><br><span class="line">        <span class="comment"># Backtracking + Trie</span></span><br><span class="line">        trie = self.buildTrie(words)</span><br><span class="line">        self.res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(board[<span class="number">0</span>])):</span><br><span class="line">                self.dfs(board, i, j, trie)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, board, i, j, trie)</span>:</span></span><br><span class="line">        <span class="comment"># found one</span></span><br><span class="line">        <span class="keyword">if</span> trie.get(<span class="string">'word'</span>):</span><br><span class="line">            self.res.append(trie[<span class="string">'word'</span>])</span><br><span class="line">            <span class="comment"># de-duplicate</span></span><br><span class="line">            trie[<span class="string">'word'</span>] = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> i&lt;<span class="number">0</span> <span class="keyword">or</span> i&gt;=len(board) <span class="keyword">or</span> j&lt;<span class="number">0</span> <span class="keyword">or</span> j&gt;=len(board[<span class="number">0</span>]) <span class="keyword">or</span> board[i][j] <span class="keyword">not</span> <span class="keyword">in</span> trie:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        c, board[i][j] = board[i][j], <span class="string">'#'</span></span><br><span class="line">        self.dfs(board, i<span class="number">-1</span>, j, trie[c])</span><br><span class="line">        self.dfs(board, i+<span class="number">1</span>, j, trie[c])</span><br><span class="line">        self.dfs(board, i, j<span class="number">-1</span>, trie[c])</span><br><span class="line">        self.dfs(board, i, j+<span class="number">1</span>, trie[c])</span><br><span class="line">        board[i][j] = c</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTrie</span><span class="params">(self, words)</span>:</span></span><br><span class="line">        trie = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            cur = trie</span><br><span class="line">            <span class="keyword">for</span> char <span class="keyword">in</span> word:</span><br><span class="line">                cur = cur.setdefault(char, &#123;&#125;)</span><br><span class="line">            cur[<span class="string">'word'</span>] = word</span><br><span class="line">        <span class="keyword">return</span> trie</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是我非常喜欢的一道题，用到了 Backtracking 和 Trie，但不拘泥于表面；&lt;br&gt;初版的解法实质上是两道题的结合，摸清楚 Trie 的原理后，就能一步步进行优化。&lt;/p&gt;
&lt;h2 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;hea
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://brightsunp.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Kaggle学习之过拟合与欠拟合</title>
    <link href="https://brightsunp.github.io/2018/12/04/Kaggle%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%87%E6%8B%9F%E5%90%88%E4%B8%8E%E6%AC%A0%E6%8B%9F%E5%90%88/"/>
    <id>https://brightsunp.github.io/2018/12/04/Kaggle学习之过拟合与欠拟合/</id>
    <published>2018-12-04T01:29:47.000Z</published>
    <updated>2020-08-03T03:47:49.857Z</updated>
    
    <content type="html"><![CDATA[<p>Machine Learning的课程安排是 <code>4hours/19lessons</code>，内容循序渐进，对ML novice非常的友好。</p><h2 id="1-现象描述"><a href="#1-现象描述" class="headerlink" title="1 现象描述"></a>1 现象描述</h2><blockquote><p>过拟合（overfitting）是由于统计模型使用的参数过多，导致模型对训练数据完美匹配，但是对新数据的预测与期望值相差很大的现象；<br>欠拟合（underfitting）是由于统计模型使用的参数过少，以至于得到的模型连训练数据都难以拟合的现象。</p></blockquote><p>机器学习训练后的模型，最好能在新样本上有很好的表现。过拟合是模型过于复杂，学习器很可能把训练样本的某些自身特性当成了所有潜在样本的共性，导致模型的泛化性能下降；欠拟合是模型过于简单，学习器没学到训练样本的一般性质，导致在训练样本和测试样本中的表现都很差。<br>最好的比方莫过于：考试复习，复习题都会做了，但到了考试就不会，那是过拟合；可是如果连复习题都没搞懂，到了考试更不会，那就是欠拟合。在机器学习中，我们要极力避免这两种现象。</p><p><img src="/img/overfitting-and-underfitting-1.png" alt=""></p><h2 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2 解决方案"></a>2 解决方案</h2><h4 id="一般场景"><a href="#一般场景" class="headerlink" title="一般场景"></a>一般场景</h4><p>以决策树的深度选择为例，我们用最简单的平均绝对误差来评价模型的精度，只需找到下图中的拐点：</p><p><img src="/img/overfitting-and-underfitting-2.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeRegressor</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_absolute_error</span><br><span class="line"></span><br><span class="line">iowa_file_path = <span class="string">'../datasets/home-data-for-ml-course/train.csv'</span></span><br><span class="line">home_data = pd.read_csv(iowa_file_path)</span><br><span class="line"></span><br><span class="line">feature_names = [<span class="string">'LotArea'</span>, <span class="string">'YearBuilt'</span>, <span class="string">'1stFlrSF'</span>, <span class="string">'2ndFlrSF'</span>, <span class="string">'FullBath'</span>, <span class="string">'BedroomAbvGr'</span>, <span class="string">'TotRmsAbvGrd'</span>]</span><br><span class="line">X = home_data[feature_names]</span><br><span class="line">y = home_data.SalePrice</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_mae</span><span class="params">(max_leaf_nodes, train_X, val_X, train_y, val_y)</span>:</span></span><br><span class="line">    model = DecisionTreeRegressor(max_leaf_nodes=max_leaf_nodes, random_state=<span class="number">0</span>)</span><br><span class="line">    model.fit(train_X, train_y)</span><br><span class="line">    preds_val = model.predict(val_X)</span><br><span class="line">    mae = mean_absolute_error(val_y, preds_val)</span><br><span class="line">    <span class="keyword">return</span>(mae)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. Split Data into Train &amp; Test</span></span><br><span class="line">train_X, val_X, train_y, val_y = train_test_split(X, y, random_state=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. Choose Best Tree Size</span></span><br><span class="line">candidate_max_leaf_nodes = [<span class="number">5</span>, <span class="number">25</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">250</span>, <span class="number">500</span>]</span><br><span class="line">scores = &#123;leaf_size: get_mae(leaf_size, train_X, val_X, train_y, val_y) <span class="keyword">for</span> leaf_size <span class="keyword">in</span> candidate_max_leaf_nodes&#125;</span><br><span class="line">best_tree_size = min(scores, key=scores.get)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. Fit Model Using All Data</span></span><br><span class="line">final_model = DecisionTreeRegressor(max_leaf_nodes=best_tree_size, random_state=<span class="number">1</span>)</span><br><span class="line">final_model.fit(X, y)</span><br></pre></td></tr></table></figure><h4 id="特定场景"><a href="#特定场景" class="headerlink" title="特定场景"></a>特定场景</h4><p><strong>欠拟合</strong><br>相对来说，欠拟合更容易解决。如果是统计回归模型，则增加模型的参数，线性模型改为二次模型，线性回归改为二次回归；如果是神经网络模型，则增加网络的层数和每一层的神经元数量，具体方案可以看 <a href="https://blog.ailemon.me/2018/04/09/deep-learning-the-ways-to-solve-underfitting/" target="_blank" rel="noopener">深度学习：欠拟合问题的几种解决方案</a>。</p><p><strong>过拟合</strong><br>第一种思路是考虑过拟合的原因：训练数据与训练参数的比例太小。所以，通过增加数据量或者适当减少参数数量来解决，前者是根据大数定理，当数据量足够大时，训练模型会无限逼近实际；后者是根据模型的需要，人工剔除那些跟模型不太相关的参数。<br>第二种思路是正则化：在目标方程中添加正则项（regularization term）。通过加入一个正则项，在最小化新的代价函数时，正则项使得预测值与期望值的误差并不会达到最小，也就是不完美匹配，即防止了过拟合，提高了机器学习模型的泛化能力。</p><p><strong>待学习的知识点</strong>：线性回归、对数几率回归、使用梯度下降法、正则化方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Machine Learning的课程安排是 &lt;code&gt;4hours/19lessons&lt;/code&gt;，内容循序渐进，对ML novice非常的友好。&lt;/p&gt;
&lt;h2 id=&quot;1-现象描述&quot;&gt;&lt;a href=&quot;#1-现象描述&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
    
      <category term="Kaggle" scheme="https://brightsunp.github.io/tags/Kaggle/"/>
    
  </entry>
  
  <entry>
    <title>Daily-Coding-Problem-1-10</title>
    <link href="https://brightsunp.github.io/2018/12/03/Daily-Coding-Problem-1-10/"/>
    <id>https://brightsunp.github.io/2018/12/03/Daily-Coding-Problem-1-10/</id>
    <published>2018-12-03T02:55:54.000Z</published>
    <updated>2020-08-03T03:47:49.843Z</updated>
    
    <content type="html"><![CDATA[<p>从 <code>2018-11-24</code> 开始，我订阅了 <a href="https://www.dailycodingproblem.com/subscribe" target="_blank" rel="noopener">Daily Coding Problem</a>，如果工作忙碌导致没有大块时间刷Leetcode，每日一题的深度思考也能让我保持<strong>对算法问题的敏感程度</strong>；<br>同时，我打算每10天做一次总结，记录其中的 <code>valuable solutions</code>。本文的完整代码见 <a href="https://github.com/brightsunp/learn/blob/master/leetcode/DCP_1-10.py" target="_blank" rel="noopener">这里</a>。</p><blockquote><p>put in a few months of extra effort to pass hard interviews.</p></blockquote><h2 id="1-Uber-数组中所有其他元素的积"><a href="#1-Uber-数组中所有其他元素的积" class="headerlink" title="1 Uber-数组中所有其他元素的积"></a>1 Uber-数组中所有其他元素的积</h2><p><a href="https://leetcode.com/problems/product-of-array-except-self/" target="_blank" rel="noopener">238. Product of Array Except Self</a></p><blockquote><p>Given an array of integers, return a new array such that each element at index i of the new array is the product of all the numbers in the original array except the one at i. what if you can’t use division?<br>[1, 2, 3, 4, 5] =&gt; [120, 60, 40, 30, 24]<br>[3, 2, 1] =&gt; [2, 3, 6]</p></blockquote><p>这道题的思路，首先想到的是计算所有元素的积，对每个元素分别做除法，两次遍历完成，时间复杂度O(n)，但题目不允许使用除法。<br>如果用两个数组分别记录每个数左边和右边子数组的所有元素的乘积，那么：<br><code>res[i] = left[i] * right[n-1-i]</code><br>为了使上述表达式成立，必须考虑边界条件，并设计 <code>left</code> 和 <code>right</code> 的结构。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">productExceptSelf</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="comment"># split: left * right</span></span><br><span class="line">        left, right = [<span class="number">1</span>], [<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums[:<span class="number">-1</span>]:</span><br><span class="line">            left.append(left[<span class="number">-1</span>] * num)</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums[<span class="number">-1</span>:<span class="number">0</span>:<span class="number">-1</span>]:</span><br><span class="line">            right.append(right[<span class="number">-1</span>] * num)</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            res.append(left[i] * right[n<span class="number">-1</span>-i])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><h2 id="2-Google-二叉树的序列化-反序列化"><a href="#2-Google-二叉树的序列化-反序列化" class="headerlink" title="2 Google-二叉树的序列化/反序列化"></a>2 Google-二叉树的序列化/反序列化</h2><p><a href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/" target="_blank" rel="noopener">297. Serialize and Deserialize Binary Tree</a></p><blockquote><p>Given the root to a binary tree, implement serialize(root), which serializes the tree into a string, and deserialize(s), which deserializes the string back into the tree.<br>assert deserialize(serialize(node)).left.left.val == ‘left.left’</p></blockquote><p>这个问题其实在工作中有直接应用，将某个对象序列化、存储，到需要的时候再读取、反序列化，Python的 <code>pickle</code> 和 <code>sklearn.externals.joblib</code> 模块都能实现该功能。<br>对二叉树的问题当然要掌握其遍历方法，我前面做过 <a href="https://brightsunp.github.io/2018/10/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0/">总结</a>，这道题通过遍历和反遍历即可实现。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="comment"># BFS</span></span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> res</span><br><span class="line">        queue = [root]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                res += str(node.val) + <span class="string">' '</span></span><br><span class="line">                queue.append(node.left)</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += <span class="string">'# '</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="comment"># reverse BFS</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data: <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        vals = data.split()</span><br><span class="line">        root = TreeNode(int(vals[<span class="number">0</span>]))</span><br><span class="line">        queue = [root]</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(vals):</span><br><span class="line">            parent = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> vals[i] != <span class="string">'#'</span>:</span><br><span class="line">                left = TreeNode(int(vals[i]))</span><br><span class="line">                parent.left = left</span><br><span class="line">                queue.append(left)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> vals[i] != <span class="string">'#'</span>:</span><br><span class="line">                right = TreeNode(int(vals[i]))</span><br><span class="line">                parent.right = right</span><br><span class="line">                queue.append(right)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></p><h2 id="3-Stripe-数组中第一个缺失的正数"><a href="#3-Stripe-数组中第一个缺失的正数" class="headerlink" title="3 Stripe-数组中第一个缺失的正数"></a>3 Stripe-数组中第一个缺失的正数</h2><p><a href="https://leetcode.com/problems/first-missing-positive/" target="_blank" rel="noopener">41. First Missing Positive</a></p><blockquote><p>Given an array of integers, find the first missing positive integer in linear time and constant space. In other words, find the lowest positive integer that does not exist in the array. The array can contain duplicates and negative numbers as well.<br>[3, 4, -1, 1] =2<br>[1, 2, 0] =3</p></blockquote><p>第一种解法是把所有正数放到哈希表中，同时记录最大的数max_num，然后看1到max_num中的i是否存在，如果存在返回i，否则返回max_num+1；时间复杂度是O(n)，但空间复杂度也是O(n)，不满足条件。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="comment"># use set</span></span><br><span class="line">        s = set()</span><br><span class="line">        max_num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num &gt; <span class="number">0</span>:</span><br><span class="line">                s.add(num)</span><br><span class="line">                max_num = max(max_num, num)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, max_num+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> s:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> max_num+<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>第二种解法是省去额外的空间，直接修改原数组，将每个正数放到它本该出现的索引位置，比如1对应0、2对应1…，然后做一次遍历；对空间复杂度进行了优化。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="comment"># swap in-place</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="comment"># key point: "while loop"</span></span><br><span class="line">            <span class="keyword">while</span> <span class="number">0</span> &lt; nums[i] &lt;= n <span class="keyword">and</span> nums[nums[i]<span class="number">-1</span>] != nums[i]:</span><br><span class="line">                nums[nums[i]<span class="number">-1</span>], nums[i] = nums[i], nums[nums[i]<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != i+<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> n+<span class="number">1</span></span><br></pre></td></tr></table></figure></p><h2 id="4-Airbnb-数组中所有不相邻元素的最大和"><a href="#4-Airbnb-数组中所有不相邻元素的最大和" class="headerlink" title="4 Airbnb-数组中所有不相邻元素的最大和"></a>4 Airbnb-数组中所有不相邻元素的最大和</h2><p><a href="https://leetcode.com/problems/house-robber/" target="_blank" rel="noopener">198. House Robber</a></p><blockquote><p>Given a list of integers, write a function that returns the largest sum of non-adjacent numbers. Numbers can be 0 or negative.<br>[2, 4, 6, 2, 5] =13<br>[5, 1, 1, 5] =10</p></blockquote><p>典型的动态规划问题：<code>f(n) = max(f(n-2)+nums[n-1], f(n-1))</code><br>第一种解法，不考虑空间复杂度<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (n+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">1</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">            dp[i] = max(dp[i<span class="number">-1</span>], nums[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure></p><p>第二种解法，对空间复杂度进行了优化<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        pre = cur = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            pre, cur = cur, max(pre + num, cur)</span><br><span class="line">        <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从 &lt;code&gt;2018-11-24&lt;/code&gt; 开始，我订阅了 &lt;a href=&quot;https://www.dailycodingproblem.com/subscribe&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Daily Coding Prob
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://brightsunp.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Kaggle学习之Pandas</title>
    <link href="https://brightsunp.github.io/2018/11/28/Kaggle%E5%AD%A6%E4%B9%A0%E4%B9%8BPandas/"/>
    <id>https://brightsunp.github.io/2018/11/28/Kaggle学习之Pandas/</id>
    <published>2018-11-28T07:20:02.000Z</published>
    <updated>2020-08-03T03:47:49.836Z</updated>
    
    <content type="html"><![CDATA[<p>Kaggle提供的在线课程，内容生动而实用。</p><blockquote><p>We pare down complex topics to their key practical components, so you finish each course in a few hours (instead of weeks or months).</p></blockquote><p>Pandas是数据分析进阶的必备工具，原课程的安排是 <code>4hours/7lessons</code>；作为Python重度用户，我很快搞定了这几个课时的内容。<br>详细的官方教程见 <a href="https://pandas.pydata.org/pandas-docs/stable/tutorials.html" target="_blank" rel="noopener">这里</a>。</p><h2 id="1-选取数据"><a href="#1-选取数据" class="headerlink" title="1 选取数据"></a>1 选取数据</h2><h4 id="创建与读写"><a href="#创建与读写" class="headerlink" title="创建与读写"></a>创建与读写</h4><p>基本的数据结构是 <code>DataFrame</code>（多行多列）和 <code>Series</code>（一行或一列）。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">pd.set_option(<span class="string">'display.max_rows'</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建对象</span></span><br><span class="line">fruit_sales = pd.DataFrame([[<span class="number">35</span>, <span class="number">21</span>], [<span class="number">41</span>, <span class="number">34</span>]],</span><br><span class="line">                           index=[<span class="string">'2017 Sales'</span>, <span class="string">'2018 Sales'</span>],</span><br><span class="line">                           columns=[<span class="string">'Apples'</span>, <span class="string">'Bananas'</span>])</span><br><span class="line"></span><br><span class="line">ingredients = pd.Series([<span class="string">'4 cups'</span>, <span class="string">'1 cup'</span>, <span class="string">'2 large'</span>, <span class="string">'1 can'</span>],</span><br><span class="line">                        index=[<span class="string">'Flour'</span>, <span class="string">'Milk'</span>, <span class="string">'Eggs'</span>, <span class="string">'Spam'</span>],</span><br><span class="line">                        name=<span class="string">'Dinner'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读写csv</span></span><br><span class="line"><span class="comment"># 第1列作为索引，而不是字段名</span></span><br><span class="line">reviews = pd.read_csv(<span class="string">'../datasets/winemag-data-130k-v2.csv'</span>, index_col=<span class="number">0</span>)</span><br><span class="line">reviews.to_csv(<span class="string">'../datasets/result.csv'</span>)</span><br><span class="line"><span class="comment"># Property: reviews.columns/index/values</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读SQLite数据库</span></span><br><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line">conn = sqlite3.connect(<span class="string">'../datasets/database.sqlite'</span>)</span><br><span class="line">music_reviews = pd.read_sql_query(<span class="string">'select * from artists;'</span>, conn)</span><br></pre></td></tr></table></figure></p><h4 id="选取与过滤"><a href="#选取与过滤" class="headerlink" title="选取与过滤"></a>选取与过滤</h4><p>基本的选取方法是 <code>iloc</code>（位置索引、切片左闭右开）和 <code>loc</code>（值索引、切片左闭右闭）。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按行、列选取</span></span><br><span class="line">desc = reviews.loc[:, <span class="string">'description'</span>]</span><br><span class="line"><span class="comment"># desc = reviews.description</span></span><br><span class="line">first_row = reviews.iloc[<span class="number">0</span>]</span><br><span class="line">sample_reviews = reviews.loc[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>]]</span><br><span class="line">df = reviews.loc[:, [<span class="string">'country'</span>, <span class="string">'variety'</span>]].iloc[:<span class="number">100</span>]</span><br><span class="line"><span class="comment"># df = reviews.head(100).loc[:, ['country', 'variety']]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按条件过滤</span></span><br><span class="line">italian_wines = reviews[reviews.country == <span class="string">'Italy'</span>]</span><br><span class="line">top_oceania_wines = reviews[</span><br><span class="line">    (reviews.points &gt;= <span class="number">95</span>)</span><br><span class="line">    &amp; (reviews.country.isin([<span class="string">'Australia'</span>, <span class="string">'New Zealand'</span>]))</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h2 id="2-分析数据"><a href="#2-分析数据" class="headerlink" title="2 分析数据"></a>2 分析数据</h2><h4 id="基本统计"><a href="#基本统计" class="headerlink" title="基本统计"></a>基本统计</h4><p><code>DataFrame</code> 和 <code>Series</code>：<a href="https://blog.csdn.net/luckarecs/article/details/71627893" target="_blank" rel="noopener">pandas常用统计方法</a>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 中位数</span></span><br><span class="line">median_points = reviews.points.median()</span><br><span class="line"><span class="comment"># 去重后的字段列表</span></span><br><span class="line">countries = reviews.country.unique()</span><br><span class="line"><span class="comment"># 各字段的频率</span></span><br><span class="line">reviews_per_country = reviews.country.value_counts()</span><br><span class="line"><span class="comment"># series 可以直接减 mean_value</span></span><br><span class="line">centered_price = reviews.price - reviews.price.mean()</span><br><span class="line"><span class="comment"># idxmax/argmax 找到某最大值的索引值/位置</span></span><br><span class="line">bargain_idx = (reviews.points / reviews.price).idxmax()</span><br><span class="line">bargain_wine = reviews.loc[bargain_idx, <span class="string">'title'</span>]</span><br><span class="line"><span class="comment"># 某个词在 series 中出现的频率</span></span><br><span class="line">n_trop = reviews.description.map(<span class="keyword">lambda</span> desc: <span class="string">"tropical"</span> <span class="keyword">in</span> desc).sum()</span><br><span class="line">n_fruity = reviews.description.map(<span class="keyword">lambda</span> desc: <span class="string">"fruity"</span> <span class="keyword">in</span> desc).sum()</span><br><span class="line">descriptor_counts = pd.Series([n_trop, n_fruity], index=[<span class="string">'tropical'</span>, <span class="string">'fruity'</span>])</span><br><span class="line"><span class="comment"># apply 对行元素进行统计</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stars</span><span class="params">(row)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> row.country == <span class="string">'Canada'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">    <span class="keyword">elif</span> row.points &gt;= <span class="number">95</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">    <span class="keyword">elif</span> row.points &gt;= <span class="number">85</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">star_ratings = reviews.apply(stars, axis=<span class="string">'columns'</span>)</span><br></pre></td></tr></table></figure><h4 id="分组排序"><a href="#分组排序" class="headerlink" title="分组排序"></a>分组排序</h4><p><code>GroupBy</code>：本身不进行任何计算，只是暂时存储的容器，便于计算想要的 <code>DataFrame</code> 和 <code>Series</code> 结果。</p><ul><li><a href="https://blog.csdn.net/leonis_v/article/details/51832916" target="_blank" rel="noopener">GroupBy用法详解</a></li><li><a href="https://blog.csdn.net/claroja/article/details/71080293" target="_blank" rel="noopener">GroupBy函数汇总</a></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以taster_twitter_handle为索引，以其对应的组大小为值</span></span><br><span class="line">reviews_written = reviews.groupby(<span class="string">'taster_twitter_handle'</span>).size()</span><br><span class="line"><span class="comment"># 以price为索引，以其对应的max(points)为值</span></span><br><span class="line">best_rating_per_price = reviews.groupby(<span class="string">'price'</span>)[<span class="string">'points'</span>].max().sort_index()</span><br><span class="line"><span class="comment"># aggregate聚合：以variety为索引，以其对应的min(price)和max(price)为值</span></span><br><span class="line">price_extremes = reviews.groupby(<span class="string">'variety'</span>)[<span class="string">'price'</span>].agg([min, max])</span><br><span class="line"><span class="comment"># 降序排列：min(price)和max(price)的列表</span></span><br><span class="line">sorted_varieties = price_extremes.sort_values(by=[<span class="string">'min'</span>, <span class="string">'max'</span>], ascending=<span class="keyword">False</span>)</span><br><span class="line"><span class="comment"># 以taster_name为索引，以其对应的mean(points)为值</span></span><br><span class="line">reviewer_mean_ratings = reviews.groupby(<span class="string">'taster_name'</span>)[<span class="string">'points'</span>].mean()</span><br><span class="line"><span class="comment"># 以(country, variety)为索引，以其对应的组大小为值</span></span><br><span class="line">country_variety_counts = reviews.groupby([<span class="string">'country'</span>, <span class="string">'variety'</span>]).size().sort_values(ascending=<span class="keyword">False</span>)</span><br></pre></td></tr></table></figure><h2 id="3-处理数据"><a href="#3-处理数据" class="headerlink" title="3 处理数据"></a>3 处理数据</h2><h4 id="空值与重命名"><a href="#空值与重命名" class="headerlink" title="空值与重命名"></a>空值与重命名</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示类型</span></span><br><span class="line">points_dtype = reviews[<span class="string">'points'</span>].dtype</span><br><span class="line"><span class="comment"># 修改类型</span></span><br><span class="line">point_strings = reviews[<span class="string">'points'</span>].astype(str)</span><br><span class="line"><span class="comment"># point_strings = reviews['points'].astype('float64')</span></span><br><span class="line"><span class="comment"># 空值的个数：isnull 等价于 isna</span></span><br><span class="line">n_missing_prices = reviews[<span class="string">'price'</span>].isnull().sum()</span><br><span class="line"><span class="comment"># n_missing_prices = pd.isnull(reviews['price']).sum()</span></span><br><span class="line"><span class="comment"># 降序排列：常见的链式处理</span></span><br><span class="line">reviews_per_region = reviews[<span class="string">'region_1'</span>].fillna(<span class="string">'Unknown'</span>).value_counts().sort_values(ascending=<span class="keyword">False</span>)</span><br><span class="line"><span class="comment"># 两种重命名方法</span></span><br><span class="line">renamed = reviews.rename(columns=&#123;<span class="string">'region_1'</span>: <span class="string">'region'</span>, <span class="string">'region_2'</span>: <span class="string">'locale'</span>&#125;)</span><br><span class="line">reindexed = reviews.rename_axis(<span class="string">'wines'</span>, axis=<span class="string">'index'</span>)</span><br></pre></td></tr></table></figure><h4 id="联接"><a href="#联接" class="headerlink" title="联接"></a>联接</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">powerlifting_meets = pd.read_csv(<span class="string">"../datasets/powerlifting_meets.csv"</span>)</span><br><span class="line">powerlifting_competitors = pd.read_csv(<span class="string">"../datasets/openpowerlifting.csv"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最简单的联接</span></span><br><span class="line">simple_combined = powerlifting_meets.append(powerlifting_competitors)</span><br><span class="line"><span class="comment"># simple_combined = pd.concat([powerlifting_meets, powerlifting_competitors])</span></span><br><span class="line"><span class="comment"># 根据外键联接</span></span><br><span class="line">powerlifting_combined = powerlifting_meets.set_index(<span class="string">"MeetID"</span>).join(powerlifting_competitors.set_index(<span class="string">"MeetID"</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Kaggle提供的在线课程，内容生动而实用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;We pare down complex topics to their key practical components, so you finish each course in a 
      
    
    </summary>
    
    
      <category term="Kaggle" scheme="https://brightsunp.github.io/tags/Kaggle/"/>
    
  </entry>
  
  <entry>
    <title>Python装饰器原理</title>
    <link href="https://brightsunp.github.io/2018/11/27/Python%E8%A3%85%E9%A5%B0%E5%99%A8%E5%8E%9F%E7%90%86/"/>
    <id>https://brightsunp.github.io/2018/11/27/Python装饰器原理/</id>
    <published>2018-11-27T08:12:17.000Z</published>
    <updated>2020-08-03T03:47:49.826Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间作为项目组的新人，我做了一个技术分享：装饰器原理；这是我在面试中遇过的一道题，而当时的理解浮于表面，所以答的并不好。</p><h2 id="1-什么是装饰器"><a href="#1-什么是装饰器" class="headerlink" title="1 什么是装饰器"></a>1 什么是装饰器</h2><p>装饰器的作用是 <code>在不改动原函数内部实现的情况下，给原函数的工作前后追加工作量</code>。</p><h4 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h4><p>理论基础是 <code>Python中一切皆对象，包括函数</code>。</p><blockquote><p>函数可以用来赋值，也可以作为其他函数的参数、返回值。</p></blockquote><p><strong>函数赋值</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> n * n</span><br><span class="line"></span><br><span class="line">func = square</span><br><span class="line">print(func) <span class="comment"># &lt;function square at ...&gt;</span></span><br><span class="line">print(func(<span class="number">5</span>)) <span class="comment"># 25</span></span><br></pre></td></tr></table></figure></p><p><strong>函数作为参数</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_square</span><span class="params">(f, m, n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> f(m) + f(n)</span><br><span class="line"></span><br><span class="line">print(sum_square(square, <span class="number">3</span>, <span class="number">4</span>)) <span class="comment"># 25</span></span><br></pre></td></tr></table></figure></p><p><strong>函数作为返回值</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square_wrapper</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(n)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> n * n</span><br><span class="line">    <span class="keyword">return</span> square</span><br><span class="line"></span><br><span class="line">wrapper = square_wrapper()</span><br><span class="line">print(wrapper(<span class="number">5</span>))  <span class="comment"># 25</span></span><br></pre></td></tr></table></figure></p><h4 id="装饰器实现"><a href="#装饰器实现" class="headerlink" title="装饰器实现"></a>装饰器实现</h4><ol><li>接受一个函数对象为参数</li><li>嵌套一个包装函数，其参数列表与目标函数的一致</li><li>在包装函数中执行目标函数，追加工作量（甚至彻底替换掉目标函数）</li><li>返回嵌套函数对象</li></ol><p><strong>最简单示例</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">'Get in %s'</span> % func.__name__)</span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"><span class="comment"># 语法糖：等价于 foo = wrapper(foo)</span></span><br><span class="line"><span class="meta">@wrapper</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(something)</span>:</span></span><br><span class="line">    print(<span class="string">'foo: with args [%s]'</span> % something)</span><br><span class="line"></span><br><span class="line">foo(<span class="string">'test'</span>)</span><br></pre></td></tr></table></figure></p><p><strong>目标函数前后打印</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'Get in %s'</span> % func.__name__)</span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line">        print(<span class="string">'Get out %s'</span> % func.__name__)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(something)</span>:</span></span><br><span class="line">    print(<span class="string">'foo: with args [%s]'</span> % something)</span><br><span class="line"></span><br><span class="line">foo(<span class="string">'test'</span>)</span><br></pre></td></tr></table></figure></p><p><strong>彻底替换掉目标函数</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'Get in %s'</span> % func.__name__)</span><br><span class="line">        print(<span class="string">'args:'</span>, *args, <span class="string">' kwargs:'</span>, **kwargs)</span><br><span class="line">        print(<span class="string">'Get out %s'</span> % func.__name__)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(something)</span>:</span></span><br><span class="line">    print(<span class="string">'foo: with args [%s]'</span> % something)</span><br><span class="line"></span><br><span class="line">foo(<span class="string">'test'</span>)</span><br></pre></td></tr></table></figure></p><p><strong>装饰器带参数</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_logging</span><span class="params">(level)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> level == <span class="string">'warn'</span>:</span><br><span class="line">                logging.warning(<span class="string">'Get in %s'</span> % func.__name__)</span><br><span class="line">            <span class="keyword">elif</span> level == <span class="string">'info'</span>:</span><br><span class="line">                logging.info(<span class="string">'Get in %s'</span> % func.__name__)</span><br><span class="line">            func(*args, **kwargs)</span><br><span class="line">            print(<span class="string">'Get out %s'</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@use_logging(level='warn')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(something)</span>:</span></span><br><span class="line">    print(<span class="string">'foo: with args [%s]'</span> % something)</span><br><span class="line"></span><br><span class="line">foo(<span class="string">'test'</span>)</span><br></pre></td></tr></table></figure></p><h2 id="2-其他语言"><a href="#2-其他语言" class="headerlink" title="2 其他语言"></a>2 其他语言</h2><h4 id="JavaScript版本"><a href="#JavaScript版本" class="headerlink" title="JavaScript版本"></a>JavaScript版本</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 某功能</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">haveFunWithJrs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"have fun with jrs\r\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 装饰器</span></span><br><span class="line"><span class="keyword">var</span> decorator = <span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"before calling\r\n"</span>);</span><br><span class="line">    func();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"after calling\r\n "</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 装饰</span></span><br><span class="line">haveFunWithJrs=decorator(haveFunWithJrs);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">haveFunWithJrs();</span><br></pre></td></tr></table></figure><h4 id="PHP版本"><a href="#PHP版本" class="headerlink" title="PHP版本"></a>PHP版本</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 某功能</span></span><br><span class="line">$have_fun_with_jrs = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"have fun with jrs\r\n"</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 装饰器</span></span><br><span class="line">$decorator = <span class="function"><span class="keyword">function</span><span class="params">($func)</span> </span>&#123;</span><br><span class="line">    $wrap = <span class="function"><span class="keyword">function</span><span class="params">()</span> <span class="title">use</span> <span class="params">($func)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"before calling\r\n"</span>;</span><br><span class="line">        $func();</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"after calling\r\n "</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> $wrap;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 装饰</span></span><br><span class="line">$have_fun_with_jrs=$dec($have_fun_with_jrs);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">$have_fun_with_jrs();</span><br></pre></td></tr></table></figure><h2 id="3-通过一道题来回顾"><a href="#3-通过一道题来回顾" class="headerlink" title="3 通过一道题来回顾"></a>3 通过一道题来回顾</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator_a</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">'Get in decorator_a'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner_a</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'Get in inner_a'</span>)</span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line">        print(<span class="string">'Get out inner_a'</span>)</span><br><span class="line">    <span class="keyword">return</span> inner_a</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator_b</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">'Get in decorator_b'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner_b</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'Get in inner_b'</span>)</span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line">        print(<span class="string">'Get out inner_b'</span>)</span><br><span class="line">    <span class="keyword">return</span> inner_b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价于 foo = decorator_a(decorator_b(foo))</span></span><br><span class="line"><span class="meta">@decorator_a</span></span><br><span class="line"><span class="meta">@decorator_b</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(x)</span>:</span></span><br><span class="line">    print(<span class="string">'Get in foo'</span>)</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Get in decorator_b</span></span><br><span class="line"><span class="string">Get in decorator_a</span></span><br><span class="line"><span class="string">Get in inner_a</span></span><br><span class="line"><span class="string">Get in inner_b</span></span><br><span class="line"><span class="string">Get in foo</span></span><br><span class="line"><span class="string">Get out inner_b</span></span><br><span class="line"><span class="string">Get out inner_a</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="4-推荐阅读"><a href="#4-推荐阅读" class="headerlink" title="4 推荐阅读"></a>4 推荐阅读</h2><ul><li><a href="https://wiki.python.org/moin/PythonDecoratorLibrary" target="_blank" rel="noopener">Python装饰器应用示例</a></li><li><a href="https://guoruibiao.gitbooks.io/effective-python/content/" target="_blank" rel="noopener">《Effective Python:编写高质量Python代码的59个有效方法》</a></li><li><a href="https://book.douban.com/subject/3117898/" target="_blank" rel="noopener">《Python源码剖析》</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前段时间作为项目组的新人，我做了一个技术分享：装饰器原理；这是我在面试中遇过的一道题，而当时的理解浮于表面，所以答的并不好。&lt;/p&gt;
&lt;h2 id=&quot;1-什么是装饰器&quot;&gt;&lt;a href=&quot;#1-什么是装饰器&quot; class=&quot;headerlink&quot; title=&quot;1 什么是装
      
    
    </summary>
    
    
      <category term="Python" scheme="https://brightsunp.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>几个典型的Backtracking问题</title>
    <link href="https://brightsunp.github.io/2018/11/25/%E5%87%A0%E4%B8%AA%E5%85%B8%E5%9E%8B%E7%9A%84Backtracking%E9%97%AE%E9%A2%98/"/>
    <id>https://brightsunp.github.io/2018/11/25/几个典型的Backtracking问题/</id>
    <published>2018-11-25T07:59:30.000Z</published>
    <updated>2020-08-03T03:47:49.819Z</updated>
    
    <content type="html"><![CDATA[<p>回溯（Backtracking）是一种穷举，但与brutal force有区别；回溯带了两点脑子，并不多，但brutal force一点都没带。</p><blockquote><p>第一点是回溯知道回头，一条路不通就回头换路；第二点是回溯知道剪枝，有障碍的路直接就不走。</p></blockquote><p>用回溯法解决问题，其实是虚拟树或图的DFS；方法具有普适性，但不一定是最优解；写递归函数时，可以多用几个参数，让思路更加清晰。<br>同时要注意的是，Python的变量是引用传递，本文所有题目的Java解法见 <a href="https://leetcode.com/problems/combination-sum/discuss/16502/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning" target="_blank" rel="noopener">这里</a>。</p><h2 id="0-回溯模板"><a href="#0-回溯模板" class="headerlink" title="0 回溯模板"></a>0 回溯模板</h2><p>回溯的问题类型有三种：</p><ol><li><code>Find a path to success</code> 有没有解<br>模板：返回<code>True/False</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">solve</span><span class="params">(Node n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> n is a leaf node &#123;</span><br><span class="line">        <span class="keyword">if</span> the leaf is a goal node, <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> each child c of n &#123;</span><br><span class="line">            <span class="function"><span class="keyword">if</span> <span class="title">solve</span><span class="params">(c)</span> succeeds, return <span class="keyword">true</span></span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">        return <span class="keyword">false</span></span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><code>Find all paths to success</code> 求所有解<br>模板：如果是求个数，设全局<code>count</code>，返回<code>void</code>；如果是求所有解信息，设全局<code>res[]</code>，返回<code>void</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(Node n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> n is a leaf node &#123;</span><br><span class="line">        <span class="keyword">if</span> the leaf is a goal node, count++, <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> each child c of n &#123;</span><br><span class="line">            solve(c)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><code>Find the best path to success</code> 求最优解<br>模板：设全局<code>best</code>，返回<code>void</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(Node n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> n is a leaf node &#123;</span><br><span class="line">        <span class="keyword">if</span> the leaf is a goal node, update best result, <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> each child c of n &#123;</span><br><span class="line">            solve(c)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-subsets"><a href="#1-subsets" class="headerlink" title="1 subsets"></a>1 subsets</h2><p>求所有的子集合：<a href="https://leetcode.com/problems/subsets/" target="_blank" rel="noopener">https://leetcode.com/problems/subsets/</a><br>以及拓展题：<a href="https://leetcode.com/problems/subsets-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/subsets-ii/</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">找到所有的叶子节点</span></span><br><span class="line"><span class="string">                        []        </span></span><br><span class="line"><span class="string">                   /          \        </span></span><br><span class="line"><span class="string">                  /            \     </span></span><br><span class="line"><span class="string">                 /              \</span></span><br><span class="line"><span class="string">              [1]                []</span></span><br><span class="line"><span class="string">           /       \           /    \</span></span><br><span class="line"><span class="string">          /         \         /      \        </span></span><br><span class="line"><span class="string">       [1 2]       [1]       [2]     []</span></span><br><span class="line"><span class="string">      /     \     /   \     /   \    / \</span></span><br><span class="line"><span class="string">  [1 2 3] [1 2] [1 3] [1] [2 3] [2] [3] []</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># BFS</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsets</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        res = [[]]</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            size = len(res)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(size):</span><br><span class="line">                res.append(copy.deepcopy(res[i]))</span><br><span class="line">                res[<span class="number">-1</span>].append(num)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># DFS</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution2</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsets</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        self.res = []</span><br><span class="line">        self.dfs(nums, <span class="number">0</span>, [])</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, nums, pos, tmp)</span>:</span></span><br><span class="line">        self.res.append(tmp)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(pos, len(nums)):</span><br><span class="line">            self.dfs(nums, i+<span class="number">1</span>, tmp+[nums[i]])</span><br></pre></td></tr></table></figure><h2 id="2-permutations"><a href="#2-permutations" class="headerlink" title="2 permutations"></a>2 permutations</h2><p>求全排列：<a href="https://leetcode.com/problems/permutations/" target="_blank" rel="noopener">https://leetcode.com/problems/permutations/</a><br>以及拓展题：<a href="https://leetcode.com/problems/permutations-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/permutations-ii/</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        self.res = []</span><br><span class="line">        self.dfs(nums, [])</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, nums, tmp)</span>:</span></span><br><span class="line">        <span class="comment"># when to backtrack</span></span><br><span class="line">        <span class="keyword">if</span> len(tmp) == len(nums):</span><br><span class="line">            <span class="keyword">return</span> self.res.append(tmp)</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">in</span> tmp:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            self.dfs(nums, tmp+[num])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用 used 数组“剪枝”</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution2</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permuteUnique</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        used = [<span class="keyword">False</span>] * len(nums)</span><br><span class="line">        self.res = []</span><br><span class="line">        self.dfs(nums, [], used)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, nums, tmp, used)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(tmp) == len(nums):</span><br><span class="line">            <span class="keyword">return</span> self.res.append(tmp)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="comment"># use same number only if its previous is used</span></span><br><span class="line">            <span class="keyword">if</span> used[i] <span class="keyword">or</span> (i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i<span class="number">-1</span>] <span class="keyword">and</span> <span class="keyword">not</span> used[i<span class="number">-1</span>]):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            used[i] = <span class="keyword">True</span></span><br><span class="line">            self.dfs(nums, tmp+[nums[i]], used)</span><br><span class="line">            used[i] = <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h2 id="3-combination-sum"><a href="#3-combination-sum" class="headerlink" title="3 combination sum"></a>3 combination sum</h2><p>求和为定值的所有组合：<a href="https://leetcode.com/problems/combination-sum/" target="_blank" rel="noopener">https://leetcode.com/problems/combination-sum/</a><br>以及拓展题：<a href="https://leetcode.com/problems/combination-sum-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/combination-sum-ii/</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, candidates, target)</span>:</span></span><br><span class="line">        self.res = []</span><br><span class="line">        self.dfs(candidates, target, <span class="number">0</span>, [])</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, nums, target, pos, tmp)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> target &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">elif</span> target == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.res.append(tmp)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(pos, len(nums)):</span><br><span class="line">            <span class="comment"># not i+1: same numbers reused</span></span><br><span class="line">            self.dfs(nums, target-nums[i], i, tmp+[nums[i]])</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution2</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, candidates, target)</span>:</span></span><br><span class="line">        candidates.sort()</span><br><span class="line">        self.res = []</span><br><span class="line">        self.dfs(candidates, target, <span class="number">0</span>, [])</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, nums, target, pos, tmp)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> target &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">elif</span> target == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.res.append(tmp)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(pos, len(nums)):</span><br><span class="line">            <span class="comment"># nums.sort() and skip duplicates in self.res</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; pos <span class="keyword">and</span> nums[i] == nums[i<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># i+1: each number used once</span></span><br><span class="line">            self.dfs(nums, target-nums[i], i+<span class="number">1</span>, tmp+[nums[i]])</span><br></pre></td></tr></table></figure><h2 id="4-palindrome-partitioning"><a href="#4-palindrome-partitioning" class="headerlink" title="4 palindrome partitioning"></a>4 palindrome partitioning</h2><p>求回文子字符串切分的所有组合：<a href="https://leetcode.com/problems/palindrome-partitioning/" target="_blank" rel="noopener">https://leetcode.com/problems/palindrome-partitioning/</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        self.res = []</span><br><span class="line">        self.dfs(s, <span class="number">0</span>, [])</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, s, pos, tmp)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> pos == len(s):</span><br><span class="line">            <span class="keyword">return</span> self.res.append(tmp)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(pos, len(s)):</span><br><span class="line">            <span class="keyword">if</span> self.isPalindrome(s, pos, i):</span><br><span class="line">                self.dfs(s, i+<span class="number">1</span>, tmp+[s[pos:i+<span class="number">1</span>]])</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, s, lo, hi)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">            <span class="keyword">if</span> s[lo] != s[hi]:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            lo += <span class="number">1</span></span><br><span class="line">            hi -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;回溯（Backtracking）是一种穷举，但与brutal force有区别；回溯带了两点脑子，并不多，但brutal force一点都没带。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;第一点是回溯知道回头，一条路不通就回头换路；第二点是回溯知道剪枝，有障碍的路直接就不走。
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://brightsunp.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>爬虫项目的总结</title>
    <link href="https://brightsunp.github.io/2018/11/19/%E7%88%AC%E8%99%AB%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>https://brightsunp.github.io/2018/11/19/爬虫项目的总结/</id>
    <published>2018-11-19T06:10:24.000Z</published>
    <updated>2020-08-03T03:47:49.813Z</updated>
    
    <content type="html"><![CDATA[<p>近期开发了一个很不错的项目，其中数据挖掘是关键，我负责的是网页爬虫部分；爬虫过程中遇到了不少问题，基本都是自己独立解决，用到的知识点结合了前端、网络协议、正则表达式、数据结构、分治法，我认为这是个很好的实战项目。</p><h2 id="1-爬虫目的"><a href="#1-爬虫目的" class="headerlink" title="1 爬虫目的"></a>1 爬虫目的</h2><blockquote><p>从我国的政府网站中，搜集各级政府的领导简介页面。</p></blockquote><p>我花费了不少精力调研各级政府网站的特点，最后采取的思路如下：</p><blockquote><p>从国务院的网站出发，一层层抓取下属机关的链接，同时针对各层级的政府网站，找到对应的领导简介页面。</p></blockquote><p><img src="/img/政府层级图.jpg" alt=""></p><h2 id="2-爬虫策略"><a href="#2-爬虫策略" class="headerlink" title="2 爬虫策略"></a>2 爬虫策略</h2><p>爬虫策略在数据结构上的体现是：<code>树+队列</code>。</p><blockquote><p>树是为了<strong>按层级存储爬虫的结果</strong>，设计的每个节点都包含3部分：当前url、对应的领导页面url列表、指向的下属机构节点列表；<br>以 <a href="http://www.gov.cn/" target="_blank" rel="noopener">www.gov.cn/</a> 或 <a href="http://中国政府网.政务" target="_blank" rel="noopener">中国政府网.政务</a> 作为根节点的url，从上往下构建树结构，通过BFS遍历即可。我们一共需要四层：国家级、省部级、市局级、县处级。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GovNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    树节点：值为当前url和找到的多个领导页面url，指向的是多个下属机构节点</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, url)</span>:</span></span><br><span class="line">        self.base_url = url</span><br><span class="line">        self.leader_urls = []</span><br><span class="line">        self.sub_nodes = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">traverse</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    遍历树：BFS</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    queue = [root]</span><br><span class="line">    level = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">            node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            print(<span class="string">'第&#123;&#125;层 &#123;&#125; 对应的领导页面有：&#123;&#125;'</span>.format(level, node.base_url, <span class="string">', '</span>.join(node.leader_urls)))</span><br><span class="line">            <span class="keyword">for</span> sub_node <span class="keyword">in</span> node.sub_nodes:</span><br><span class="line">                queue.append(sub_node)</span><br><span class="line">        level += <span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p>队列是为了<strong>控制url的访问顺序</strong>，避免重复访问。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    访问队列：unvisited是当前层级的待访问url列表，visited是所有已访问的url列表</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.visited = []</span><br><span class="line">        self.unvisited = []</span><br><span class="line">        <span class="comment"># 需要过滤的域名</span></span><br><span class="line">        self.domain_urls = &#123;<span class="string">'mail.gov.cn'</span>, <span class="string">'english.gov.cn'</span>, <span class="string">'sousuo.gov.cn'</span>, <span class="string">'www.beian.gov.cn'</span>, <span class="string">'www.miitbeian.gov.cn'</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push_unvisited</span><span class="params">(self, url)</span>:</span></span><br><span class="line">        url = url.strip()</span><br><span class="line">        domain_url = urlparse(url)[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> url <span class="keyword">not</span> <span class="keyword">in</span> self.unvisited <span class="keyword">and</span> url <span class="keyword">not</span> <span class="keyword">in</span> self.visited <span class="keyword">and</span> domain_url <span class="keyword">not</span> <span class="keyword">in</span> self.domain_urls:</span><br><span class="line">            self.unvisited.append(url)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop_unvisited</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.unvisited.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push_visited</span><span class="params">(self, url)</span>:</span></span><br><span class="line">        self.visited.append(url)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">count_unvisited</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.unvisited)</span><br></pre></td></tr></table></figure><h2 id="3-爬虫主体"><a href="#3-爬虫主体" class="headerlink" title="3 爬虫主体"></a>3 爬虫主体</h2><p>定义好数据结构后，如何由每个节点的当前url，找到对应的领导页面，以及指向的下属机构节点，这些是数据挖掘的关键。<br>通过分析政府网站的共同特征，我最后的实施办法如下：</p><blockquote><p>第一步，抓取当前url的html源码，从当前页面和 <code>frame</code> 标签中的页面（js动态生成的不考虑），提取所有的链接；<br>第二步，判断不在以前节点的下属列表中的所有外链为此节点的下属列表（有点绕），找到“网站地图”所在的 <code>a</code> 标签链接；<br>第三步，根据“网站地图”找到“领导”的汇总页面，一般是个目录，取这个目录下的所有链接，即为领导页面url列表。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spider</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    爬虫主程序</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, root_url)</span>:</span></span><br><span class="line">        self.queue = Queue()</span><br><span class="line">        self.queue.push_unvisited(root_url)</span><br><span class="line">        self.cur_deepth = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">crawler</span><span class="params">(self, crawl_deepth=<span class="number">4</span>)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        主爬取，根据深度进行爬取层级控制：国家级、省部级、市厅级、县处级</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">while</span> self.cur_deepth &lt;= crawl_deepth:</span><br><span class="line">            level_count = len(self.queue.unvisited)</span><br><span class="line">            print(<span class="string">'url count at level_&#123;&#125;: &#123;&#125;'</span>.format(self.cur_deepth, level_count))</span><br><span class="line">            <span class="keyword">while</span> level_count:</span><br><span class="line">                url = self.queue.pop_unvisited()</span><br><span class="line">                print(level_count, url)</span><br><span class="line">                begin_count = self.queue.count_unvisited</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    sub_urls = self.get_sub_urls(url)</span><br><span class="line">                <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                    <span class="comment"># 打印爬虫过程中的网络中断、访问拒绝等错误</span></span><br><span class="line">                    print(<span class="string">'error occured:'</span>, e)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">for</span> sub_url <span class="keyword">in</span> sub_urls:</span><br><span class="line">                        self.queue.push_unvisited(sub_url)</span><br><span class="line">                    end_count = self.queue.count_unvisited</span><br><span class="line">                    print(<span class="string">'sub_url count:'</span>, end_count - begin_count)</span><br><span class="line">                <span class="keyword">finally</span>:</span><br><span class="line">                    self.queue.push_visited(url)</span><br><span class="line">                    level_count -= <span class="number">1</span></span><br><span class="line">            self.cur_deepth += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>具体的爬取细节不再详写，我后来采用了scrapy框架，让整个爬虫变得系统和结构化，所以还会有一篇关于scrapy的实践总结。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;近期开发了一个很不错的项目，其中数据挖掘是关键，我负责的是网页爬虫部分；爬虫过程中遇到了不少问题，基本都是自己独立解决，用到的知识点结合了前端、网络协议、正则表达式、数据结构、分治法，我认为这是个很好的实战项目。&lt;/p&gt;
&lt;h2 id=&quot;1-爬虫目的&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="Web" scheme="https://brightsunp.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>推荐系统之中文分词、文本去重与特征提取</title>
    <link href="https://brightsunp.github.io/2018/11/10/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E4%B9%8B%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E3%80%81%E6%96%87%E6%9C%AC%E5%8E%BB%E9%87%8D%E4%B8%8E%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/"/>
    <id>https://brightsunp.github.io/2018/11/10/推荐系统之中文分词、文本去重与特征提取/</id>
    <published>2018-11-10T13:41:01.000Z</published>
    <updated>2020-08-03T03:47:49.805Z</updated>
    
    <content type="html"><![CDATA[<p>近期做了一个文章推荐系统，数据量有20w左右，不管采用哪种ML模型，数据预处理都是必须的。<br>考虑到信息安全，我只对数据预处理的思路进行了总结：中文分词、文本去重、特征提取。</p><h2 id="1-中文分词"><a href="#1-中文分词" class="headerlink" title="1 中文分词"></a>1 中文分词</h2><p>我们的数据格式是 <code>csv</code>，其中每一行代表着一篇文章，样例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">94336,原创歌曲《你好雷锋》| 我校学生眼中的雷锋,95后大学生眼中的雷锋,南昌工程学院,20180307,点击上方蓝色文字关注公众号“一滴水只有放进大海里才永远不会干涸，一个人只有当他把自己和集体事业融合在一起的时候才能最有力量。一朵鲜花打扮不出美丽的春天，一个人先进总是单枪匹马，众人先进才能移山填海。” ——摘自雷锋日记雷锋一个做好事不留名的人一个做好事长留人心的人他曾说要把有限的生命投入到无限的“为人民服务”之中践行雷锋精神，争做志愿先锋在“向雷锋同志学习”55周年来临之际我校宋逸杰同学创作歌曲《你好雷锋》与同学们一起自编自导原创歌曲V唱出江西高校学子对新时代雷锋精神内涵的理解原创歌曲：《你好雷锋》作词 / 作曲/ 演唱：宋逸杰学习雷锋，好榜样“学雷锋，做好事”雷锋就是这样的一个人一个用自己短暂的22年人生为大家诠释了奉献，大爱与信仰即使已离开半个多世纪但却一直活在我们的心底当看到好人好事时，我们会想起他的名字当我们帮助他人后，会留下他的名字他 —— 就是雷锋  歌词：你好雷锋老师常说有一个平凡英雄他的名字就叫做雷锋他虽然年纪不大只是个青年但是不怕苦累有着奉献的梦虽然他只是个小小战士却毫无畏惧所有的艰险无论身在何方当你需要时他都伸出双手绽放笑容.......</span><br></pre></td></tr></table></figure></p><p>使用 <a href="https://github.com/fxsjy/jieba" target="_blank" rel="noopener">jieba分词</a> 来处理文本：<br>对分词结果进行停用词过滤，同时过滤掉单字符、非中文词汇；<br>根据试分词结果再更新停用词库，比如“点击”“二维码”等词明显不属于文章内容。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, config)</span></span></span><br><span class="line">    stopword = config.get_config('stop_words')['file']</span><br><span class="line">    <span class="keyword">with</span> open(stopword, encoding=<span class="string">'utf8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        self.stopwords = &#123;line.strip() <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines()&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_jieba_arr</span><span class="params">(self, content)</span>:</span></span><br><span class="line">    words = jieba.cut(content)</span><br><span class="line">    <span class="keyword">return</span> list(filter(self.is_valid_word, words))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_valid_word</span><span class="params">(self, word)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> re.compile(<span class="string">'[\u4E00-\u9FA5]'</span>).match(word) <span class="keyword">and</span> len(word)&gt;<span class="number">1</span> <span class="keyword">and</span> word <span class="keyword">not</span> <span class="keyword">in</span> self.stopwords</span><br></pre></td></tr></table></figure></p><p>对于每一篇文章，对我们有用的信息是文章id、文章标题和文章正文：id用来标识和存储，<code>标题 + 正文</code> 用来做推荐。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_article_participle</span><span class="params">(self, article_path, participle_path)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> self.get_source_content(article_path):</span><br><span class="line">            tmp = line.split(<span class="string">','</span>)</span><br><span class="line">            <span class="keyword">if</span> len(tmp) &gt; <span class="number">5</span>:</span><br><span class="line">                article_id = tmp[<span class="number">0</span>]</span><br><span class="line">                content = tmp[<span class="number">1</span>] + tmp[<span class="number">5</span>]</span><br><span class="line">                jieba_arr = self.get_jieba_arr(content)</span><br><span class="line">                save_content = article_id + <span class="string">' '</span> + <span class="string">' '</span>.join(jieba_arr)</span><br><span class="line">                <span class="keyword">with</span> open(participle_path, <span class="string">'a+'</span>, encoding=<span class="string">'utf8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    f.write(save_content + <span class="string">'\n'</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">'build_article_participle'</span> + str(e))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_source_content</span><span class="params">(self, data_file)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(data_file, encoding=<span class="string">'utf8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">            <span class="keyword">yield</span> line.strip()</span><br></pre></td></tr></table></figure></p><h2 id="2-文本去重"><a href="#2-文本去重" class="headerlink" title="2 文本去重"></a>2 文本去重</h2><p>进行20w文章数据的去重对效率和内存的要求较高，<a href="http://www.cnblogs.com/maybe2030/p/5203186.html" target="_blank" rel="noopener">simhash算法</a> 是Google进行海量网页去重的高效算法；经过调试和训练，我选取了Hamming距离不大于5，作为判定文本重复的依据。<br>另外，为了避免重复计算，我在每次利用 SimhashIndex 对象去重后，将其序列化存储，一开始报错 <code>TypeError: can&#39;t pickle _thread.RLock objects</code>。<br>提示说明 SimhashIndex 对象和线程锁有关，阅读 <code>simhash</code> 源码发现内部调用了 <code>logging</code> 模块，只是为了打印日志；我将涉及该模块的代码删除，其作为数据结构的功能不受影响，调试后顺利通过，再将自定义的 <code>simhash_lib</code> 模块加入到项目的 lib 目录。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">filter_by_simhash</span><span class="params">(self, participle_path, no_recur_path, simhash_path)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        count, index = <span class="number">0</span>, <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> os.path.exists(simhash_path):</span><br><span class="line">            count, index = joblib.load(simhash_path)</span><br><span class="line">        count_origin = count</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> self.get_source_content(participle_path):</span><br><span class="line">            content_arr = line.split()[<span class="number">1</span>:]</span><br><span class="line">            sim = Simhash(content_arr)</span><br><span class="line">            <span class="keyword">if</span> count == <span class="number">0</span>:</span><br><span class="line">                index = SimhashIndex([(str(count), sim)], k=<span class="number">5</span>)</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                <span class="keyword">with</span> open(no_recur_path, <span class="string">'a+'</span>, encoding=<span class="string">'utf8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    f.write(line + <span class="string">'\n'</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> index.get_near_dups(sim):</span><br><span class="line">                index.add(str(count), sim)</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                <span class="keyword">with</span> open(no_recur_path, <span class="string">'a+'</span>, encoding=<span class="string">'utf8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    f.write(line + <span class="string">'\n'</span>)</span><br><span class="line">        print(<span class="string">'去重后的文章总数：'</span>, count)</span><br><span class="line">        <span class="keyword">if</span> count &gt; count_origin:</span><br><span class="line">            <span class="keyword">if</span> os.path.exists(simhash_path):</span><br><span class="line">                os.remove(simhash_path)</span><br><span class="line">            joblib.dump((count, index), simhash_path)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">'filter_by_simhash'</span> + str(e))</span><br></pre></td></tr></table></figure></p><h2 id="3-特征提取"><a href="#3-特征提取" class="headerlink" title="3 特征提取"></a>3 特征提取</h2><p>数据经过分词、去重，我们取出现次数前10000的词作为词袋，同时将id和文章的对应关系存入 redis 数据库。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_vocab</span><span class="params">(self, redis, no_recur_path, vocab_path)</span>:</span></span><br><span class="line">    counter = Counter()</span><br><span class="line">    redis.delete(<span class="string">'recmd_article_index'</span>)</span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> self.get_source_content(no_recur_path):</span><br><span class="line">        tmp = line.split()</span><br><span class="line">        content_arr = tmp[<span class="number">1</span>:]</span><br><span class="line">        counter.update(content_arr)</span><br><span class="line">        redis.zadd(<span class="string">'recmd_article_index'</span>, index, tmp[<span class="number">0</span>])</span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    result = [data[<span class="number">0</span>] <span class="keyword">for</span> data <span class="keyword">in</span> counter.most_common()[:<span class="number">10000</span>]]</span><br><span class="line">    <span class="keyword">with</span> open(vocab_path, <span class="string">'w'</span>, encoding=<span class="string">'utf8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(<span class="string">'\n'</span>.join(result))</span><br></pre></td></tr></table></figure></p><p>根据词袋对每一篇文章的词汇进行过滤，用词频向量表示文章的特征，即计算所有文章的词频矩阵。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_content_arr</span><span class="params">(self, vocab_path, no_recur_path, content_path)</span>:</span></span><br><span class="line">    content_arr = list()</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(content_path):</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> self.get_source_content(content_path):</span><br><span class="line">            content_arr.append(line)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        vocabs = set()</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> self.get_source_content(vocab_path):</span><br><span class="line">            vocabs.add(line)</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> self.get_source_content(no_recur_path):</span><br><span class="line">            words = [x <span class="keyword">for</span> x <span class="keyword">in</span> line.split() <span class="keyword">if</span> x <span class="keyword">in</span> vocabs]</span><br><span class="line">            content_arr.append(<span class="string">' '</span>.join(words))</span><br><span class="line">        <span class="keyword">with</span> open(content_path, <span class="string">'w'</span>, encoding=<span class="string">'utf8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(<span class="string">'\n'</span>.join(content_arr))</span><br><span class="line">    <span class="keyword">return</span> content_arr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_tf_matrix</span><span class="params">(self, content_arr, tf_vector_path)</span>:</span></span><br><span class="line">    tf_vector = CountVectorizer()</span><br><span class="line">    tf = tf_vector.fit_transform(content_arr)</span><br><span class="line">    print(<span class="string">'Shape of tf-Matrix: '</span>, tf.shape)</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(tf_vector_path):</span><br><span class="line">        os.remove(tf_vector_path)</span><br><span class="line">    joblib.dump(tf_vector, tf_vector_path)</span><br><span class="line">    <span class="keyword">return</span> tf</span><br></pre></td></tr></table></figure></p><p>当然，也可以计算所有文章的 tf-idf 矩阵，这个就看模型的具体要求了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_tfidf_matrix</span><span class="params">(self, content_arr)</span>:</span></span><br><span class="line">    tfidf_vector = TfidfVectorizer()</span><br><span class="line">    tfidf = tfidf_vector.fit_transform(content_arr)</span><br><span class="line">    print(<span class="string">'Shape of tfidf-Matrix: '</span>, tfidf.shape)</span><br><span class="line">    <span class="keyword">return</span> tfidf</span><br></pre></td></tr></table></figure></p><p>经过上述步骤的数据预处理，特征矩阵代表了文章的词频、语料特征；再将特征矩阵塞给ML模型，训练、调参、分析和存储，最终得到了令人满意的聚类、分类结果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;近期做了一个文章推荐系统，数据量有20w左右，不管采用哪种ML模型，数据预处理都是必须的。&lt;br&gt;考虑到信息安全，我只对数据预处理的思路进行了总结：中文分词、文本去重、特征提取。&lt;/p&gt;
&lt;h2 id=&quot;1-中文分词&quot;&gt;&lt;a href=&quot;#1-中文分词&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="NLP" scheme="https://brightsunp.github.io/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>8种数据结构的总结</title>
    <link href="https://brightsunp.github.io/2018/11/05/8%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>https://brightsunp.github.io/2018/11/05/8种数据结构的总结/</id>
    <published>2018-11-05T02:43:20.000Z</published>
    <updated>2020-08-03T03:47:49.799Z</updated>
    
    <content type="html"><![CDATA[<p>1976年，国外的大神写过一本书《算法+数据结构=程序》，这个等式在40多年后的今天依然成立。<br>数据结构是计算机存储、组织数据的方式；对于特定的数据结构，有些操作效率高，有些操作效率低。我们程序员的目标是为当前问题选择最优的数据结构。<br>我复习了8种数据结构，其中囊括的算法题都选自geeksforgeeks。</p><h2 id="1-数组"><a href="#1-数组" class="headerlink" title="1 数组"></a>1 数组</h2><p>连续的内存；查找效率高，插入和删除效率低。</p><ul><li><a href="https://www.geeksforgeeks.org/to-find-smallest-and-second-smallest-element-in-an-array/" target="_blank" rel="noopener">求数组中第二小的元素</a>：one-pass</li><li><a href="https://www.geeksforgeeks.org/non-repeating-element/" target="_blank" rel="noopener">求数组中第一个不重复的元素</a>：OrderedDict</li><li><a href="https://www.geeksforgeeks.org/merge-two-sorted-arrays-o1-extra-space/" target="_blank" rel="noopener">合并两个排序好的数组</a>：mergeSort/insertSort</li><li><a href="https://www.geeksforgeeks.org/rearrange-positive-and-negative-numbers-publish/" target="_blank" rel="noopener">重排数组中的正数和负数</a></li></ul><h2 id="2-栈"><a href="#2-栈" class="headerlink" title="2 栈"></a>2 栈</h2><p>后进先出；Push/Pop/Top；入栈再出栈，也是逆序的一种。<br>Ctrl+Z，大多数应用都支持这个功能：内部实现是把之前的应用状态保存到内存中，最近的状态放在第一个。</p><ul><li><a href="https://www.geeksforgeeks.org/check-for-balanced-parentheses-in-an-expression/" target="_blank" rel="noopener">检查字符串的括号是否正确匹配</a></li><li><a href="https://www.geeksforgeeks.org/sort-stack-using-temporary-stack/" target="_blank" rel="noopener">栈排序</a>：辅助栈</li><li><a href="https://www.geeksforgeeks.org/stack-set-4-evaluation-postfix-expression/" target="_blank" rel="noopener">计算后缀表达式</a></li></ul><h2 id="3-队列"><a href="#3-队列" class="headerlink" title="3 队列"></a>3 队列</h2><p>先进先出；Enqueue/Dequeue/Top；<a href="https://docs.lvrui.io/2016/07/20/Python%E4%B8%AD%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E9%98%9F%E5%88%97queue%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">python中队列的使用</a>。</p><ul><li><a href="https://www.geeksforgeeks.org/interesting-method-generate-binary-numbers-1-n/" target="_blank" rel="noopener">将1~n转换为二进制</a>：借鉴BFS</li><li><a href="https://www.geeksforgeeks.org/reversing-first-k-elements-queue/" target="_blank" rel="noopener">将队列的前k个元素逆序</a>：辅助栈</li></ul><h2 id="4-链表"><a href="#4-链表" class="headerlink" title="4 链表"></a>4 链表</h2><p>离散的内存；查找效率低，插入和删除效率高；可以用来实现文件系统、哈希表、邻接表等。</p><ul><li><a href="https://www.geeksforgeeks.org/remove-duplicates-from-an-unsorted-linked-list/" target="_blank" rel="noopener">移除无序链表的重复元素</a>：O(n^2) -&gt; O(nLogn) -&gt; O(n)</li><li><a href="https://www.geeksforgeeks.org/reverse-a-linked-list/" target="_blank" rel="noopener">链表逆序</a></li><li><a href="https://www.geeksforgeeks.org/detect-loop-in-a-linked-list/" target="_blank" rel="noopener">判断链表是否有环</a></li></ul><h2 id="5-哈希表"><a href="#5-哈希表" class="headerlink" title="5 哈希表"></a>5 哈希表</h2><p>通常由数组实现：数组的下标为哈希值（由哈希函数计算），数组中保存的数据为值。</p><ul><li><a href="https://www.geeksforgeeks.org/find-whether-an-array-is-subset-of-another-array-set-1/" target="_blank" rel="noopener">判断数组是否为另一个数组的子集</a>：brutal -&gt; sort&amp;binarySearch -&gt; sort&amp;merge -&gt; hash</li><li><a href="https://www.geeksforgeeks.org/given-an-array-of-pairs-find-all-symmetric-pairs-in-it/" target="_blank" rel="noopener">找到数组中所有的对称组合</a>：brutal -&gt; sort&amp;binarySearch -&gt; hash</li></ul><h2 id="6-树"><a href="#6-树" class="headerlink" title="6 树"></a>6 树</h2><p>树是一种特殊的图，由节点和连接节点的边组成，最大的区别是没有循环；最常用的是二叉树、二叉查找树。</p><ul><li><a href="https://www.geeksforgeeks.org/write-a-c-program-to-find-the-maximum-depth-or-height-of-a-tree/" target="_blank" rel="noopener">树的高度</a>：递归</li><li><a href="https://www.geeksforgeeks.org/kth-largest-element-in-bst-when-modification-to-bst-is-not-allowed/" target="_blank" rel="noopener">查找BST中第k大的数</a>：中序遍历</li><li><a href="https://www.geeksforgeeks.org/print-nodes-at-k-distance-from-root/" target="_blank" rel="noopener">查找与根节点距离为k的节点</a>：递归</li><li><a href="https://www.geeksforgeeks.org/print-ancestors-of-a-given-node-in-binary-tree/" target="_blank" rel="noopener">查找某个节点的所有祖先节点</a>：递归！</li></ul><h2 id="7-前缀树"><a href="#7-前缀树" class="headerlink" title="7 前缀树"></a>7 前缀树</h2><p>（Trie/PrefixTree）实现Insert/Search，空间换时间，利用字符串的公共前缀减少无谓的字符串比较，达到提高查询效率的目的；可以实现快速检索，字典的单词查询、词频统计、搜索引擎的自动补全等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a trie node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    ALPHABET_SIZE = <span class="number">26</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.isLeaf = <span class="keyword">False</span></span><br><span class="line">        self.children = [<span class="keyword">None</span>] * ALPHABET_SIZE</span><br></pre></td></tr></table></figure><ul><li><a href="https://www.geeksforgeeks.org/counting-number-words-trie/" target="_blank" rel="noopener">统计Trie中单词的个数</a>：遍历、isLeaf节点计数</li><li><a href="https://www.geeksforgeeks.org/sorting-array-strings-words-using-trie/" target="_blank" rel="noopener">Trie为字符串数组排序</a>：前序遍历</li></ul><h2 id="8-图"><a href="#8-图" class="headerlink" title="8 图"></a>8 图</h2><p>（Graph）多个节点互相连接组成一个网络，有向图和无向图；(x, y)表示边 <code>edge</code>，即x与y顶点 <code>vertex</code> 相连，边可能有权值 <code>weight/cost</code>。<br>图的知识体系我单独做了总结，完整代码见 <a href="https://github.com/brightsunp/learn/blob/master/leetcode/learn_Graph.py" target="_blank" rel="noopener">这里</a>。<br>1）存储：邻接矩阵、邻接表<br>2）遍历：bfs、dfs<br>3）拓扑排序、判断环、判断连通性<br>4）最短路径算法：迪杰斯特拉、弗洛伊德<br>5）最小生成树算法：普利姆、克鲁斯卡尔</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Represented with adjacency lists.</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n_vertices)</span>:</span></span><br><span class="line">        self.graph = defaultdict(list)</span><br><span class="line">        self.V = n_vertices</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_edge</span><span class="params">(self, u, v)</span>:</span></span><br><span class="line">        self.graph[u].append(v)</span><br></pre></td></tr></table></figure><ul><li><a href="https://www.geeksforgeeks.org/check-given-graph-tree/" target="_blank" rel="noopener">判断图是否为树</a>：两个条件 -&gt; 没有环；连通</li><li><a href="https://www.geeksforgeeks.org/count-number-edges-undirected-graph/" target="_blank" rel="noopener">统计无向图中边的个数</a></li><li><a href="https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/" target="_blank" rel="noopener">求两个节点之间的最短距离</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1976年，国外的大神写过一本书《算法+数据结构=程序》，这个等式在40多年后的今天依然成立。&lt;br&gt;数据结构是计算机存储、组织数据的方式；对于特定的数据结构，有些操作效率高，有些操作效率低。我们程序员的目标是为当前问题选择最优的数据结构。&lt;br&gt;我复习了8种数据结构，其中
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://brightsunp.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>几个典型的DP问题</title>
    <link href="https://brightsunp.github.io/2018/11/01/%E5%87%A0%E4%B8%AA%E5%85%B8%E5%9E%8B%E7%9A%84DP%E9%97%AE%E9%A2%98/"/>
    <id>https://brightsunp.github.io/2018/11/01/几个典型的DP问题/</id>
    <published>2018-11-01T05:15:12.000Z</published>
    <updated>2020-08-03T03:47:49.792Z</updated>
    
    <content type="html"><![CDATA[<p>我最近做的专题总结包括二叉树、链表、数组、哈希表、字符串，掌握数据结构的基础后，真正解决问题还要结合算法来思考。<br>动态规划（Dynamic Programming）很容易从递归转化而来：定义一个n维数组，数组的下标是递归函数参数的取值范围，数组的元素是递归函数的返回值；从边界值开始，逐步填充数组，相当于计算递归函数值的逆过程。</p><blockquote><p>用DP分析问题的思路：1）将问题抽象化，描述为一个个状态；2）确定状态转移方程，保证每个状态能稳定推出下一个状态；3）确定边界状态值。</p></blockquote><h2 id="1-数字三角形从上到下的路径的最小和"><a href="#1-数字三角形从上到下的路径的最小和" class="headerlink" title="1 数字三角形从上到下的路径的最小和"></a>1 数字三角形从上到下的路径的最小和</h2><p>入门级DP：<a href="https://leetcode.com/problems/triangle" target="_blank" rel="noopener">https://leetcode.com/problems/triangle</a><br>用f(i, j)表示下标为(i, j)的元素到最后一行的最小和；f(0, 0)即为所求。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minTotal1</span><span class="params">(triangle)</span>:</span></span><br><span class="line">    <span class="comment"># O(n*n) space</span></span><br><span class="line">    n = len(triangle)</span><br><span class="line">    dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">    <span class="keyword">while</span> n &gt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> n == len(triangle):</span><br><span class="line">                dp[n - <span class="number">1</span>][i] = triangle[n - <span class="number">1</span>][i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[n - <span class="number">1</span>][i] = triangle[n - <span class="number">1</span>][i] + min(dp[n][i], dp[n][i + <span class="number">1</span>])</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minTotal2</span><span class="params">(triangle)</span>:</span></span><br><span class="line">    <span class="comment"># O(n) space</span></span><br><span class="line">    n = len(triangle)</span><br><span class="line">    minSum = [<span class="number">0</span>] * n</span><br><span class="line">    <span class="keyword">while</span> n &gt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> n == len(triangle):</span><br><span class="line">                minSum[i] = triangle[n - <span class="number">1</span>][i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                minSum[i] = triangle[n - <span class="number">1</span>][i] + min(minSum[i], minSum[i + <span class="number">1</span>])</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> minSum[<span class="number">0</span>]</span><br></pre></td></tr></table></figure></p><h2 id="2-连续子数组的最大和-最大积"><a href="#2-连续子数组的最大和-最大积" class="headerlink" title="2 连续子数组的最大和/最大积"></a>2 连续子数组的最大和/最大积</h2><p>与数组的结合：<a href="https://leetcode.com/problems/maximum-product-subarray" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-product-subarray</a><br>用f(i)表示以第i个数字结尾的子数组的最大和，最大积/最小积；分析如何从f(i-1)推到f(i)；f(n)即为所求。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxSumSubarray</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    res = cur_max = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums[<span class="number">1</span>:]:</span><br><span class="line">        <span class="keyword">if</span> cur_max &gt;= <span class="number">0</span>:</span><br><span class="line">            cur_max += num</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur_max = num</span><br><span class="line">        res = max(res, cur_max)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProductSubarray</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    res = cur_max = cur_min = pre_max = pre_min = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums[<span class="number">1</span>:]:</span><br><span class="line">        cur_max = max(pre_max * num, pre_min * num, num)</span><br><span class="line">        cur_min = min(pre_max * num, pre_min * num, num)</span><br><span class="line">        pre_max = cur_max</span><br><span class="line">        pre_min = cur_min</span><br><span class="line">        res = max(res, cur_max)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><h2 id="3-用1-n构成的所有BST集合"><a href="#3-用1-n构成的所有BST集合" class="headerlink" title="3 用1~n构成的所有BST集合"></a>3 用1~n构成的所有BST集合</h2><p>与二叉查找树的结合：<a href="https://leetcode.com/problems/unique-binary-search-trees-ii" target="_blank" rel="noopener">https://leetcode.com/problems/unique-binary-search-trees-ii</a><br>用f(i-1)表示1~(i-1)构成的所有BST集合；分析如何对其中的每个BST插入i节点；f(n)即为所求。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="keyword">None</span></span><br><span class="line">        self.right = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span><span class="params">(n)</span>:</span></span><br><span class="line">    dp = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line">    dp[<span class="number">0</span>].append(<span class="keyword">None</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> dp[i - <span class="number">1</span>]:</span><br><span class="line">            <span class="comment"># first insert</span></span><br><span class="line">            root = TreeNode(i)</span><br><span class="line">            root.left = deepCopy(node)</span><br><span class="line">            dp[i].append(root)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># second insert</span></span><br><span class="line">            cur = node</span><br><span class="line">            <span class="keyword">while</span> cur.right:</span><br><span class="line">                tmp = cur.right</span><br><span class="line">                root = TreeNode(i)</span><br><span class="line">                cur.right = root</span><br><span class="line">                root.left = tmp</span><br><span class="line">                dp[i].append(deepCopy(node))</span><br><span class="line">                <span class="comment"># revert cur's structure</span></span><br><span class="line">                cur.right = tmp</span><br><span class="line">                cur = cur.right</span><br><span class="line">            cur.right = TreeNode(i)</span><br><span class="line">            dp[i].append(deepCopy(node))</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deepCopy</span><span class="params">(node)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">    newNode = TreeNode(node.val)</span><br><span class="line">    newNode.left = deepCopy(node.left)</span><br><span class="line">    newNode.right = deepCopy(node.right)</span><br><span class="line">    <span class="keyword">return</span> newNode</span><br></pre></td></tr></table></figure></p><h2 id="4-字符串转换的最小编辑距离"><a href="#4-字符串转换的最小编辑距离" class="headerlink" title="4 字符串转换的最小编辑距离"></a>4 字符串转换的最小编辑距离</h2><p>与字符串的结合：<a href="https://leetcode.com/problems/edit-distance/" target="_blank" rel="noopener">https://leetcode.com/problems/edit-distance/</a><br>用f(i, j)表示 word1 第i个字符转换为 word2 第j个字符所需的最小步数；初始状态 f(0, k) = f(k, 0) = k；f(m, n)即为所求。</p><ul><li>f(i, j - 1) represents insert operation</li><li>f(i - 1, j) represents delete operation</li><li>f(i - 1, j - 1) represents replace operation</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minDistance</span><span class="params">(word1, word2)</span>:</span></span><br><span class="line">    m, n = len(word1), len(word2)</span><br><span class="line">    dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m + <span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m + <span class="number">1</span>):</span><br><span class="line">        dp[i][<span class="number">0</span>] = i</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">1</span>):</span><br><span class="line">        dp[<span class="number">0</span>][i] = i</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]:</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][j] = <span class="number">1</span> + min(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我最近做的专题总结包括二叉树、链表、数组、哈希表、字符串，掌握数据结构的基础后，真正解决问题还要结合算法来思考。&lt;br&gt;动态规划（Dynamic Programming）很容易从递归转化而来：定义一个n维数组，数组的下标是递归函数参数的取值范围，数组的元素是递归函数的返回值
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://brightsunp.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>链表逆序的实现</title>
    <link href="https://brightsunp.github.io/2018/10/26/%E9%93%BE%E8%A1%A8%E9%80%86%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://brightsunp.github.io/2018/10/26/链表逆序的实现/</id>
    <published>2018-10-26T05:39:22.000Z</published>
    <updated>2020-08-03T03:47:49.786Z</updated>
    
    <content type="html"><![CDATA[<p>链表的问题有很多种：反转、旋转、排序、环、删除节点等；遍历方式无非两种：单指针或双指针的one-pass。但解题没多少规律可循，要灵活思考，所以我觉得比二叉树的难度更大。<br>链表逆序是很基本的操作，可以衍生出多个问题，实现了三种思路，复杂度都相同：<code>时间O(n) + 空间O(1)</code>。本文的节点定义参照Leetcode。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br></pre></td></tr></table></figure></p><h2 id="1-递归思路"><a href="#1-递归思路" class="headerlink" title="1 递归思路"></a>1 递归思路</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse1</span><span class="params">(head)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    不断将head抛到当前链表的末尾，递归调用</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> (head <span class="keyword">and</span> head.next):</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    res = reverse1(head.next)</span><br><span class="line">    head.next.next = head</span><br><span class="line">    head.next = <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="2-one辅助变量"><a href="#2-one辅助变量" class="headerlink" title="2 one辅助变量"></a>2 one辅助变量</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse2</span><span class="params">(head)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    不断将head指向新的表头，并更新newHead</span></span><br><span class="line"><span class="string">    注：这个思路本质上和递归相同</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> (head <span class="keyword">and</span> head.next):</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    newHead = <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">while</span> head:</span><br><span class="line">        tmp = head.next</span><br><span class="line">        head.next = newHead</span><br><span class="line">        newHead = head</span><br><span class="line">        head = tmp</span><br><span class="line">    <span class="keyword">return</span> newHead</span><br></pre></td></tr></table></figure><h2 id="3-two辅助变量"><a href="#3-two辅助变量" class="headerlink" title="3 two辅助变量"></a>3 two辅助变量</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse3</span><span class="params">(head)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    用1个变量记录表头的变化，另1个变量循环向后操作，最后别忘了原来的head置为尾节点</span></span><br><span class="line"><span class="string">    注：理解这个思路很重要！向尾节点靠拢，有的逆序问题则是向头节点靠拢</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> (head <span class="keyword">and</span> head.next):</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    fir, sec = head, head.next</span><br><span class="line">    <span class="keyword">while</span> sec:</span><br><span class="line">        tmp = sec.next</span><br><span class="line">        sec.next = fir</span><br><span class="line">        fir = sec</span><br><span class="line">        sec = tmp</span><br><span class="line">    head.next = <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">return</span> fir</span><br></pre></td></tr></table></figure><h2 id="4-测试代码"><a href="#4-测试代码" class="headerlink" title="4 测试代码"></a>4 测试代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_ll</span><span class="params">(arr)</span>:</span></span><br><span class="line">    pre = ListNode(<span class="number">0</span>)</span><br><span class="line">    tmp = pre</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">        tmp.next = ListNode(i)</span><br><span class="line">        tmp = tmp.next</span><br><span class="line">    <span class="keyword">return</span> pre.next</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_ll</span><span class="params">(head)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> head:</span><br><span class="line">        res.append(head.val)</span><br><span class="line">        head = head.next</span><br><span class="line">    print(res)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    node = get_ll(range(<span class="number">5</span>))</span><br><span class="line">    print_ll(node)</span><br><span class="line">    node = reverse1(node)</span><br><span class="line">    print_ll(node)</span><br><span class="line">    node = reverse2(node)</span><br><span class="line">    print_ll(node)</span><br><span class="line">    node = reverse3(node)</span><br><span class="line">    print_ll(node)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;链表的问题有很多种：反转、旋转、排序、环、删除节点等；遍历方式无非两种：单指针或双指针的one-pass。但解题没多少规律可循，要灵活思考，所以我觉得比二叉树的难度更大。&lt;br&gt;链表逆序是很基本的操作，可以衍生出多个问题，实现了三种思路，复杂度都相同：&lt;code&gt;时间O(n
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://brightsunp.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>二叉树遍历的非递归实现</title>
    <link href="https://brightsunp.github.io/2018/10/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0/"/>
    <id>https://brightsunp.github.io/2018/10/23/二叉树遍历的非递归实现/</id>
    <published>2018-10-23T01:22:04.000Z</published>
    <updated>2020-08-03T03:47:49.780Z</updated>
    
    <content type="html"><![CDATA[<p>对于二叉树的问题，熟练掌握其各种遍历的实现很有必要。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val, left=None, right=None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br></pre></td></tr></table></figure><h2 id="1-递归思路"><a href="#1-递归思路" class="headerlink" title="1 递归思路"></a>1 递归思路</h2><p>递归的解法很容易，我习惯先写递归的终止条件，所以三段代码都以 <code>if not root</code> 开头。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Global variable</span></span><br><span class="line">res = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorderTraverse</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    res.append(root.val)</span><br><span class="line">    preorderTraverse(root.left)</span><br><span class="line">    preorderTraverse(root.right)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorderTraverse</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    inorderTraverse(root.left)</span><br><span class="line">    res.append(root.val)</span><br><span class="line">    inorderTraverse(root.right)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postorderTraverse</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    postorderTraverse(root.left)</span><br><span class="line">    postorderTraverse(root.right)</span><br><span class="line">    res.append(root.val)</span><br></pre></td></tr></table></figure><h2 id="2-非递归思路"><a href="#2-非递归思路" class="headerlink" title="2 非递归思路"></a>2 非递归思路</h2><p>非递归的解法一定会用到栈，关键在于入栈、出栈的判断，并按照出栈顺序打印每个节点的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preOrder</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    1. 将根节点入栈，然后出栈；</span></span><br><span class="line"><span class="string">    2. 对于出栈节点，先将其右孩子入栈，再将其左孩子入栈。</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    res, stack = [], root <span class="keyword">and</span> [root]</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        node = stack.pop()</span><br><span class="line">        res.append(node.val)</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            stack.append(node.right)</span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            stack.append(node.left)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inOrder</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    1. 不断将左孩子入栈，直到没有左孩子，开始出栈；</span></span><br><span class="line"><span class="string">    2. 对于出栈节点，指向其右孩子，重复第1步。</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    res, stack = [], []</span><br><span class="line">    <span class="keyword">while</span> root <span class="keyword">or</span> stack:</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            stack.append(root)</span><br><span class="line">            root = root.left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            root = node.right</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postOrder</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="string">'''后序遍历，难点在于判断右孩子是入栈还是出栈，所以多了“标记”这一步。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    1. 不断将左孩子入栈，直到没有左孩子，开始判断栈顶节点；</span></span><br><span class="line"><span class="string">    2. 对于栈顶节点，如果其右孩子不等于标记节点，则入栈，重复第1步，并且将标记置为None；</span></span><br><span class="line"><span class="string">    3. 如果其右孩子等于标记节点，说明右孩子为None，或者右孩子之前已入栈，则出栈，并且将标记置为出栈节点。</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    res, stack = [], []</span><br><span class="line">    markNode = <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">while</span> root <span class="keyword">or</span> stack:</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            stack.append(root)</span><br><span class="line">            root = root.left</span><br><span class="line">        <span class="keyword">elif</span> stack[<span class="number">-1</span>].right != markNode:</span><br><span class="line">            root = stack[<span class="number">-1</span>].right</span><br><span class="line">            markNode = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            markNode = stack.pop()</span><br><span class="line">            res.append(markNode.val)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="3-层次遍历"><a href="#3-层次遍历" class="headerlink" title="3 层次遍历"></a>3 层次遍历</h2><p>层次遍历也就是BFS，借助队列来实现，代码形式和前序遍历相似：它们的共同点在于已知parent，对children做判断。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    1. 从根节点开始，依次出队；</span></span><br><span class="line"><span class="string">    2. 对于出列节点，先将其左孩子入队，再将其右孩子入队。</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    res, queue = [], root <span class="keyword">and</span> [root]</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        vals = []</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">            node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            vals.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">        res.append(vals)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="4-测试代码"><a href="#4-测试代码" class="headerlink" title="4 测试代码"></a>4 测试代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">'__main__'</span>:</span><br><span class="line">    node = TreeNode(<span class="number">1</span>)</span><br><span class="line">    node.left = TreeNode(<span class="number">2</span>)</span><br><span class="line">    node.left.left = TreeNode(<span class="number">4</span>)</span><br><span class="line">    node.left.right = TreeNode(<span class="number">5</span>)</span><br><span class="line">    node.left.right.left = TreeNode(<span class="number">6</span>)</span><br><span class="line">    node.right = TreeNode(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'非递归前序遍历：'</span>, preOrder(node))</span><br><span class="line">    print(<span class="string">'非递归中序遍历：'</span>, inOrder(node))</span><br><span class="line">    print(<span class="string">'非递归后序遍历：'</span>, postOrder(node))</span><br><span class="line">    print(<span class="string">'层次遍历：'</span>, levelOrder(node))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于二叉树的问题，熟练掌握其各种遍历的实现很有必要。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span c
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://brightsunp.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>从二叉树BFS开始</title>
    <link href="https://brightsunp.github.io/2018/10/22/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91BFS%E5%BC%80%E5%A7%8B/"/>
    <id>https://brightsunp.github.io/2018/10/22/从二叉树BFS开始/</id>
    <published>2018-10-22T03:01:10.000Z</published>
    <updated>2020-08-03T03:47:49.774Z</updated>
    
    <content type="html"><![CDATA[<p>我从今年5月份开始面试互联网公司，结果没拿到几个offer，究其原因，我有三点表现不足的地方：</p><ol><li>为什么来这里面试，换工作的理由不能正面地打动面试官；</li><li>算法题答不上来，对数据结构的掌握不够系统；</li><li>提前准备不充分，在面试过程中缺乏思考，所谓“凡事预则立，不预则废”。</li></ol><p>第一次失败后，我刷了大概100道Leetcode题，本以为有所提升，不再畏惧基础的算法题，结果又跌倒在二叉树的问题上。所以我决定老老实实、全面地做题，并且每周做一次总结，等待以后的厚积薄发。</p><h2 id="1-面试原题：求二叉树每一层的最小值"><a href="#1-面试原题：求二叉树每一层的最小值" class="headerlink" title="1 面试原题：求二叉树每一层的最小值"></a>1 面试原题：求二叉树每一层的最小值</h2><p>刚看到这道题，我就想到BFS的解法，无奈当时对BFS的代码实现并不理解，所以没能手写出代码。<br>其实Leetcode上有完全类似的题：<a href="https://leetcode.com/problems/find-largest-value-in-each-tree-row/" target="_blank" rel="noopener">https://leetcode.com/problems/find-largest-value-in-each-tree-row/</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestValues</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res, queue = [], root <span class="keyword">and</span> [root]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            vals = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">                node = queue.pop(<span class="number">0</span>)</span><br><span class="line">                vals.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">            res.append(max(vals))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="2-综合题：求二叉树与给定节点距离为K的所有节点"><a href="#2-综合题：求二叉树与给定节点距离为K的所有节点" class="headerlink" title="2 综合题：求二叉树与给定节点距离为K的所有节点"></a>2 综合题：求二叉树与给定节点距离为K的所有节点</h2><p>这道题在Leetcode上难度是Medium，但涉及的知识点非常综合：<a href="https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/</a><br>求距离为K的所有节点，问题转化为 <code>如何求两个节点的距离</code>，不难发现两节点距离的计算公式为：<br><code>Dist(n1, n2) = Dist(root, n1) + Dist(root, n2) - 2*Dist(root, lca)</code><br>其中，lca是n1和n2的最小公共祖先。问题又转化为 <code>如何求两个节点的最近公共祖先节点</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">distanceK</span><span class="params">(self, root, target, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type target: TreeNode</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res, queue = [], root <span class="keyword">and</span> [root]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> self.distance(root, target, node) == K:</span><br><span class="line">                res.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">distance</span><span class="params">(self, root, n1, n2)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.findLevel(root, n1) + self.findLevel(root, n2) - <span class="number">2</span>*self.findLevel(root, self.getLastCommonAncestor(root, n1, n2))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLevel</span><span class="params">(self, root, node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> root == node:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        level = self.findLevel(root.left, node)</span><br><span class="line">        <span class="keyword">if</span> level == <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> self.findLevel(root.right, node) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> level + <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLastCommonAncestor</span><span class="params">(self, root, n1, n2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> root == n1 <span class="keyword">or</span> root == n2:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        leftLca = self.getLastCommonAncestor(root.left, n1, n2)</span><br><span class="line">        rightLca = self.getLastCommonAncestor(root.right, n1, n2)</span><br><span class="line">        <span class="keyword">if</span> leftLca <span class="keyword">and</span> rightLca:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">return</span> leftLca <span class="keyword">or</span> rightLca</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我从今年5月份开始面试互联网公司，结果没拿到几个offer，究其原因，我有三点表现不足的地方：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为什么来这里面试，换工作的理由不能正面地打动面试官；&lt;/li&gt;
&lt;li&gt;算法题答不上来，对数据结构的掌握不够系统；&lt;/li&gt;
&lt;li&gt;提前准备不充分，在
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://brightsunp.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Tcpdump的使用</title>
    <link href="https://brightsunp.github.io/2018/10/22/tcpdump%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://brightsunp.github.io/2018/10/22/tcpdump的使用/</id>
    <published>2018-10-22T02:58:52.000Z</published>
    <updated>2020-08-03T03:47:49.767Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-Linux抓包原理"><a href="#1-Linux抓包原理" class="headerlink" title="1 Linux抓包原理"></a>1 Linux抓包原理</h4><p>如果要抓取其他主机 MAC 地址的数据包，必须 root 开启网卡混杂模式：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 promisc</span><br></pre></td></tr></table></figure></p><p>Linux 抓包是通过注册一种虚拟的底层网络协议，来获取对网络报文消息的处理权。原理是网卡接收到一个网络报文后，会遍历系统中所有已经注册的网络协议，于是给了抓包模块一次处理报文的机会。一般而言，用 tcpdump 抓包后，用 Wireshark 打开分析。</p><h4 id="2-tcpdump使用"><a href="#2-tcpdump使用" class="headerlink" title="2 tcpdump使用"></a>2 tcpdump使用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认网络接口</span></span><br><span class="line">tcpdump</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定网络接口</span></span><br><span class="line">tcpdump -i eth0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 两个 host 通信的数据包/ip包</span></span><br><span class="line">tcpdump host 10.37.63.255 and \(10.37.63.61 or 10.37.63.95 \)</span><br><span class="line">tcpdump -n host 10.37.63.255 and ! 10.37.63.61</span><br><span class="line">tcpdump ip -n host 10.37.63.255 and ! 10.37.63.61</span><br><span class="line"></span><br><span class="line"><span class="comment"># host 发送/接收的所有数据包</span></span><br><span class="line">tcpdump -i eth0 src host 10.37.63.3</span><br><span class="line">tcpdump -i eth0 dst host 10.37.63.3</span><br><span class="line"></span><br><span class="line"><span class="comment"># host 在 TCP 80端口的数据包</span></span><br><span class="line">tcpdump -i eth0 host 10.37.63.3 and tcp port 80</span><br><span class="line"></span><br><span class="line"><span class="comment"># SYN，ACK 包</span></span><br><span class="line">tcpdump -i eth0 <span class="string">'tcp[tcpflags] &amp; tcp-syn != 0 and tcp[tcpflags] &amp; tcp-ack != 0'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 协议过滤</span></span><br><span class="line">tcpdump -i eth0 arp</span><br><span class="line">tcpdump -i eth0 ip</span><br><span class="line">tcpdump -i eth0 tcp</span><br><span class="line">tcpdump -i eth0 udp</span><br><span class="line">tcpdump -i eth0 icmp</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-Linux抓包原理&quot;&gt;&lt;a href=&quot;#1-Linux抓包原理&quot; class=&quot;headerlink&quot; title=&quot;1 Linux抓包原理&quot;&gt;&lt;/a&gt;1 Linux抓包原理&lt;/h4&gt;&lt;p&gt;如果要抓取其他主机 MAC 地址的数据包，必须 root 开启网卡混
      
    
    </summary>
    
    
      <category term="Web" scheme="https://brightsunp.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Tcp、udp、http的区别和联系</title>
    <link href="https://brightsunp.github.io/2018/08/03/tcp%E3%80%81udp%E3%80%81http%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB/"/>
    <id>https://brightsunp.github.io/2018/08/03/tcp、udp、http的区别和联系/</id>
    <published>2018-08-03T02:57:26.000Z</published>
    <updated>2020-08-03T03:47:49.760Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>经典比喻：IP 是高速公路，允许其他协议在上面行驶，并找到其他电脑的出口；TCP 和 UDP 是高速公路上的卡车，而它们携带的货物就是 HTTP、FTP 这样的协议等。</p></blockquote><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h4><p><code>TCP: Transmission Control Protocol</code> 一种面向连接的、可靠的、基于字节流的传输层协议：</p><ul><li>建立在不可靠的网络层 IP 协议上，IP 协议并不能提供任何可靠性机制，TCP 的可靠性完全由自己实现；</li><li>采用的最基本可靠性技术：超时重传机制，原理是在发送数据后开启一个计时器，一定时间内如果没有收到ACK报文，则重新发送直到成功为止；流量控制机制，原理是让发送速率不要过快，让接收方来得及接收。</li></ul><p><code>UDP: User Datagram Protocol</code> 一种无连接的、不可靠的传输层协议：</p><ul><li>提供了有限的差错检验功能；</li><li>目的是希望以最小的开销达到网络环境中的进程通信目的。</li></ul><p><code>HTTP: HyperText Transfer Protocol</code> 一种用于分布式、协作式、超媒体信息系统的应用层协议：</p><ul><li>利用 TCP 在Web服务器和客户端之间传输信息，包括 HTTP 请求、响应、代理等。</li></ul><h4 id="2-TCP三次握手"><a href="#2-TCP三次握手" class="headerlink" title="2 TCP三次握手"></a>2 TCP三次握手</h4><ul><li>第一次握手：客户端向服务器发送请求报文，其中同步位 <code>SYN=1</code>，初始序号 <code>ISN=x</code>，等待服务器确认；</li><li>第二次握手：服务器收到请求，如果同意建立连接，就发回一个确认报文，其中同步位 <code>SYN=1</code>，确认号 <code>ACK=x+1</code>， 初始序号 <code>ISN=y</code>；</li><li>第三次握手：客户端收到服务器的确认报文，还需要给服务器发送确认包，其中 <code>ACK=y+1</code>，进而完成握手。</li></ul><p>为了保证服务器能接收到客户端的信息，并能做出正确的应答，进行了前两次握手；为了保证客户端能接收到服务器的信息，并能做出正确的应答，进行了后两次握手；由此客户端与服务器建立起可靠的双工的连接，开始传输数据。</p><h4 id="3-TCP、UDP的比较"><a href="#3-TCP、UDP的比较" class="headerlink" title="3 TCP、UDP的比较"></a>3 TCP、UDP的比较</h4><ol><li>TCP 需要建立连接，收到报文后需要给出确认；UDP 不需要建立连接，也不需要给出任何确认。</li><li>TCP 用于有必要实现可靠传输的情形；UDP 用于对高速传输和实时性要较高要求的通信或广播通信。</li><li>趋势：网速的提升让 UDP 以其简单、传输快的优势，在越来越多场景下取代了 TCP，如网页浏览、流媒体、实时游戏、物联网等。</li></ol><h4 id="4-五类IP地址"><a href="#4-五类IP地址" class="headerlink" title="4 五类IP地址"></a>4 五类IP地址</h4><p>4字节共32bit的数字，每段8位，段与段之间用句点分隔。IP地址由两部分组成，即网络号（Internet 的一个子网）和主机号（子网的某台主机）；只有一个网络号下的计算机之间才能“直接”互通，不同网络号的计算机要通过网关才能互通。</p><table><thead><tr><th>类别</th><th>开头</th><th>首段范围</th><th>主机号bit</th><th>网络规模</th></tr></thead><tbody><tr><td>A</td><td>0</td><td>0~127</td><td>24</td><td>大型</td></tr><tr><td>B</td><td>10</td><td>128~191</td><td>16</td><td>中等</td></tr><tr><td>C</td><td>110</td><td>192~223</td><td>8</td><td>小型</td></tr><tr><td>D</td><td>1110</td><td>224~239</td><td>-</td><td>-</td></tr><tr><td>E</td><td>11110</td><td>240~247</td><td>-</td><td>-</td></tr></tbody></table><p><strong>环回接口</strong><br>Loopback Interface，允许运行在同一台主机上的客户端程序、服务器程序，通过 TCP/IP 进行通信。根据惯例大多数系统把 127.0.0.1 预留给这个接口，并命名为 localhost，传给 lo 的IP数据报不能在任何网络上出现；lo 同样完成了传输层和网络层的所有过程，只是当IP数据报离开网络层时把它返回给自己。</p><p><strong>TCP首部</strong><br>封装在 IP 数据报中：<code>IP首部 + TCP首部 + TCP数据</code><br><code>URG</code> 紧急指针有效<br><code>ACK</code> 确认序号有效<br><code>PSH</code> P 尽可能快地将数据送往接收进程<br><code>RST</code> R 复位连接<br><code>SYN</code> S 同步序号<br><code>FIN</code> F 发送方完成发送任务</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;经典比喻：IP 是高速公路，允许其他协议在上面行驶，并找到其他电脑的出口；TCP 和 UDP 是高速公路上的卡车，而它们携带的货物就是 HTTP、FTP 这样的协议等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;1-概念&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="Web" scheme="https://brightsunp.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Python实现简单的HttpServer</title>
    <link href="https://brightsunp.github.io/2018/08/01/Python%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84HttpServer/"/>
    <id>https://brightsunp.github.io/2018/08/01/Python实现简单的HttpServer/</id>
    <published>2018-08-01T02:54:23.000Z</published>
    <updated>2020-08-03T03:47:49.753Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-http-原理"><a href="#1-http-原理" class="headerlink" title="1 http 原理"></a>1 http 原理</h4><p>http 是基于 TCP/IP 通信协议来传递数据（html 文件、图片、查询结果等），包括以下概念：请求方法、消息结构、状态码、响应头等。</p><p><strong>请求方法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET     #请求指定的页面，并返回 entity 主体</span><br><span class="line">HEAD    #类似于 GET，只返回响应头</span><br><span class="line">POST    #向指定资源提交数据处理请求，如提交表单、上传文件；可能导致新资源的建立、已有资源的修改</span><br><span class="line"></span><br><span class="line">PUT     #用传输的数据取代指定的文档的内容</span><br><span class="line">DELETE  #请求服务器删除指定的页面</span><br></pre></td></tr></table></figure></p><p><strong>请求消息（客户端）</strong><br>分别是：请求行、请求头、空行、请求数据（POST 等方法）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /hello.txt HTTP/1.1</span><br><span class="line">User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3</span><br><span class="line">Host: www.example.com</span><br><span class="line">Accept-Language: en, mi</span><br></pre></td></tr></table></figure></p><p><strong>响应消息（服务端）</strong><br>分别是：状态行、响应头、空行、响应正文。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Mon, 27 Jul 2009 12:28:53 GMT</span><br><span class="line">Server: Apache</span><br><span class="line">Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT</span><br><span class="line">ETag: &quot;34aa387-d-1568eb00&quot;</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Content-Length: 51</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">Content-Type: text/plain</span><br><span class="line"></span><br><span class="line">Hello world! My payload includes a trailing CR/LF.</span><br></pre></td></tr></table></figure></p><h4 id="2-Python-简单实现"><a href="#2-Python-简单实现" class="headerlink" title="2 Python 简单实现"></a>2 Python 简单实现</h4><p><strong>BaseHTTPRequestHandler 类</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">BaseHTTPRequestHandler.path                    <span class="comment"># 包含的请求路径和GET请求的数据</span></span><br><span class="line">BaseHTTPRequestHandler.command                 <span class="comment"># 请求类型GET、POST...</span></span><br><span class="line">BaseHTTPRequestHandler.request_version         <span class="comment"># 请求的协议类型HTTP/1.0、HTTP/1.1</span></span><br><span class="line">BaseHTTPRequestHandler.headers                 <span class="comment"># 请求的头</span></span><br><span class="line">BaseHTTPRequestHandler.responses               <span class="comment"># HTTP错误代码及对应错误信息的字典</span></span><br><span class="line">BaseHTTPRequestHandler.handle()                <span class="comment"># 用于处理某一连接对象的请求，调用handle_one_request方法处理</span></span><br><span class="line">BaseHTTPRequestHandler.handle_one_request()    <span class="comment"># 根据请求类型调用do_XXX()方法，XXX为请求类型</span></span><br><span class="line">BaseHTTPRequestHandler.do_XXX()                <span class="comment"># 处理请求</span></span><br><span class="line">BaseHTTPRequestHandler.send_error()            <span class="comment"># 发送并记录一个完整的错误回复到客户端,内部调用send_response()方法实现</span></span><br><span class="line">BaseHTTPRequestHandler.send_response()         <span class="comment"># 发送一个响应头并记录已接收的请求</span></span><br><span class="line">BaseHTTPRequestHandler.send_header()           <span class="comment"># 发送一个指定的HTTP头到输出流。 keyword 应该指定头关键字，value 指定它的值</span></span><br><span class="line">BaseHTTPRequestHandler.end_headers()           <span class="comment"># 发送一个空白行，标识发送HTTP头部结束</span></span><br><span class="line">BaseHTTPRequestHandler.wfile    <span class="comment"># 应答的HTTP文本流对象，可写入应答信息</span></span><br><span class="line">BaseHTTPRequestHandler.rfile    <span class="comment"># 请求的HTTP文本流对象，可读取请求信息</span></span><br></pre></td></tr></table></figure></p><p><strong>代码示例</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> BaseHTTPServer <span class="keyword">import</span> BaseHTTPRequestHandler, HTTPServer</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServerHandler</span><span class="params">(BaseHTTPRequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_set_headers</span><span class="params">(self, status=<span class="number">200</span>)</span>:</span></span><br><span class="line">        self.send_response(status)</span><br><span class="line">        self.send_header(<span class="string">'Content-type'</span>, <span class="string">'text/html'</span>)</span><br><span class="line">        self.send_header(<span class="string">"test"</span>, <span class="string">"This is test!"</span>)</span><br><span class="line">        self.end_headers()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_GET</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._set_headers()</span><br><span class="line">        buf = <span class="string">'''&lt;!DOCTYPE HTML&gt;</span></span><br><span class="line"><span class="string">        &lt;html&gt;</span></span><br><span class="line"><span class="string">            &lt;head&gt;&lt;title&gt;Index page&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">            &lt;body&gt;Hello, world!&lt;/body&gt;</span></span><br><span class="line"><span class="string">        &lt;/html&gt;'''</span></span><br><span class="line">        self.wfile.write(buf)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_HEAD</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._set_headers()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_POST</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._set_headers()</span><br><span class="line">        <span class="comment"># 获取post提交的数据</span></span><br><span class="line">        datas = self.rfile.read(int(self.headers[<span class="string">'Content-Length'</span>]))</span><br><span class="line">        datas = urllib.unquote(datas)</span><br><span class="line">        print(self.headers)</span><br><span class="line">        print(datas)</span><br><span class="line"></span><br><span class="line">        buf = <span class="string">'''&lt;!DOCTYPE HTML&gt;</span></span><br><span class="line"><span class="string">        &lt;html&gt;</span></span><br><span class="line"><span class="string">            &lt;head&gt;&lt;title&gt;Post page&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">            &lt;body&gt;Post Data:%s  &lt;br /&gt;Path:%s&lt;/body&gt;</span></span><br><span class="line"><span class="string">        &lt;/html&gt;'''</span> % (datas, self.path)</span><br><span class="line">        self.wfile.write(buf)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_server</span><span class="params">(handler_class=ServerHandler, port=<span class="number">3100</span>)</span>:</span></span><br><span class="line">    server_address = (<span class="string">''</span>, port)</span><br><span class="line">    httpd = HTTPServer(server_address, handler_class)</span><br><span class="line">    print(<span class="string">'Starting httpd...'</span>)</span><br><span class="line">    httpd.serve_forever()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    run_server()</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-http-原理&quot;&gt;&lt;a href=&quot;#1-http-原理&quot; class=&quot;headerlink&quot; title=&quot;1 http 原理&quot;&gt;&lt;/a&gt;1 http 原理&lt;/h4&gt;&lt;p&gt;http 是基于 TCP/IP 通信协议来传递数据（html 文件、图片、查询结果等
      
    
    </summary>
    
    
      <category term="Python" scheme="https://brightsunp.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Go接口的继承、组合</title>
    <link href="https://brightsunp.github.io/2018/08/01/Go%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BB%A7%E6%89%BF%E3%80%81%E7%BB%84%E5%90%88/"/>
    <id>https://brightsunp.github.io/2018/08/01/Go接口的继承、组合/</id>
    <published>2018-08-01T02:50:11.000Z</published>
    <updated>2020-08-03T03:47:49.745Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Go 在定义的 interface 中说明了它有哪些方法，类似于 c++ 中的基类定义；然后在其他函数中，将该 interface 类型作为函数的形参，则任意实现了 interface 类型的实参都是该 interface 的实例对象。这种“继承”关系是隐式的，并且一个类型可以实现多个接口。</p></blockquote><h4 id="1-多继承"><a href="#1-多继承" class="headerlink" title="1 多继承"></a>1 多继承</h4><p>代码示例：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> base <span class="keyword">interface</span> &#123; <span class="comment">//类似基类定义</span></span><br><span class="line">    virtualfunc() <span class="keyword">int</span> <span class="comment">//类似虚函数抽象定义</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> der1 <span class="keyword">int</span> <span class="comment">//类似派生类1定义</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(der1)</span> <span class="title">virtualfunc</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="comment">//类似派生类1虚函数具体实现</span></span><br><span class="line">    fmt.Printf(<span class="string">"I'm der1\n"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> der2 <span class="keyword">struct</span> &#123; <span class="comment">//类似派生类2定义</span></span><br><span class="line">    <span class="comment">//nothing</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(der2)</span> <span class="title">virtualfunc</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="comment">//类似派生类2虚函数具体实现</span></span><br><span class="line">    fmt.Printf(<span class="string">"I'm der2\n"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">somefunc</span><span class="params">(b base)</span></span> &#123; <span class="comment">//作为某个函数的形参</span></span><br><span class="line">    b.virtualfunc()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-组合"><a href="#2-组合" class="headerlink" title="2 组合"></a>2 组合</h4><p>代码示例：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> Base <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// nothing</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Base)</span> <span class="title">ShowA</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"showA"</span>)</span><br><span class="line">    b.ShowB()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Base)</span> <span class="title">ShowB</span><span class="params">()</span></span> &#123; <span class="comment">//始终保持b.showB()方法，不会被重写</span></span><br><span class="line">    fmt.Println(<span class="string">"showB"</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> Derived <span class="keyword">struct</span> &#123;</span><br><span class="line">    Base</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Derived)</span> <span class="title">ShowB</span><span class="params">()</span></span> &#123; <span class="comment">//仅实现了d.ShowB()方法</span></span><br><span class="line">    fmt.Println(<span class="string">"Derived showB"</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    d := Derived&#123;&#125;</span><br><span class="line">    d.ShowA()</span><br><span class="line">    <span class="comment">//输出：showA showB</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Go 在定义的 interface 中说明了它有哪些方法，类似于 c++ 中的基类定义；然后在其他函数中，将该 interface 类型作为函数的形参，则任意实现了 interface 类型的实参都是该 interface 的实例对象。这种“继承”
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://brightsunp.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Go协程同步</title>
    <link href="https://brightsunp.github.io/2018/08/01/Go%E5%8D%8F%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    <id>https://brightsunp.github.io/2018/08/01/Go协程同步/</id>
    <published>2018-08-01T02:47:13.000Z</published>
    <updated>2020-08-03T03:47:49.732Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Go 提供了 sync 包和 channel 来解决协程同步和通讯。</p></blockquote><h4 id="1-sync-WaitGroup"><a href="#1-sync-WaitGroup" class="headerlink" title="1 sync.WaitGroup"></a>1 sync.WaitGroup</h4><p>它实现了一个类似任务队列的结构，你可以向队列中加入任务，任务完成后就把任务从队列中移除；如果队列中的任务没有全部完成，队列就会触发阻塞以阻止程序继续运行。</p><p>代码示例：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(shownum <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(shownum)</span><br><span class="line">    wg.Done() <span class="comment">//任务完成，将任务队列中的任务数量-1，其实.Done就是.Add(-1)</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>) <span class="comment">//每创建一个goroutine，就把任务队列中任务的数量+1</span></span><br><span class="line">        <span class="keyword">go</span> test(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait() <span class="comment">//.Wait()这里会发生阻塞，直到队列中所有的任务结束就会解除阻塞</span></span><br><span class="line">    fmt.Println(<span class="string">"done!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-done-chan"><a href="#2-done-chan" class="headerlink" title="2 done chan"></a>2 done chan</h4><p>main goroutine 通过 done channel 等待 worker 完成任务；worker 做完任务后，只需往 channel 发送一个数据就可以通知任务完成。</p><p>代码示例：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(done <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    <span class="comment">// 通知任务已完成</span></span><br><span class="line">    done &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> worker(done)</span><br><span class="line">    <span class="comment">// 等待任务完成</span></span><br><span class="line">    &lt;-done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Go 提供了 sync 包和 channel 来解决协程同步和通讯。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;1-sync-WaitGroup&quot;&gt;&lt;a href=&quot;#1-sync-WaitGroup&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://brightsunp.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Nginx入门</title>
    <link href="https://brightsunp.github.io/2018/06/10/Nginx%E5%85%A5%E9%97%A8/"/>
    <id>https://brightsunp.github.io/2018/06/10/Nginx入门/</id>
    <published>2018-06-10T09:40:41.000Z</published>
    <updated>2020-08-03T03:47:49.725Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ol><li>对Nginx的角色认识，涉及到对Internet、对WEB、对HTTP的技术体系认识和理解；</li><li>对Nginx的功能认识，涉及到对高并发、反向代理、负载均衡等技术功能的认识和实践。<br>多读在线文档，多实践，是熟练使用Nginx的关键。</li></ol></blockquote><h4 id="1-安装、部署、运行"><a href="#1-安装、部署、运行" class="headerlink" title="1 安装、部署、运行"></a>1 安装、部署、运行</h4><p>Nginx在Linux下的安装有一些依赖关系，需安装 <code>pcre、zlib、openssl</code> 等；<br>运行windows版本的openresty，常用命令如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">start nginx</span><br><span class="line">tasklist /<span class="keyword">fi</span> <span class="string">"imagename eq nginx.exe"</span></span><br><span class="line">nginx -p %<span class="built_in">cd</span>%</span><br><span class="line">nginx -s stop</span><br><span class="line"><span class="comment"># without stopping the server</span></span><br><span class="line">nginx -s reload</span><br><span class="line"><span class="comment"># test nginx.conf</span></span><br><span class="line">curl localhost:6699/app/test_parallels -i</span><br><span class="line">taskkill /pid 520 /pid 3948 /pid 5520 /pid 11408 /F</span><br><span class="line"><span class="comment"># requires a Perl interpreter</span></span><br><span class="line">resty -e <span class="string">"ngx.say('Hello, OpenResty!')"</span></span><br></pre></td></tr></table></figure></p><h4 id="2-配置指令"><a href="#2-配置指令" class="headerlink" title="2 配置指令"></a>2 配置指令</h4><p>只有理解了nginx.conf配置文件，才能正确的、很好的使用Nginx；完成这两步后，已经可以说能够熟练使用Nginx了。<br><strong>location语法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location [模式] /uri/ &#123;...&#125;</span><br><span class="line"></span><br><span class="line">1. = 精确匹配</span><br><span class="line">2. ^~ 以某个常规字符串开头：不考虑url编码</span><br><span class="line">3. ~和~* 正则匹配：区分、不区分大小写</span><br><span class="line">4. !~和!~* 正则不匹配：区分、不区分大小写</span><br><span class="line">5. / 通用匹配：即所有请求</span><br></pre></td></tr></table></figure></p><p><strong>server示例</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    # 监听端口</span><br><span class="line">    listen 6699; </span><br><span class="line">    location / &#123;</span><br><span class="line">        default_type text/html;</span><br><span class="line">        # 外部重定向</span><br><span class="line">        rewrite_by_lua_block &#123;</span><br><span class="line">            return ngx.redirect(&apos;/foo&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    location = /foo &#123;</span><br><span class="line">        content_by_lua_block &#123;</span><br><span class="line">            ngx.say([[I am foo]])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    location = /sum &#123;</span><br><span class="line">        # 只允许内部调用</span><br><span class="line">        internal; </span><br><span class="line">        content_by_lua_block &#123;</span><br><span class="line">            ngx.sleep(0.1)</span><br><span class="line">            local args = ngx.req.get_uri_args()</span><br><span class="line">            ngx.print(tonumber(args.a) + tonumber(args.b))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location = /subduction &#123;</span><br><span class="line">        internal; </span><br><span class="line">        content_by_lua_block &#123;</span><br><span class="line">            ngx.sleep(0.1)</span><br><span class="line">            local args = ngx.req.get_uri_args()</span><br><span class="line">            ngx.print(tonumber(args.a) - tonumber(args.b))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location = /app/test_parallels &#123;</span><br><span class="line">        content_by_lua_block &#123;</span><br><span class="line">            local start_time = ngx.now()</span><br><span class="line">            # 对两个请求并行执行</span><br><span class="line">            local res1, res2 = ngx.location.capture_multi( &#123;</span><br><span class="line">                            &#123;&quot;/sum&quot;, &#123;args=&#123;a=3, b=8&#125;&#125;&#125;,</span><br><span class="line">                            &#123;&quot;/subduction&quot;, &#123;args=&#123;a=3, b=8&#125;&#125;&#125;</span><br><span class="line">                        &#125;)</span><br><span class="line">            ngx.say(&quot;status:&quot;, res1.status, &quot; response:&quot;, res1.body)</span><br><span class="line">            ngx.say(&quot;status:&quot;, res2.status, &quot; response:&quot;, res2.body)</span><br><span class="line">            ngx.say(&quot;time used:&quot;, ngx.now() - start_time)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location = /app/test_queue &#123;</span><br><span class="line">        content_by_lua_block &#123;</span><br><span class="line">            local start_time = ngx.now()</span><br><span class="line">            # 对两个请求顺序执行</span><br><span class="line">            local res1 = ngx.location.capture_multi( &#123;</span><br><span class="line">                            &#123;&quot;/sum&quot;, &#123;args=&#123;a=3, b=8&#125;&#125;&#125;</span><br><span class="line">                        &#125;)</span><br><span class="line">            local res2 = ngx.location.capture_multi( &#123;</span><br><span class="line">                            &#123;&quot;/subduction&quot;, &#123;args=&#123;a=3, b=8&#125;&#125;&#125;</span><br><span class="line">                        &#125;)</span><br><span class="line">            ngx.say(&quot;status:&quot;, res1.status, &quot; response:&quot;, res1.body)</span><br><span class="line">            ngx.say(&quot;status:&quot;, res2.status, &quot; response:&quot;, res2.body)</span><br><span class="line">            ngx.say(&quot;time used:&quot;, ngx.now() - start_time)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-Nginx-调优"><a href="#3-Nginx-调优" class="headerlink" title="3 Nginx 调优"></a>3 Nginx 调优</h4><p>通过 tsung、siege 等压测工具测试出最优的参数设置，尽可能压榨、发挥 Nginx 的性能。</p><ul><li>工作进程数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker_processes [CPU核数];</span><br></pre></td></tr></table></figure><ul><li>工作连接数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">worker_connections [默认值768];</span><br><span class="line"></span><br><span class="line">Nginx 服务器的用户最大请求数 = Processes * Connections</span><br></pre></td></tr></table></figure><ul><li>客户端缓冲</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">client_body_buffer_size 10K;</span><br><span class="line">client_header_buffer_size 1K;</span><br><span class="line">client_max_body_size 8m;</span><br><span class="line">large_client_header_buffers 2 1K;</span><br><span class="line"></span><br><span class="line">其中，client_max_body_size是客户端请求Body部分允许的最大尺寸；如果客户端发送的请求的Body部分超过此值，那么Nginx就会返回413错误，或“Request Entity Too Large”（请求实体太大）的消息。</span><br></pre></td></tr></table></figure><ul><li>超时</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">client_body_timeout 12;</span><br><span class="line">client_header_timeout 12;</span><br><span class="line">keepalive_timeout 15;</span><br><span class="line">send_timeout 10;</span><br><span class="line"></span><br><span class="line">超时设置也能显著提高性能。</span><br><span class="line">前两个指令是让服务器在客户端请求后，等待客户端的Header部分或Body部分发送完的设置；如果客户端既不发送Header部分又不发送Body部分，那么服务器会返回408错误或“Request time out”（请求超时）的错误消息。</span><br><span class="line">后面的keepalive_timeout指令，让服务器保持与客户端的活动连接维持指定的时间；Nginx将在指定时间到来后关闭客户端的连接。</span><br></pre></td></tr></table></figure><h4 id="4-开发Nginx插件"><a href="#4-开发Nginx插件" class="headerlink" title="4 开发Nginx插件"></a>4 开发Nginx插件</h4><p>Nginx并非万能的，即使Nginx的社区很庞大，也无法提供包治百病的解决方案。面对某些具体的需求，可能会遇到Nginx达不到预期效果的问题。遇到这种情况，就需要深入Nginx架构和源码，按自己的需求开放插件或模块了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;对Nginx的角色认识，涉及到对Internet、对WEB、对HTTP的技术体系认识和理解；&lt;/li&gt;
&lt;li&gt;对Nginx的功能认识，涉及到对高并发、反向代理、负载均衡等技术功能的认识和实践。&lt;br&gt;多读在线文档，多实践，是熟练使用N
      
    
    </summary>
    
    
      <category term="Web" scheme="https://brightsunp.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Lua入门</title>
    <link href="https://brightsunp.github.io/2018/06/10/Lua%E5%85%A5%E9%97%A8/"/>
    <id>https://brightsunp.github.io/2018/06/10/Lua入门/</id>
    <published>2018-06-10T09:28:20.000Z</published>
    <updated>2020-08-03T03:47:49.711Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-注释"><a href="#1-注释" class="headerlink" title="1 注释"></a>1 注释</h4><p>行注释：<code>--</code>；<br>块注释：<code>--[[注释内容]]</code>，推荐用<code>--[=[注释内容]=]</code>，其中<code>=</code>的个数前后一致。</p><h4 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2 数据类型"></a>2 数据类型</h4><p>基础类型有8种：</p><ol><li><code>nil</code><br>未初始化的变量默认为<code>nil</code>；删除一个全局变量<code>b=nil</code></li><li><code>boolean</code><br>只有false和nil视为<code>false</code>，其他值都为<code>true</code></li><li><code>number</code><br>默认只有一种<code>double</code>类型</li><li><code>string</code><br>一对单引号或双引号；表示一块字符串<code>[[]]</code>；字符串连接符<code>..</code>；长度操作符<code>#</code>；计算时数字与字符串自动转换</li><li><code>table</code><br>数组+哈希表，一种动态分配的对象，程序仅持有一个对他们的引用；注意<code>a[&#39;x&#39;]</code>和<code>a.x</code>等价，但容易出错；索引的起始值为1；包含空隙Hole的数组，#会认为nil就是结尾标记，这时应该用<code>table.maxn()</code>，Lua5.2之后该方法不存在</li><li><code>function</code><br>看做“第一类值”，可以赋给变量；允许以匿名函数的形式通过参数传递</li><li><code>thread</code><br>在Lua里主要是协同程序，跟线程差不多，拥有自己独立的栈、局部变量和指令指针，可以跟其他协同程序共享全局变量和其他大部分东西；线程可以同时多个运行，而协程任意时刻只能运行一个，并且处于运行状态的协程只有被挂起<code>suspend</code>时才会暂停。</li><li><code>userdata</code><br>用户自定义数据，可以将C/C++的任意数据类型（通常是 struct 和 指针）存储到 Lua 变量中调用。</li></ol><p>注意：对于 <code>table/userdata/function</code>，只做引用的比较，<code>a~=b</code>。</p><h4 id="3-变量"><a href="#3-变量" class="headerlink" title="3 变量"></a>3 变量</h4><ul><li>Lua中的变量全是全局变量，哪怕是语句块或是函数里，除非用 <code>local</code> 显式声明；</li><li>局部变量的作用域为从声明位置开始到所在语句块结束，缩短变量的作用域能提高代码的可读性，块作用域 <code>do-end</code>；</li><li>尽可能使用局部变量：<code>local foo = foo</code>，避免命名冲突，同时加速在当前作用域对 foo 的访问；</li><li>对 table 的索引使用方括号 <code>[]</code>，<code>.</code> 操作符是索引为字符串类型时的一种简化写法。</li></ul><h4 id="4-表达式"><a href="#4-表达式" class="headerlink" title="4 表达式"></a>4 表达式</h4><ul><li>先计算右边所有的值然后再执行赋值操作：<code>x, y = y, x</code>；</li><li>变量和值的个数不一致时：<code>a, b = 0 --b=nil</code>，<code>a, b = 0, 1, 2 --2 is ignored</code>；</li><li>and和or都是短路求值，只在需要时才评估第二个数，<code>x = x or v</code>，<code>max = (x&gt;y) and x or y</code>；</li></ul><h4 id="5-迭代器"><a href="#5-迭代器" class="headerlink" title="5 迭代器"></a>5 迭代器</h4><p>迭代器获取三个值：迭代函数、状态常量、控制变量；<br>无状态迭代器，避免创建闭包花费额外的代价；多状态迭代器，对应“多个状态信息”，将所有的状态封装到table内，作为迭代函数的唯一参数；<br>不同类型的迭代器：文件中的每行 <code>io.lines</code>，table元素 <code>pairs</code>（遍历所有的值，包括nil），数组元素 <code>ipairs</code>（不能返回nil），字符串元素 <code>string.gmatch</code>。</p><h4 id="6-函数"><a href="#6-函数" class="headerlink" title="6 函数"></a>6 函数</h4><ul><li>函数的两个用途：作为调用语句，完成指定任务；</li><li>多返回值、可变参数 <code>(fmt, …)</code>、具名实参；</li><li>支持“尾调用消除”：递归不会造成栈溢出；编写“状态机”；</li><li>判断“尾调用”：一个函数在调用完另一个函数后，是否无需做其他事情；完成一条 goto 语句到另一个函数，非传统的函数调用；<code>return &lt;func&gt;(&lt;args&gt;)</code>。</li><li>冒号操作符：面向对象式的调用，<code>o.foo(o, x)</code> 等价于 <code>o:foo(x)</code>；所有Lua标准程序库的函数都是用C语言写的，但对于Lua程序员来说是透明的。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-注释&quot;&gt;&lt;a href=&quot;#1-注释&quot; class=&quot;headerlink&quot; title=&quot;1 注释&quot;&gt;&lt;/a&gt;1 注释&lt;/h4&gt;&lt;p&gt;行注释：&lt;code&gt;--&lt;/code&gt;；&lt;br&gt;块注释：&lt;code&gt;--[[注释内容]]&lt;/code&gt;，推荐用&lt;code&gt;-
      
    
    </summary>
    
    
      <category term="Lua" scheme="https://brightsunp.github.io/tags/Lua/"/>
    
  </entry>
  
  <entry>
    <title>Lua数据结构的实现</title>
    <link href="https://brightsunp.github.io/2018/06/10/Lua%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://brightsunp.github.io/2018/06/10/Lua数据结构的实现/</id>
    <published>2018-06-10T09:26:50.000Z</published>
    <updated>2020-08-03T03:47:49.718Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>《Lua程序设计》笔记：高效地使用table来实现一些传统的数据结构</p></blockquote><h4 id="1-数组"><a href="#1-数组" class="headerlink" title="1 数组"></a>1 数组</h4><p>Lua库和长度操作符都遵循索引从1开始的约定。</p><h4 id="2-多维数组"><a href="#2-多维数组" class="headerlink" title="2 多维数组"></a>2 多维数组</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--数组的数组</span></span><br><span class="line">mt = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>, N <span class="keyword">do</span></span><br><span class="line">    mt[i] = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> j=<span class="number">1</span>, M <span class="keyword">do</span></span><br><span class="line">        mt[i][j] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--合并索引（i*常量 + j）</span></span><br><span class="line">mt = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>, N <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">for</span> j=<span class="number">1</span>, M <span class="keyword">do</span></span><br><span class="line">        mt[(i<span class="number">-1</span>)*M+j] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h4 id="3-链表、队列"><a href="#3-链表、队列" class="headerlink" title="3 链表、队列"></a>3 链表、队列</h4><p>table是动态实体，所以实现链表很方便；实现队列的话，使用table库的insert、remove。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--主要是new/pushlast/popfirst</span></span><br><span class="line">List = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">List.new</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">return</span> &#123;first=<span class="number">0</span>, last=<span class="number">-1</span>&#125;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">List.pushfirst</span><span class="params">(list, value)</span></span></span><br><span class="line">    <span class="keyword">local</span> first = list.first<span class="number">-1</span></span><br><span class="line">    list.first = first</span><br><span class="line">    list[first] = value</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">List.pushlast</span><span class="params">(list, value)</span></span></span><br><span class="line">    <span class="keyword">local</span> last = list.last+<span class="number">1</span></span><br><span class="line">    list.last = last</span><br><span class="line">    list[last] = value</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">List.popfirst</span><span class="params">(list)</span></span></span><br><span class="line">    <span class="keyword">local</span> first = list.first</span><br><span class="line">    <span class="keyword">if</span> first&gt;list.last <span class="keyword">then</span> <span class="built_in">error</span>(<span class="string">'list is empty'</span>) <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">local</span> value = list[first]</span><br><span class="line">    <span class="comment">--允许垃圾收集</span></span><br><span class="line">    list[first] = <span class="literal">nil</span></span><br><span class="line">    list.first = first+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">List.poplast</span><span class="params">(list)</span></span></span><br><span class="line">    <span class="keyword">local</span> last = list.last</span><br><span class="line">    <span class="keyword">if</span> list.first&gt;last <span class="keyword">then</span> <span class="built_in">error</span>(<span class="string">'list is empty'</span>) <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">local</span> value = list[last]</span><br><span class="line">    list[last] = <span class="literal">nil</span></span><br><span class="line">    list.last = last<span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h4 id="4-集合、包"><a href="#4-集合、包" class="headerlink" title="4 集合、包"></a>4 集合、包</h4><p>将集合元素作为索引放入table中；则对任意值都无需搜索table，直接索引即可。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set</span><span class="params">(list)</span></span></span><br><span class="line">    <span class="keyword">local</span> set = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, l <span class="keyword">in</span> <span class="built_in">ipairs</span>(list) <span class="keyword">do</span> set[l] = <span class="literal">true</span> <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> set</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bag</span><span class="params">(list)</span></span></span><br><span class="line">    <span class="keyword">local</span> bag = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, l <span class="keyword">in</span> <span class="built_in">ipairs</span>(list) <span class="keyword">do</span> bag[l] = <span class="number">1</span> <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> bag</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span><span class="params">(bag, element)</span></span></span><br><span class="line">    bag[element] = (bag[element] <span class="keyword">or</span> <span class="number">0</span>)+<span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span><span class="params">(bag, element)</span></span></span><br><span class="line">    <span class="keyword">local</span> count = bag[element]</span><br><span class="line">    <span class="comment">--递减其计数器</span></span><br><span class="line">    bag[element] = (count <span class="keyword">and</span> count&gt;<span class="number">1</span>) <span class="keyword">and</span> (count<span class="number">-1</span>) <span class="keyword">or</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h4 id="5-字符串缓冲"><a href="#5-字符串缓冲" class="headerlink" title="5 字符串缓冲"></a>5 字符串缓冲</h4><p>只要字符串是immutable值，不断的连接就会造成性能浪费。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--读文件的正确姿势</span></span><br><span class="line"><span class="keyword">local</span> t = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">io</span>.<span class="built_in">lines</span> <span class="keyword">do</span></span><br><span class="line">    t[#t+<span class="number">1</span>] = line</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--欺骗concat，在结尾处添加换行</span></span><br><span class="line">t[#t+<span class="number">1</span>] = <span class="string">''</span></span><br><span class="line"><span class="keyword">local</span> s = <span class="built_in">table</span>.<span class="built_in">concat</span>(t, <span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">--“汉诺塔”实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addString</span><span class="params">(stack, s)</span></span></span><br><span class="line">    stack[#stack+<span class="number">1</span>] = s</span><br><span class="line">    <span class="keyword">for</span> i = #stack<span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> #stack[i] &gt; #stack[i+<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment">--如果新字符串更大，则连接、压缩栈</span></span><br><span class="line">        stack[i] = stack[i] .. stack[i+<span class="number">1</span>]</span><br><span class="line">        stack[i+<span class="number">1</span>] = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;《Lua程序设计》笔记：高效地使用table来实现一些传统的数据结构&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;1-数组&quot;&gt;&lt;a href=&quot;#1-数组&quot; class=&quot;headerlink&quot; title=&quot;1 数组&quot;&gt;&lt;/a&gt;1 数组&lt;
      
    
    </summary>
    
    
      <category term="Lua" scheme="https://brightsunp.github.io/tags/Lua/"/>
    
  </entry>
  
</feed>
